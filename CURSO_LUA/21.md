# Cap√≠tulo 21: Integra√ß√£o com C (C API de Lua)

üéØ Objetivos de Aprendizagem:

-   Entender como Lua e C interagem atrav√©s da C API.
-   Criar fun√ß√µes em C que podem ser chamadas de Lua.
-   Manipular a pilha de Lua em C.
-   Registrar bibliotecas C em Lua.
-   Conhecer boas pr√°ticas de integra√ß√£o.

## 21.1 Por que Integrar Lua com C?

-   Performance: mover partes cr√≠ticas para C.
-   Integra√ß√£o: usar bibliotecas nativas do sistema ou de terceiros.
-   Extens√£o: adicionar novas funcionalidades a Lua.

## 21.2 Estrutura B√°sica de uma Fun√ß√£o C

Toda fun√ß√£o C que ser√° chamada de Lua deve ter a assinatura:

```c
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

int minha_funcao(lua_State *L) {
    // Manipula a pilha Lua
    return n; // n√∫mero de valores de retorno
}
```

üìå Observa√ß√µes:

-   Os argumentos v√™m da pilha Lua.
-   Devemos retornar quantos valores foram empilhados como sa√≠da.

## 21.3 Exemplo: Fun√ß√£o "dobrar"

Fun√ß√£o em C que dobra um n√∫mero vindo de Lua:

```c
int dobrar(lua_State *L) {
    double n = luaL_checknumber(L, 1); // pega 1¬∫ argumento
    lua_pushnumber(L, n * 2);          // empilha resultado
    return 1; // 1 valor de retorno
}
```

## 21.4 Registrando Fun√ß√µes em Lua

Precisamos registrar fun√ß√µes em uma biblioteca:

```c
static const struct luaL_Reg minha_biblioteca [] = {
    {"dobrar", dobrar},
    {NULL, NULL} // terminador
};

int luaopen_minhabiblio(lua_State *L) {
    luaL_newlib(L, minha_biblioteca);
    return 1;
}
```

üìå Isso permite importar em Lua:

```lua
local lib = require("minhabiblio")
print(lib.dobrar(10)) -- 20
```

## 21.5 Compilando o M√≥dulo

No Linux:

```sh
gcc -O2 -Wall -shared -fPIC -o minhabiblio.so minhabiblio.c -I/usr/include/lua5.4 -llua5.4
```

No Windows (MinGW):

```sh
gcc -O2 -Wall -shared -o minhabiblio.dll minhabiblio.c -I"path\to\lua\include" -L"path\to\lua\lib" -llua54
```

## 21.6 Manipulando Strings

Fun√ß√£o que recebe uma string de Lua e devolve em mai√∫sculas:

```c
int maiuscula(lua_State *L) {
    const char *str = luaL_checkstring(L, 1);
    char buf[256];
    snprintf(buf, sizeof(buf), "%s", str);

    for (int i=0; buf[i]; i++) {
        if (buf[i] >= 'a' && buf[i] <= 'z') {
            buf[i] -= 32;
        }
    }

    lua_pushstring(L, buf);
    return 1;
}
```

## 21.7 Manipulando Tabelas

Fun√ß√£o que soma todos os n√∫meros de uma tabela:

```c
int soma_tabela(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);
    double soma = 0;

    lua_pushnil(L); // primeira chave
    while (lua_next(L, 1) != 0) {
        if (lua_isnumber(L, -1)) {
            soma += lua_tonumber(L, -1);
        }
        lua_pop(L, 1); // remove valor, mant√©m chave
    }

    lua_pushnumber(L, soma);
    return 1;
}
```

Em Lua:

```lua
local lib = require("minhabiblio")
print(lib.soma_tabela({1,2,3,4})) -- 10
```

## 21.8 Chamando C de Lua e Lua de C

-   Lua ‚Üí C: usando fun√ß√µes registradas (`require`).
-   C ‚Üí Lua: usando `lua_getglobal`, `lua_pcall` etc., para chamar fun√ß√µes Lua de dentro do C.

Exemplo chamando Lua do C:

```c
lua_getglobal(L, "minha_funcao_lua");
lua_pushnumber(L, 42);
lua_pcall(L, 1, 1, 0);
double resultado = lua_tonumber(L, -1);
```

## 21.9 Boas Pr√°ticas

-   Sempre valide argumentos com luaL_check\*.
-   Evite buffer fixo pequeno em strings ‚Üí prefira aloca√ß√£o din√¢mica.
-   Documente quais fun√ß√µes sua biblioteca exporta.
-   Trate erros ao chamar Lua de dentro do C (lua_pcall).
-   Compile m√≥dulos com op√ß√µes seguras (-Wall, -O2).

Resumo

-   Lua e C se comunicam via C API.
-   Fun√ß√µes C manipulam a pilha de Lua.
-   Bibliotecas C s√£o registradas e carregadas com require.
-   Podemos manipular n√∫meros, strings e tabelas.
-   Integra√ß√£o abre caminho para extens√µes r√°pidas e poderosas.
