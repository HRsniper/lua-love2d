# Capítulo 21: Integração com C (C API de Lua)

## 21.1 Introdução à C API

### O que é a C API do Lua?

A C API é o conjunto de funções que permite que código C interaja com Lua. Ela possibilita:

-   Ler e escrever variáveis globais Lua
-   Chamar funções Lua
-   Executar código Lua
-   Registrar funções C para serem chamadas por Lua
-   E muito mais!

### Conceito Fundamental: Lua como Biblioteca

Lua não é um programa standalone - é uma **biblioteca** que pode ser incorporada em aplicações. O interpretador `lua` que usamos é apenas uma aplicação pequena (menos de 500 linhas) que usa a biblioteca Lua.

### Dois Paradigmas de Interação

**1. Lua como Linguagem de Extensão** (C controla Lua)

```c
// c_control.c

// C controla e chama Lua
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

int main(void) {
    lua_State *L = luaL_newstate();  // Cria um estado Lua
    luaL_openlibs(L);                // Abre bibliotecas padrão

    // Executa código Lua de dentro de C
    luaL_dostring(L, "print('Hello from Lua!')");

    lua_close(L);                    // Fecha o estado
    return 0;
}

/*
Saída esperada>
Hello from Lua!
*/
```

**2. Lua como Linguagem Extensível (lib)** (Lua controla C)

```c
// meumodulo.c

// Lua controla e chama C
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Função C que será chamada por Lua
static int l_somar(lua_State *L) {
    double a = lua_tonumber(L, 1);   // Pega primeiro argumento
    double b = lua_tonumber(L, 2);   // Pega segundo argumento
    lua_pushnumber(L, a + b);        // Empilha resultado
    return 1;                        // Número de resultados
}

// Função de registro do módulo
// O nome 'luaopen_meumodulo' deve bater com o nome do arquivo .so (sem o .so).
int luaopen_meumodulo(lua_State *L) {
    // Registrar a função
    lua_register(L, "somar", l_somar);
    return 0;
}
```

```lua
-- lua_control.lua

-- Adiciona o diretório atual ao caminho de busca de bibliotecas (arquivos '.so' no Linux, '.dll' no Windows)
package.cpath = "./?.so;./?.dll;" .. package.cpath
-- Carrega o módulo
require("meumodulo")
-- Usa a função registrada
print(somar(10, 5))

--[[
Saída esperada>
15
]]
```

## Como compilar/biblioteca e executar programas com a C API

```sh
# Compilar
gcc programa.c -o programa -I/usr/include/lua5.4 /usr/lib/lua5.4/liblua.a -lm -ldl # binário autossuficiente, sem depender de bibliotecas externas
# ou
gcc programa.c -o programa -llua -lm -ldl # binário leve e está em um sistema onde 'liblua.so' está disponível

# Executar
./programa

# Biblioteca
gcc -shared -fPIC meumodulo.c -o libmeumodulo.so -I/usr/include/lua5.4 /usr/lib/lua5.4/liblua.so -lm -ldl # linka diretamente com o arquivo 'liblua.so' usando o caminho absoluto
# ou
gcc -shared -fPIC meumodulo.c -o libmeumodulo.so -llua -lm -ldl # Linka usando o nome da biblioteca 'liblua.so' e depende do linker encontrar o arquivo no diretório padrão como '/usr/lib'

# Executar
lua programa.lua
```

### Exemplo Completo: Primeiro Programa com C API

```c
// primeiro_programa.c

#include <stdio.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

int main(void) {
    // Passo 1: Criar um novo estado Lua
    lua_State *L = luaL_newstate();
    if (L == NULL) {
        fprintf(stderr, "Erro ao criar estado Lua\n");
        return 1;
    }

    // Passo 2: Abrir bibliotecas padrão
    luaL_openlibs(L);

    // Passo 3: Executar código Lua simples
    if (luaL_dostring(L, "print('Olá do Lua!')") != LUA_OK) {
        fprintf(stderr, "Erro: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 1;
    }

    // Passo 4: Manipular variáveis
    lua_pushnumber(L, 42);           // Empilha o número 42
    lua_setglobal(L, "resposta");    // Define global 'resposta' = 42

    // Passo 5: Ler e usar a variável
    luaL_dostring(L, "print('A resposta é: ' .. resposta)");

    // Passo 6: Limpar e fechar
    lua_close(L);

    return 0;
}

/*
Saída esperada>
Olá do Lua!
A resposta é: 42
*/
```

---

## 21.2 A Pilha (Stack)

### Conceito da Pilha Virtual

A pilha é o componente central da comunicação entre C e Lua. Ela resolve dois problemas fundamentais:

1. **Garbage Collection vs Alocação Manual**: Lua usa coleta de lixo, C usa alocação/liberação manual
2. **Tipagem Dinâmica vs Tipagem Estática**: Lua é dinâmico, C é estático

### Visualizando a Pilha

```
   +----------------+
4  |    "nome"      |  <- topo  (índice -1)
   +----------------+
3  |     42.5       |  <-       (índice -2)
   +----------------+
2  |     true       |  <-       (índice -3)
   +----------------+
1  |     nil        |  <- fundo (índice -4)
   +----------------+
```

### Índices: Positivos e Negativos

-   **Índices Positivos**: Contam do fundo (1 = primeiro elemento)
-   **Índices Negativos**: Contam do topo (-1 = último elemento)

### Exemplo: Manipulando a Pilha

```c
// manipulando_pilha.c

#include <stdio.h>
#include <lua.h>
#include <lauxlib.h>

void imprimir_pilha(lua_State *L) {
    int topo = lua_gettop(L);
    printf("\n=== Pilha (tamanho: %d) ===\n", topo);

    for (int i = topo; i >= 1; i--) {
        int tipo = lua_type(L, i);
        printf("Índice %2d (ou %2d): ", i, i - topo - 1);

        switch (tipo) {
            case LUA_TNUMBER:
                printf("NUMBER: %.2f\n", lua_tonumber(L, i));
                break;
            case LUA_TSTRING:
                printf("STRING: '%s'\n", lua_tostring(L, i));
                break;
            case LUA_TBOOLEAN:
                printf("BOOLEAN: %s\n", lua_toboolean(L, i) ? "true" : "false");
                break;
            case LUA_TNIL:
                printf("NIL\n");
                break;
            default:
                printf("%s\n", lua_typename(L, tipo));
        }
    }
    printf("========================\n\n");
}

int main(void) {
    lua_State *L = luaL_newstate();

    printf("Pilha inicialmente vazia:\n");
    imprimir_pilha(L);

    // Empilhando valores
    printf("Empilhando valores...\n");
    lua_pushnil(L);              // Empilha nil
    lua_pushboolean(L, 1);       // Empilha true
    lua_pushnumber(L, 42.5);     // Empilha número
    lua_pushstring(L, "Lua");    // Empilha string
    imprimir_pilha(L);

    // Acessando valores
    printf("Acessando valores:\n");
    printf("Valor no índice 1: %s\n", lua_typename(L, lua_type(L, 1)));
    printf("Valor no índice -1: %s\n", lua_tostring(L, -1));
    printf("Valor no índice 3: %.2f\n", lua_tonumber(L, 3));
    printf("===\n");

    // Removendo topo
    printf("\nRemovendo elemento do topo...\n");
    lua_pop(L, 1);  // Remove 1 elemento
    imprimir_pilha(L);

    // Inserindo no meio
    printf("Inserindo 'novo' na posição 2...\n");
    lua_pushstring(L, "novo");
    lua_insert(L, 2);
    imprimir_pilha(L);

    lua_close(L);
    return 0;
}

/*
Saída esperada>
Pilha inicialmente vazia:

=== Pilha (tamanho: 0) ===
========================

Empilhando valores...

=== Pilha (tamanho: 4) ===
Índice  4 (ou -1): STRING: 'Lua'
Índice  3 (ou -2): NUMBER: 42.50
Índice  2 (ou -3): BOOLEAN: true
Índice  1 (ou -4): NIL
========================

Acessando valores:
Valor no índice 1: nil
Valor no índice -1: Lua
Valor no índice 3: 42.50
===

Removendo elemento do topo...

=== Pilha (tamanho: 3) ===
Índice  3 (ou -1): NUMBER: 42.50
Índice  2 (ou -2): BOOLEAN: true
Índice  1 (ou -3): NIL
========================

Inserindo 'novo' na posição 2...

=== Pilha (tamanho: 4) ===
Índice  4 (ou -1): NUMBER: 42.50
Índice  3 (ou -2): BOOLEAN: true
Índice  2 (ou -3): STRING: 'novo'
Índice  1 (ou -4): NIL
========================
*/
```

### Operações Básicas da Pilha

```c
// operacoes_basicas_pilha.c

#include <stdio.h>
#include <lua.h>
#include <lauxlib.h>

// Se quiser ver o estado da pilha, use a função 'imprimir_pilha' e adicione-a depois de cada operação na pilha

int main(void) {
    lua_State *L = luaL_newstate();

    // 1. PUSH - Empilhar valores
    lua_pushnumber(L, 10);
    lua_pushnumber(L, 20);
    lua_pushnumber(L, 30);
    // [10, 20, 30]
    printf("Topo da pilha: %d\n", lua_gettop(L));  // Saída: 3

    // 2. POP - Remover elementos
    lua_pop(L, 1);  // Remove 1 elemento do topo
    // [10, 20]
    printf("Após pop: %d\n", lua_gettop(L));  // Saída: 2

    // 3. SETTOP - Ajustar tamanho da pilha
    lua_settop(L, 5);  // Expande para 5 elementos (adiciona nils)
    // [10, 20, nil, nil, nil, nil]
    printf("Após settop(5): %d\n", lua_gettop(L));  // Saída: 5

    lua_settop(L, 0);  // Limpa toda a pilha
    // []
    printf("Após settop(0): %d\n", lua_gettop(L));  // Saída: 0

    // 4. PUSHVALUE - Duplicar valor
    lua_pushstring(L, "teste");
    lua_pushvalue(L, -1);  // Duplica o elemento do topo
    // ["teste", "teste"]
    printf("Elementos na pilha: %d\n", lua_gettop(L));  // Saída: 2

    // 5. REMOVE - Remove elemento específico
    lua_settop(L, 0);
    lua_pushstring(L, "primeiro");
    lua_pushstring(L, "segundo");
    lua_pushstring(L, "terceiro");
    lua_remove(L, 2);  // Remove "segundo"
    // ["primeiro", "terceiro"]
    printf("Após remoção: %d\n", lua_gettop(L));  // Saída: 2

    // 6. INSERT - Inserir em posição específica
    lua_pushstring(L, "inserido");
    lua_insert(L, 2);  // Insere na posição 2
    // ["primeiro", "inserido", "terceiro"]
    printf("Após inserção: %d\n", lua_gettop(L));  // Saída: 3

    // 7. REPLACE - Substitui elemento
    lua_pushstring(L, "substituto");
    lua_replace(L, 1);  // Substitui elemento na posição 1
    // ["substituto", "inserido", "terceiro"]
    printf("Após substituição: %d\n", lua_gettop(L));  // Saída: 3

    // 8. CHECKSTACK - Verificar espaço disponível
    if (lua_checkstack(L, 100)) {
        printf("Espaço garantido para 100 elementos\n");
    }

    lua_close(L);
    return 0;
}
```

---

## 21.3 Tratamento de Erros na C API

### Mecanismo de Erros

Lua usa `setjmp/longjmp` (similar a exceções) para tratamento de erros. Em C++, pode-se compilar com exceções reais.

### Ambientes Protegidos

```c
// tratamento_erros.c

#include <stdio.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Função que pode causar erro
int funcao_perigosa(lua_State *L) {
    const char *codigo = lua_tostring(L, 1);

    // luaL_dostring pode causar erro
    int status = luaL_dostring(L, codigo);

    if (status != LUA_OK) {
        // Erro já está no topo da pilha
        return lua_error(L);  // Propaga o erro
    }

    return 0;
}

// Função que trata erros gracefully
int funcao_segura(lua_State *L) {
    const char *codigo = lua_tostring(L, 1);

    int status = luaL_dostring(L, codigo);

    if (status == LUA_OK) {
        lua_pushboolean(L, 1);  // Sucesso
        lua_pushnil(L);         // Sem erro
        return 2;
    } else {
        lua_pushboolean(L, 0);  // Falha
        // Erro já está na pilha
        return 2;
    }
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    // Exemplo 1: Erro sem proteção
    printf("=== Exemplo 1: Erro direto ===\n");
    if (luaL_dostring(L, "error('Algo deu errado!')") != LUA_OK) {
        printf("Erro capturado: %s\n\n", lua_tostring(L, -1));
        lua_pop(L, 1);  // Remove mensagem de erro
    }

    // Exemplo 2: Usando pcall do lado Lua
    printf("=== Exemplo 2: Usando pcall ===\n");
    luaL_dostring(L, R"(
        local status, err = pcall(function()
            error('Erro dentro de pcall')
        end)

        if not status then
            print('Erro tratado:', err)
        end
    )");
    printf("\n");

    // Exemplo 3: Usando lua_pcall do lado C
    printf("=== Exemplo 3: Usando lua_pcall ===\n");

    // Carrega função que pode errar
    luaL_dostring(L, R"(
        function dividir(a, b)
            if b == 0 then
                error('Divisão por zero!')
            end
            return a / b
        end
    )");

    // Chama com proteção
    lua_getglobal(L, "dividir");
    lua_pushnumber(L, 10);
    lua_pushnumber(L, 0);

    if (lua_pcall(L, 2, 1, 0) != LUA_OK) {
        printf("Erro ao chamar função: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }
    printf("\n");

    // Exemplo 4: Handler de erro personalizado
    printf("=== Exemplo 4: Handler personalizado ===\n");

    // Define handler
    luaL_dostring(L, R"(
        function error_handler(err)
            return 'ERRO CAPTURADO: ' .. tostring(err)
        end
    )");

    // Coloca handler na pilha
    lua_getglobal(L, "error_handler");
    int handler_index = lua_gettop(L);

    // Prepara chamada
    lua_getglobal(L, "dividir");
    lua_pushnumber(L, 20);
    lua_pushnumber(L, 0);

    // lua_pcall com handler (4º parâmetro)
    if (lua_pcall(L, 2, 1, handler_index) != LUA_OK) {
        printf("%s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }

    lua_pop(L, 1);  // Remove handler

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Exemplo 1: Erro direto ===
Erro capturado: [string "error('Algo deu errado!')"]:1: Algo deu errado!

=== Exemplo 2: Usando pcall ===
Erro tratado:   [string "..."]:3: Erro dentro de pcall

=== Exemplo 3: Usando lua_pcall ===
Erro ao chamar função: [string "..."]:4: Divisão por zero!

=== Exemplo 4: Handler personalizado ===
ERRO CAPTURADO: [string "..."]:4: Divisão por zero!
*/
```

### Códigos de Status

```c
// codigos_status.c

#include <stdio.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

const char* status_para_string(int status) {
    switch (status) {
        case LUA_OK:        return "LUA_OK (sucesso)";
        case LUA_YIELD:     return "LUA_YIELD (suspendeu)";
        case LUA_ERRRUN:    return "LUA_ERRRUN (erro de execução)";
        case LUA_ERRSYNTAX: return "LUA_ERRSYNTAX (erro de sintaxe)";
        case LUA_ERRMEM:    return "LUA_ERRMEM (erro de memória)";
        case LUA_ERRERR:    return "LUA_ERRERR (erro no handler)";
        default:            return "Status desconhecido";
    }
}

void testar_codigo(lua_State *L, const char *descricao, const char *codigo) {
    printf("\n=== %s ===\n", descricao);
    printf("Código: %s\n", codigo);

    int status = luaL_loadstring(L, codigo);
    printf("Status do load: %s\n", status_para_string(status));

    if (status == LUA_OK) {
        status = lua_pcall(L, 0, 0, 0);
        printf("Status do pcall: %s\n", status_para_string(status));
    }

    if (status != LUA_OK) {
        printf("Mensagem de erro: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    // Teste 1: Código válido
    testar_codigo(L, "Código válido", "print('OK')");

    // Teste 2: Erro de sintaxe
    testar_codigo(L, "Erro de sintaxe", "print('sem fechar");

    // Teste 3: Erro de execução
    testar_codigo(L, "Erro de execução", "error('Erro proposital')");

    // Teste 4: Variável inexistente
    testar_codigo(L, "Variável inexistente", "print(variavel_inexistente)");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Código válido ===
Código: print('OK')
Status do load: LUA_OK (sucesso)
OK
Status do pcall: LUA_OK (sucesso)

=== Erro de sintaxe ===
Código: print('sem fechar
Status do load: LUA_ERRSYNTAX (erro de sintaxe)
Mensagem de erro: [string "print('sem fechar"]:1: unfinished string near <eof>

=== Erro de execução ===
Código: error('Erro proposital')
Status do load: LUA_OK (sucesso)
Status do pcall: LUA_ERRRUN (erro de execução)
Mensagem de erro: [string "error('Erro proposital')"]:1: Erro proposital

=== Variável inexistente ===
Código: print(variavel_inexistente)
Status do load: LUA_OK (sucesso)
nil
Status do pcall: LUA_OK (sucesso)
*/
```

---

## 21.4 Estendendo sua Aplicação e Configuração com Lua

### Usando Lua como Arquivo de Configuração

```c
// config.c

// Sistema de configuração simples
#include <stdio.h>
#include <string.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Estrutura de configuração da aplicação
typedef struct {
    char titulo[100];
    int largura;
    int altura;
    int fullscreen;
    double volume;
} Config;

// Carrega configuração de arquivo Lua
int carregar_config(const char *arquivo, Config *cfg) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    // Carrega arquivo de configuração
    if (luaL_dofile(L, arquivo) != LUA_OK) {
        fprintf(stderr, "Erro ao carregar config: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 0;
    }

    // Lê valores da tabela global 'config'
    lua_getglobal(L, "config");
    if (!lua_istable(L, -1)) {
        fprintf(stderr, "Arquivo de config inválido\n");
        lua_close(L);
        return 0;
    }

    // Lê título
    lua_getfield(L, -1, "titulo");
    if (lua_isstring(L, -1)) {
        strncpy(cfg->titulo, lua_tostring(L, -1), sizeof(cfg->titulo) - 1);
    }
    lua_pop(L, 1);

    // Lê largura
    lua_getfield(L, -1, "largura");
    if (lua_isinteger(L, -1)) {
        cfg->largura = lua_tointeger(L, -1);
    }
    lua_pop(L, 1);

    // Lê altura
    lua_getfield(L, -1, "altura");
    if (lua_isinteger(L, -1)) {
        cfg->altura = lua_tointeger(L, -1);
    }
    lua_pop(L, 1);

    // Lê fullscreen
    lua_getfield(L, -1, "fullscreen");
    if (lua_isboolean(L, -1)) {
        cfg->fullscreen = lua_toboolean(L, -1);
    }
    lua_pop(L, 1);

    // Lê volume
    lua_getfield(L, -1, "volume");
    if (lua_isnumber(L, -1)) {
        cfg->volume = lua_tonumber(L, -1);
    }
    lua_pop(L, 1);

    lua_close(L);
    return 1;
}

int main(void) {
    Config cfg = {
        .titulo = "Janela Padrão",
        .largura = 800,
        .altura = 600,
        .fullscreen = 0,
        .volume = 0.5
    };

    // Cria arquivo de configuração de exemplo
    FILE *f = fopen("config.lua", "w");
    if (f) {
        fprintf(f, "-- Arquivo de Configuração\n");
        fprintf(f, "config = {\n");
        fprintf(f, "    titulo = \"Meu Jogo Incrível\",\n");
        fprintf(f, "    largura = 1920,\n");
        fprintf(f, "    altura = 1080,\n");
        fprintf(f, "    fullscreen = true,\n");
        fprintf(f, "    volume = 0.8\n");
        fprintf(f, "}\n");
        fclose(f);
    }

    // Carrega configuração
    if (carregar_config("config.lua", &cfg)) {
        printf("Configuração carregada:\n");
        printf("  Título: %s\n", cfg.titulo);
        printf("  Resolução: %dx%d\n", cfg.largura, cfg.altura);
        printf("  Fullscreen: %s\n", cfg.fullscreen ? "Sim" : "Não");
        printf("  Volume: %.1f\n", cfg.volume);
    }

    return 0;
}

/*
Saída esperada>
Configuração carregada:
  Título: Meu Jogo Incrível
  Resolução: 1920x1080
  Fullscreen: Sim
  Volume: 0.8
*/
```

### Configuração Avançada com Validação

```c
// config_avancado.c

#include <stdio.h>
#include <string.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Estrutura para configuração de janela
typedef struct {
    char titulo[100];
    struct {
        int largura;
        int altura;
        int x;
        int y;
    } geometria;
    struct {
        int r, g, b;
    } cor_fundo;
    int resizable;
} WindowConfig;

// Função auxiliar para ler inteiro de tabela
int ler_campo_int(lua_State *L, const char *campo, int valor_padrao, int minimo, int maximo) {
    lua_getfield(L, -1, campo);
    int valor = valor_padrao;

    if (lua_isinteger(L, -1)) {
        valor = lua_tointeger(L, -1);
        if (valor < minimo) valor = minimo;
        if (valor > maximo) valor = maximo;
    }

    lua_pop(L, 1);
    return valor;
}

// Carrega configuração com validação
int carregar_window_config(const char *arquivo, WindowConfig *wc) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    if (luaL_dofile(L, arquivo) != LUA_OK) {
        fprintf(stderr, "Erro: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 0;
    }

    // Acessa tabela 'window'
    lua_getglobal(L, "window");
    if (!lua_istable(L, -1)) {
        fprintf(stderr, "Configuração 'window' não encontrada\n");
        lua_close(L);
        return 0;
    }

    // Lê título
    lua_getfield(L, -1, "title");
    if (lua_isstring(L, -1)) {
        strncpy(wc->titulo, lua_tostring(L, -1), sizeof(wc->titulo) - 1);
    }
    lua_pop(L, 1);

    // Lê geometria
    lua_getfield(L, -1, "geometry");
    if (lua_istable(L, -1)) {
        wc->geometria.largura = ler_campo_int(L, "width", 800, 320, 3840);
        wc->geometria.altura = ler_campo_int(L, "height", 600, 240, 2160);
        wc->geometria.x = ler_campo_int(L, "x", 100, 0, 10000);
        wc->geometria.y = ler_campo_int(L, "y", 100, 0, 10000);
    }
    lua_pop(L, 1);

    // Lê cor de fundo
    lua_getfield(L, -1, "background");
    if (lua_istable(L, -1)) {
        wc->cor_fundo.r = ler_campo_int(L, "r", 255, 0, 255);
        wc->cor_fundo.g = ler_campo_int(L, "g", 255, 0, 255);
        wc->cor_fundo.b = ler_campo_int(L, "b", 255, 0, 255);
    }
    lua_pop(L, 1);

    // Lê resizable
    lua_getfield(L, -1, "resizable");
    wc->resizable = lua_toboolean(L, -1);
    lua_pop(L, 1);

    lua_close(L);
    return 1;
}

int main(void) {
    // Cria arquivo de configuração
    FILE *f = fopen("window_config.lua", "w");
    if (f) {
        fprintf(f, "window = {\n");
        fprintf(f, "    title = \"Editor de Texto\",\n");
        fprintf(f, "    geometry = {\n");
        fprintf(f, "        width = 1024,\n");
        fprintf(f, "        height = 768,\n");
        fprintf(f, "        x = 100,\n");
        fprintf(f, "        y = 50\n");
        fprintf(f, "    },\n");
        fprintf(f, "    background = {\n");
        fprintf(f, "        r = 30,\n");
        fprintf(f, "        g = 30,\n");
        fprintf(f, "        b = 30\n");
        fprintf(f, "    },\n");
        fprintf(f, "    resizable = true\n");
        fprintf(f, "}\n");
        fclose(f);
    }

    WindowConfig wc = {0};
    strcpy(wc.titulo, "Padrão");

    if (carregar_window_config("window_config.lua", &wc)) {
        printf("=== Configuração da Janela ===\n");
        printf("Título: %s\n", wc.titulo);
        printf("Geometria: %dx%d na posição (%d, %d)\n",
               wc.geometria.largura, wc.geometria.altura,
               wc.geometria.x, wc.geometria.y);
        printf("Cor de Fundo: RGB(%d, %d, %d)\n",
               wc.cor_fundo.r, wc.cor_fundo.g, wc.cor_fundo.b);
        printf("Redimensionável: %s\n", wc.resizable ? "Sim" : "Não");
    }

    return 0;
}

/*
Saida esperada>
=== Configuração da Janela ===
Título: Editor de Texto
Geometria: 1024x768 na posição (100, 50)
Cor de Fundo: RGB(30, 30, 30)
Redimensionável: Sim
*/
```

---

## 21.5 Executando Código Lua de Strings

### Funções Básicas de Execução

```c
// executar_lua.c

#include <stdio.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

void exemplo_dostring(lua_State *L) {
    printf("=== luaL_dostring ===\n");

    // luaL_dostring: carrega e executa uma string
    const char *codigo = "print('Executando código Lua!')";

    if (luaL_dostring(L, codigo) != LUA_OK) {
        fprintf(stderr, "Erro: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }
    printf("\n");
}

void exemplo_loadstring(lua_State *L) {
    printf("=== luaL_loadstring ===\n");

    // luaL_loadstring: apenas carrega (compila), não executa
    const char *codigo = "return 2 + 2";

    if (luaL_loadstring(L, codigo) != LUA_OK) {
        fprintf(stderr, "Erro ao carregar: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
        return;
    }

    // Agora executamos com lua_pcall
    printf("Código carregado, executando...\n");
    if (lua_pcall(L, 0, 1, 0) == LUA_OK) {
        printf("Resultado: %.0f\n", lua_tonumber(L, -1));
        lua_pop(L, 1);
    }
    printf("\n");
}

void exemplo_codigo_complexo(lua_State *L) {
    printf("=== Código Complexo ===\n");

    const char *codigo = R"(
        -- Define uma função
        function calcular(x, y)
            local resultado = x * y + 10
            return resultado, resultado * 2
        end

        -- Usa a função
        local a, b = calcular(5, 3)
        print(string.format('Resultados: %d e %d', a, b))

        -- Retorna valores para C
        return a, b
    )";

    if (luaL_loadstring(L, codigo) == LUA_OK) {
        if (lua_pcall(L, 0, 2, 0) == LUA_OK) {
            int val1 = lua_tointeger(L, -2);
            int val2 = lua_tointeger(L, -1);
            printf("Valores recebidos em C: %d, %d\n", val1, val2);
            lua_pop(L, 2);
        }
    }
    printf("\n");
}

static int print_personalizado(lua_State *L) {
        printf("Print personalizado: %s\n", lua_tostring(L, 1));
        return 0;
}

void exemplo_com_ambiente(lua_State *L) {
    printf("=== Código com Ambiente Isolado ===\n");

    // Cria um ambiente isolado
    lua_newtable(L);  // Novo ambiente

    /* // Em c++ pode usar uma funcao lambda
    lua_pushcfunction(L, [](lua_State *L) {
        printf("Print personalizado: %s\n", lua_tostring(L, 1));
        return 0;
    }); */
    // Adiciona algumas funções ao ambiente
    lua_pushcfunction(L, print_personalizado);
    lua_setfield(L, -2, "print");

    // Adiciona variável ao ambiente
    lua_pushinteger(L, 42);
    lua_setfield(L, -2, "numero_magico");

    // Carrega código
    const char *codigo = "print('Número: ' .. numero_magico)";
    if (luaL_loadstring(L, codigo) == LUA_OK) {
        // Define o ambiente (upvalue 1)
        lua_pushvalue(L, -2);  // Duplica a tabela de ambiente
        lua_setupvalue(L, -2, 1);  // Define como _ENV

        // Executa
        if (lua_pcall(L, 0, 0, 0) != LUA_OK) {
            fprintf(stderr, "Erro: %s\n", lua_tostring(L, -1));
            lua_pop(L, 1);
        }
    }

    lua_pop(L, 1);  // Remove tabela de ambiente
    printf("\n");
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    exemplo_dostring(L);
    exemplo_loadstring(L);
    exemplo_codigo_complexo(L);
    exemplo_com_ambiente(L);

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== luaL_dostring ===
Executando código Lua!

=== luaL_loadstring ===
Código carregado, executando...
Resultado: 4

=== Código Complexo ===
Resultados: 25 e 50
Valores recebidos em C: 25, 50

=== Código com Ambiente Isolado ===
Print personalizado: Número: 42
*/
```

---

## 21.6 Chamando Funções Lua de C

### Protocolo de Chamada de Função

```c
// chamar_funcoes_lua.c

#include <stdio.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Chama função Lua simples
void exemplo_chamada_simples(lua_State *L) {
    printf("=== Chamada Simples ===\n");

    // Define função Lua
    luaL_dostring(L, R"(
        function saudar(nome)
            return 'Olá, ' .. nome .. '!'
        end
    )");

    // Passo 1: Coloca função na pilha
    lua_getglobal(L, "saudar");

    // Passo 2: Coloca argumentos na pilha
    lua_pushstring(L, "Maria");

    // Passo 3: Chama (1 argumento, 1 resultado)
    if (lua_pcall(L, 1, 1, 0) == LUA_OK) {
        // Passo 4: Pega resultado
        printf("Resultado: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }
    printf("\n");
}

// Chama função com múltiplos argumentos e retornos
void exemplo_multiplos_valores(lua_State *L) {
    printf("=== Múltiplos Valores ===\n");

    luaL_dostring(L, R"(
        function calcular(a, b, c)
            local soma = a + b + c
            local produto = a * b * c
            local media = soma / 3
            return soma, produto, media
        end
    )");

    lua_getglobal(L, "calcular");
    lua_pushinteger(L, 10);
    lua_pushinteger(L, 20);
    lua_pushinteger(L, 30);

    // 3 argumentos, 3 resultados
    if (lua_pcall(L, 3, 3, 0) == LUA_OK) {
        int soma = lua_tointeger(L, -3);
        int produto = lua_tointeger(L, -2);
        double media = lua_tonumber(L, -1);

        printf("Soma: %d\n", soma);
        printf("Produto: %d\n", produto);
        printf("Média: %.2f\n", media);

        lua_pop(L, 3);
    }
    printf("\n");
}

// Chama função com número variável de retornos
void exemplo_retornos_variaveis(lua_State *L) {
    printf("=== Retornos Variáveis (LUA_MULTRET) ===\n");

    luaL_dostring(L, R"(
        function gerar_sequencia(n)
            local resultado = {}
            for i = 1, n do
                table.insert(resultado, i * i)
            end
            return table.unpack(resultado)
        end
    )");

    lua_getglobal(L, "gerar_sequencia");
    lua_pushinteger(L, 5);

    int base = lua_gettop(L) - 1;  // Posição antes dos resultados

    // LUA_MULTRET: aceita todos os resultados
    if (lua_pcall(L, 1, LUA_MULTRET, 0) == LUA_OK) {
        int nresultados = lua_gettop(L) - base;
        printf("Função retornou %d valores: ", nresultados);

        for (int i = 1; i <= nresultados; i++) {
            printf("%d ", (int)lua_tointeger(L, base + i));
        }
        printf("\n");

        lua_pop(L, nresultados);
    }
    printf("\n");
}

// Chama função com tratamento de erro
void exemplo_com_error_handler(lua_State *L) {
    printf("=== Com Error Handler ===\n");

    // Define função que pode errar
    luaL_dostring(L, R"(
        function dividir(a, b)
            if b == 0 then
                error('Divisão por zero!', 2)
            end
            return a / b
        end
    )");

    // Define error handler
    luaL_dostring(L, R"(
        function error_handler(err)
            return 'ERRO INTERCEPTADO: ' .. tostring(err)
        end
    )");

    // Coloca error handler na pilha
    lua_getglobal(L, "error_handler");
    int errhandler = lua_gettop(L);

    // Tenta divisão por zero
    lua_getglobal(L, "dividir");
    lua_pushinteger(L, 100);
    lua_pushinteger(L, 0);

    // 4º parâmetro é o índice do error handler
    if (lua_pcall(L, 2, 1, errhandler) != LUA_OK) {
        printf("%s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }

    lua_pop(L, 1);  // Remove error handler
    printf("\n");
}

// Chama método de tabela
void exemplo_chamar_metodo(lua_State *L) {
    printf("=== Chamando Método ===\n");

    luaL_dostring(L, R"(
        Pessoa = {}
        function Pessoa:new(nome, idade)
            local obj = {nome = nome, idade = idade}
            setmetatable(obj, self)
            self.__index = self
            return obj
        end

        function Pessoa:apresentar()
            return self.nome .. ' tem ' .. self.idade .. ' anos'
        end

        joao = Pessoa:new('João', 25)
    )");

    // Pega objeto
    lua_getglobal(L, "joao");

    // Pega método (equivalente a joao:apresentar())
    lua_getfield(L, -1, "apresentar");

    // Coloca 'self' como primeiro argumento
    lua_pushvalue(L, -2);  // Duplica o objeto

    // Chama método (1 argumento = self, 1 resultado)
    if (lua_pcall(L, 1, 1, 0) == LUA_OK) {
        printf("%s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }

    lua_pop(L, 1);  // Remove objeto
    printf("\n");
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    exemplo_chamada_simples(L);
    exemplo_multiplos_valores(L);
    exemplo_retornos_variaveis(L);
    exemplo_com_error_handler(L);
    exemplo_chamar_metodo(L);

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Chamada Simples ===
Resultado: Olá, Maria!

=== Múltiplos Valores ===
Soma: 60
Produto: 6000
Média: 20.00

=== Retornos Variáveis (LUA_MULTRET) ===
Função retornou 4 valores: 4 9 16 25

=== Com Error Handler ===
ERRO INTERCEPTADO: Divisão por zero!

=== Chamando Método ===
João tem 25 anos
*/
```

---

## 26.7 Registrando Funções C

### Anatomia de uma Função C para Lua

```c
// funcoes_c_basicas.c

#include <stdio.h>
#include <math.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Função C mais simples: sem argumentos, retorna número
static int l_numero_magico(lua_State *L) {
    lua_pushinteger(L, 42);
    return 1;  // Número de valores retornados
}

// Função que recebe e retorna argumentos
static int l_somar(lua_State *L) {
    // Pega argumentos da pilha
    double a = luaL_checknumber(L, 1);  // 1º argumento
    double b = luaL_checknumber(L, 2);  // 2º argumento

    // Calcula e empilha resultado
    lua_pushnumber(L, a + b);

    return 1;  // Retorna 1 valor
}

// Função com múltiplos retornos
static int l_dividir(lua_State *L) {
    double dividendo = luaL_checknumber(L, 1);
    double divisor = luaL_checknumber(L, 2);

    if (divisor == 0) {
        // Gera erro em Lua
        return luaL_error(L, "divisão por zero");
    }

    double quociente = dividendo / divisor;
    double resto = fmod(dividendo, divisor);

    // Empilha ambos resultados
    lua_pushnumber(L, quociente);
    lua_pushnumber(L, resto);

    return 2;  // Retorna 2 valores
}

// Função com argumentos opcionais
static int l_potencia(lua_State *L) {
    double base = luaL_checknumber(L, 1);

    // Argumento opcional com valor padrão
    double expoente = luaL_optnumber(L, 2, 2.0);

    lua_pushnumber(L, pow(base, expoente));
    return 1;
}

// Função com número variável de argumentos
static int l_maximo(lua_State *L) {
    int n = lua_gettop(L);  // Número de argumentos

    if (n == 0) {
        return luaL_error(L, "esperado pelo menos 1 argumento");
    }

    double max = luaL_checknumber(L, 1);

    for (int i = 2; i <= n; i++) {
        double val = luaL_checknumber(L, i);
        if (val > max) {
            max = val;
        }
    }

    lua_pushnumber(L, max);
    return 1;
}

// Função que retorna múltiplos tipos
static int l_info_sistema(lua_State *L) {
    // Retorna string
    lua_pushstring(L, "Linux");

    // Retorna número
    lua_pushinteger(L, 64);

    // Retorna booleano
    lua_pushboolean(L, 1);

    // Retorna tabela
    lua_newtable(L);
    lua_pushstring(L, "value");
    lua_pushinteger(L, 123);
    lua_settable(L, -3);

    return 4;  // 4 valores retornados
}

// Registra todas as funções
int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    // Método 1: Registrar individualmente
    lua_register(L, "numero_magico", l_numero_magico);
    lua_register(L, "somar", l_somar);
    lua_register(L, "dividir", l_dividir);
    lua_register(L, "potencia", l_potencia);
    lua_register(L, "maximo", l_maximo);
    lua_register(L, "info_sistema", l_info_sistema);

    // Testa as funções
    luaL_dostring(L, R"(
        print('Número mágico:', numero_magico())
        print('Soma:', somar(10, 20))

        local q, r = dividir(17, 5)
        print(string.format('17 / 5 = %.0f com resto %.0f', q, r))

        print('2^3 =', potencia(2, 3))
        print('5^2 =', potencia(5))  -- usa padrão

        print('Máximo:', maximo(3, 7, 2, 9, 1))

        local os, bits, is64, info = info_sistema()
        print(string.format('Sistema: %s %d-bit', os, bits))
        print('Booleano:', is64)

        print('Tabela:')
        for k, v in pairs(info) do
            print(k, v)
        end
    )");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
Número mágico:  42
Soma:   30.0
17 / 5 = 3 com resto 2
2^3 =   8.0
5^2 =   25.0
Máximo: 9.0
Sistema: Linux 64-bit
Booleano:       true
Tabela:
value   123
*/
```

---

## 21.8 Registrando Bibliotecas

### Criando uma Biblioteca Completa

```c
// biblioteca_matematica.c

#include <math.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Funções da biblioteca
static int math_seno(lua_State *L) {
    double angulo = luaL_checknumber(L, 1);
    lua_pushnumber(L, sin(angulo));
    return 1;
}

static int math_cosseno(lua_State *L) {
    double angulo = luaL_checknumber(L, 1);
    lua_pushnumber(L, cos(angulo));
    return 1;
}

static int math_distancia(lua_State *L) {
    double x1 = luaL_checknumber(L, 1);
    double y1 = luaL_checknumber(L, 2);
    double x2 = luaL_checknumber(L, 3);
    double y2 = luaL_checknumber(L, 4);

    double dx = x2 - x1;
    double dy = y2 - y1;

    lua_pushnumber(L, sqrt(dx*dx + dy*dy));
    return 1;
}

static int math_fatorial(lua_State *L) {
    int n = luaL_checkinteger(L, 1);

    if (n < 0) {
        return luaL_error(L, "fatorial de número negativo");
    }

    lua_Integer resultado = 1;
    for (int i = 2; i <= n; i++) {
        resultado *= i;
    }

    lua_pushinteger(L, resultado);
    return 1;
}

static int math_fibonacci(lua_State *L) {
    int n = luaL_checkinteger(L, 1);

    if (n < 1) {
        return luaL_error(L, "esperado n >= 1");
    }

    if (n <= 2) {
        lua_pushinteger(L, 1);
        return 1;
    }

    lua_Integer a = 1, b = 1, c;
    for (int i = 3; i <= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }

    lua_pushinteger(L, b);
    return 1;
}

// Tabela de funções da biblioteca
static const luaL_Reg minha_mathlib[] = {
    {"seno", math_seno},
    {"cosseno", math_cosseno},
    {"distancia", math_distancia},
    {"fatorial", math_fatorial},
    {"fibonacci", math_fibonacci},
    {NULL, NULL}  // Sentinela
};

// Função de abertura da biblioteca
int luaopen_biblioteca_matematica(lua_State *L) {
    // Cria a biblioteca
    luaL_newlib(L, minha_mathlib);

    // Adiciona constantes
    lua_pushnumber(L, M_PI);
    lua_setfield(L, -2, "PI");

    lua_pushnumber(L, M_E);
    lua_setfield(L, -2, "E");

    return 1;  // Retorna a tabela
}
```

```lua
package.cpath = "./?.so;./?.dll;" .. package.cpath
local minhamath = require("biblioteca_matematica")

print("=== Biblioteca MinhaMatch ===")
print("PI =", minhamath.PI)
print("E =", minhamath.E)
print()

print("sen(PI/2) =", minhamath.seno(minhamath.PI / 2))
print("cos(0) =", minhamath.cosseno(0))
print()

print("Distância (0,0) -> (3,4) =", minhamath.distancia(0, 0, 3, 4))
print()

print("5! =", minhamath.fatorial(5))
print("Fibonacci(10) =", minhamath.fibonacci(10))

--[[
Saída esperada>
=== Biblioteca MinhaMatch ===
PI =    3.1415926535898
E =     2.718281828459

sen(PI/2) =     1.0
cos(0) =        1.0

Distância (0,0) -> (3,6) =      6.7082039324994

5! =    120
Fibonacci(10) = 55
]]
```

### Biblioteca com Estado Privado

```c
// biblioteca_contador.c

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Estado privado da biblioteca (compartilhado entre funções)
typedef struct {
    int contador;
    int incremento;
} EstadoContador;

// Incrementa contador
static int contador_incrementar(lua_State *L) {
    // Pega estado do upvalue
    EstadoContador *est = (EstadoContador *)lua_touserdata(L, lua_upvalueindex(1));

    est->contador += est->incremento;
    lua_pushinteger(L, est->contador);

    return 1;
}

// Obtém valor atual
static int contador_obter(lua_State *L) {
    EstadoContador *est = (EstadoContador *)lua_touserdata(L, lua_upvalueindex(1));
    lua_pushinteger(L, est->contador);
    return 1;
}

// Reseta contador
static int contador_resetar(lua_State *L) {
    EstadoContador *est = (EstadoContador *)lua_touserdata(L, lua_upvalueindex(1));
    est->contador = 0;
    return 0;
}

// Define incremento
static int contador_set_incremento(lua_State *L) {
    EstadoContador *est = (EstadoContador *)lua_touserdata(L, lua_upvalueindex(1));
    est->incremento = luaL_checkinteger(L, 1);
    return 0;
}

// Funções da biblioteca
static const luaL_Reg contador_funcs[] = {
    {"incrementar", contador_incrementar},
    {"obter", contador_obter},
    {"resetar", contador_resetar},
    {"setIncremento", contador_set_incremento},
    {NULL, NULL}
};

// Abre biblioteca
int luaopen_biblioteca_contador(lua_State *L) {
    // Cria estado privado
    EstadoContador *est = (EstadoContador *)lua_newuserdata(L, sizeof(EstadoContador));
    est->contador = 0;
    est->incremento = 1;

    // Registra funções com o estado como upvalue
    luaL_newlibtable(L, contador_funcs);
    lua_pushvalue(L, -2);  // Duplica userdata
    luaL_setfuncs(L, contador_funcs, 1);  // 1 upvalue

    return 1;
}
```

```lua
package.cpath = "./?.so;./?.dll;" .. package.cpath
local contador = require("biblioteca_contador")

print("Valor inicial:", contador.obter())

for i = 1, 3 do
    print("Incrementar:", contador.incrementar())
end

contador.setIncremento(5)
print("Incrementar (+5):", contador.incrementar())

contador.resetar()
print("Após reset:", contador.obter())

--[[
Saída esperada>
Valor inicial:  0
Incrementar:    1
Incrementar:    2
Incrementar:    3
Incrementar (+5):       8
Após reset:     0
]]
```

---

## 21.9 Técnicas para Escrever Funções C com Validação de Argumentos

### Funções de Checagem

```c
// validacao_argumentos.c

#include <string.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Exemplo 1: Checagem básica
static int l_criar_usuario(lua_State *L) {
    // luaL_check* gera erro automaticamente se tipo incorreto
    const char *nome = luaL_checkstring(L, 1);
    int idade = luaL_checkinteger(L, 2);
    const char *email = luaL_checkstring(L, 3);

    printf("Usuário criado:\n");
    printf("  Nome: %s\n", nome);
    printf("  Idade: %d\n", idade);
    printf("  Email: %s\n", email);

    return 0;
}

// Exemplo 2: Argumentos opcionais
static int l_configurar(lua_State *L) {
    const char *titulo = luaL_optstring(L, 1, "Sem Título");
    int largura = luaL_optinteger(L, 2, 800);
    int altura = luaL_optinteger(L, 3, 600);

    printf("Configuração:\n");
    printf("  Título: %s\n", titulo);
    printf("  Resolução: %dx%d\n", largura, altura);

    return 0;
}

// Exemplo 3: Validação customizada
static int l_definir_cor(lua_State *L) {
    int r = luaL_checkinteger(L, 1);
    int g = luaL_checkinteger(L, 2);
    int b = luaL_checkinteger(L, 3);

    // Validação manual com luaL_argcheck
    luaL_argcheck(L, r >= 0 && r <= 255, 1, "valor deve estar entre 0 e 255");
    luaL_argcheck(L, g >= 0 && g <= 255, 2, "valor deve estar entre 0 e 255");
    luaL_argcheck(L, b >= 0 && b <= 255, 3, "valor deve estar entre 0 e 255");

    printf("Cor RGB(%d, %d, %d) definida\n", r, g, b);
    return 0;
}

// Exemplo 4: Validação de tipos
static int l_processar_dados(lua_State *L) {
    // Aceita tabela ou string
    int tipo = lua_type(L, 1);

    if (tipo == LUA_TTABLE) {
        printf("Processando tabela...\n");
        lua_len(L, 1);
        int tamanho = lua_tointeger(L, -1);
        lua_pop(L, 1);
        printf("  Tamanho: %d elementos\n", tamanho);

    } else if (tipo == LUA_TSTRING) {
        const char *str = lua_tostring(L, 1);
        printf("Processando string: '%s'\n", str);

    } else {
        return luaL_typeerror(L, 1, "tabela ou string");
    }

    return 0;
}

// Exemplo 5: Número variável de argumentos com validação
static int l_calcular_media(lua_State *L) {
    int n = lua_gettop(L);

    if (n == 0) {
        return luaL_error(L, "esperado pelo menos 1 número");
    }

    double soma = 0;
    for (int i = 1; i <= n; i++) {
        // Valida cada argumento
        if (!lua_isnumber(L, i)) {
            return luaL_argerror(L, i, "número esperado");
        }
        soma += lua_tonumber(L, i);
    }

    lua_pushnumber(L, soma / n);
    return 1;
}

// Exemplo 6: Validação de campos de tabela
static int l_criar_retangulo(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);

    // Pega campo 'x'
    lua_getfield(L, 1, "x");
    if (!lua_isnumber(L, -1)) {
        return luaL_error(L, "campo 'x' deve ser número");
    }
    double x = lua_tonumber(L, -1);
    lua_pop(L, 1);

    // Pega campo 'y'
    lua_getfield(L, 1, "y");
    if (!lua_isnumber(L, -1)) {
        return luaL_error(L, "campo 'y' deve ser número");
    }
    double y = lua_tonumber(L, -1);
    lua_pop(L, 1);

    // Pega campo 'largura'
    lua_getfield(L, 1, "largura");
    double largura = luaL_optnumber(L, -1, 100);
    lua_pop(L, 1);

    // Pega campo 'altura'
    lua_getfield(L, 1, "altura");
    double altura = luaL_optnumber(L, -1, 100);
    lua_pop(L, 1);

    printf("Retângulo criado: pos(%.1f, %.1f), tamanho(%.1f x %.1f)\n",
           x, y, largura, altura);

    return 0;
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    lua_register(L, "criar_usuario", l_criar_usuario);
    lua_register(L, "configurar", l_configurar);
    lua_register(L, "definir_cor", l_definir_cor);
    lua_register(L, "processar_dados", l_processar_dados);
    lua_register(L, "calcular_media", l_calcular_media);
    lua_register(L, "criar_retangulo", l_criar_retangulo);

    // Testes
    luaL_dostring(L, R"(
        print('=== Teste 1: Criar Usuário ===')
        criar_usuario('Ana', 28, 'ana@email.com')
        print()

        print('=== Teste 2: Configurar (com padrões) ===')
        configurar()
        configurar('Meu App', 1920, 1080)
        print()

        print('=== Teste 3: Definir Cor ===')
        definir_cor(255, 128, 0)
        print()

        -- Teste de erro
        local ok, err = pcall(definir_cor, 300, 0, 0)
        if not ok then
            print('Erro capturado:', err)
        end
        print()

        print('=== Teste 4: Processar Dados ===')
        processar_dados({10, 20, 30})
        processar_dados('Texto de teste')
        print()

        print('=== Teste 5: Calcular Média ===')
        print('Média:', calcular_media(10, 20, 30, 40, 50))
        print()

        print('=== Teste 6: Criar Retângulo ===')
        criar_retangulo({x = 10, y = 20, largura = 200, altura = 150})
        criar_retangulo({x = 0, y = 0})  -- usa padrões
    )");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Teste 1: Criar Usuário ===
Usuário criado:
  Nome: Ana
  Idade: 28
  Email: ana@email.com

=== Teste 2: Configurar (com padrões) ===
Configuração:
  Título: Sem Título
  Resolução: 800x600
Configuração:
  Título: Meu App
  Resolução: 1920x1080

=== Teste 3: Definir Cor ===
Cor RGB(255, 128, 0) definida

Erro capturado: bad argument #1 to 'definir_cor' (valor deve estar entre 0 e 255)

=== Teste 4: Processar Dados ===
Processando tabela...
  Tamanho: 3 elementos
Processando string: 'Texto de teste'

=== Teste 5: Calcular Média ===
Média:  30.0

=== Teste 6: Criar Retângulo ===
Retângulo criado: pos(10.0, 20.0), tamanho(200.0 x 150.0)
Retângulo criado: pos(0.0, 0.0), tamanho(100.0 x 100.0)
*/
```

---

## 21.10 Manipulação de Tabelas

### Lendo e Escrevendo Tabelas

```c
// manipulacao_tabelas.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Exemplo 1: Criar e preencher tabela
static int l_criar_pessoa(lua_State *L) {
    const char *nome = luaL_checkstring(L, 1);
    int idade = luaL_checkinteger(L, 2);
    const char *cidade = luaL_checkstring(L, 3);

    // Cria nova tabela
    lua_newtable(L);

    // Adiciona campos (método 1: usando lua_setfield)
    lua_pushstring(L, nome);
    lua_setfield(L, -2, "nome");

    lua_pushinteger(L, idade);
    lua_setfield(L, -2, "idade");

    lua_pushstring(L, cidade);
    lua_setfield(L, -2, "cidade");

    // Tabela está no topo da pilha
    return 1;
}

// Exemplo 2: Ler campos de tabela
static int l_imprimir_pessoa(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);

    // Lê nome
    lua_getfield(L, 1, "nome");
    const char *nome = lua_tostring(L, -1);
    lua_pop(L, 1);

    // Lê idade
    lua_getfield(L, 1, "idade");
    int idade = lua_tointeger(L, -1);
    lua_pop(L, 1);

    // Lê cidade
    lua_getfield(L, 1, "cidade");
    const char *cidade = lua_tostring(L, -1);
    lua_pop(L, 1);

    printf("%s, %d anos, de %s\n", nome, idade, cidade);
    return 0;
}

// Exemplo 3: Iterar sobre tabela
static int l_somar_valores(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);

    double soma = 0;
    int count = 0;

    // Inicia iteração
    lua_pushnil(L);  // Primeira chave

    while (lua_next(L, 1) != 0) {
        // 'chave' está em -2, 'valor' em -1

        if (lua_isnumber(L, -1)) {
            soma += lua_tonumber(L, -1);
            count++;
        }

        // Remove 'valor', mantém 'chave' para próxima iteração
        lua_pop(L, 1);
    }

    printf("Soma de %d valores: %.2f\n", count, soma);
    lua_pushnumber(L, soma);
    return 1;
}

// Exemplo 4: Criar tabela de array
static int l_criar_sequencia(lua_State *L) {
    int n = luaL_checkinteger(L, 1);

    lua_newtable(L);

    for (int i = 1; i <= n; i++) {
        lua_pushinteger(L, i * i);  // Valor: i²
        lua_seti(L, -2, i);         // tabela[i] = valor
    }

    return 1;
}

// Exemplo 5: Modificar tabela existente
static int l_adicionar_campo(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);
    const char *chave = luaL_checkstring(L, 2);
    // 3º argumento é o valor (qualquer tipo)

    // Copia valor para topo
    lua_pushvalue(L, 3);
    // Define campo
    lua_setfield(L, 1, chave);

    return 0;
}

// Exemplo 6: Operações com índices numéricos
static int l_tamanho_array(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);

    // Método 1: usando lua_rawlen
    size_t len1 = lua_rawlen(L, 1);

    // Método 2: usando operador #
    lua_len(L, 1);
    lua_Integer len2 = lua_tointeger(L, -1);
    lua_pop(L, 1);

    printf("rawlen: %zu, operador #: %lld\n", len1, (long long)len2);
    lua_pushinteger(L, len2);
    return 1;
}

// Exemplo 7: Criar tabela com metatable
static int ponto_to_string(lua_State *L) {
    lua_getfield(L, 1, "x");
    double x = lua_tonumber(L, -1);
    lua_pop(L, 1);

    lua_getfield(L, 1, "y");
    double y = lua_tonumber(L, -1);
    lua_pop(L, 1);

    char buffer[100];
    snprintf(buffer, sizeof(buffer), "Ponto(%.2f, %.2f)", x, y);
    lua_pushstring(L, buffer);
    return 1;
}

static int l_criar_ponto(lua_State *L) {
    double x = luaL_checknumber(L, 1);
    double y = luaL_checknumber(L, 2);

    // Cria tabela
    lua_newtable(L);

    lua_pushnumber(L, x);
    lua_setfield(L, -2, "x");

    lua_pushnumber(L, y);
    lua_setfield(L, -2, "y");

    // Cria metatable
    lua_newtable(L);

    // Adiciona __tostring
    lua_pushcfunction(L, ponto_to_string);
    lua_setfield(L, -2, "__tostring");

    // Define metatable
    lua_setmetatable(L, -2);

    return 1;
}

// Exemplo 8: Acessar tabelas aninhadas
static int l_obter_aninhado(lua_State *L) {
    // Recebe tabela e caminho como string: "a.b.c"
    luaL_checktype(L, 1, LUA_TTABLE);
    const char *caminho = luaL_checkstring(L, 2);

    lua_pushvalue(L, 1);  // Duplica tabela inicial

    char *copia = strdup(caminho);
    char *token = strtok(copia, ".");

    while (token != NULL) {
        if (!lua_istable(L, -1)) {
            free(copia);
            lua_pushnil(L);
            return 1;
        }

        lua_getfield(L, -1, token);
        lua_remove(L, -2);  // Remove tabela anterior
        token = strtok(NULL, ".");
    }

    free(copia);
    return 1;
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    lua_register(L, "criar_pessoa", l_criar_pessoa);
    lua_register(L, "imprimir_pessoa", l_imprimir_pessoa);
    lua_register(L, "somar_valores", l_somar_valores);
    lua_register(L, "criar_sequencia", l_criar_sequencia);
    lua_register(L, "adicionar_campo", l_adicionar_campo);
    lua_register(L, "tamanho_array", l_tamanho_array);
    lua_register(L, "criar_ponto", l_criar_ponto);
    lua_register(L, "obter_aninhado", l_obter_aninhado);

    luaL_dostring(L, R"(
        print('=== Criar e Imprimir Pessoa ===')
        local pessoa = criar_pessoa('João', 30, 'São Paulo')
        imprimir_pessoa(pessoa)
        print()

        print('=== Somar Valores ===')
        local numeros = {10, 20, 30, valor = 5, outro = 15}
        somar_valores(numeros)
        print()

        print('=== Criar Sequência ===')
        local seq = criar_sequencia(5)
        for i, v in ipairs(seq) do
            print(i, v)
        end
        print()

        print('=== Adicionar Campo ===')
        adicionar_campo(pessoa, 'profissao', 'Engenheiro')
        print('Profissão:', pessoa.profissao)
        print()

        print('=== Tamanho Array ===')
        local arr = {10, 20, 30, 40, 50}
        print('Tamanho:', tamanho_array(arr))
        print()

        print('=== Criar Ponto ===')
        local p = criar_ponto(3.5, 7.2)
        print(p)
        print()

        print('=== Obter Aninhado ===')
        local config = {
            window = {
                size = {
                    width = 800,
                    height = 600
                }
            }
        }
        print('Largura:', obter_aninhado(config, 'window.size.width'))
    )");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Criar e Imprimir Pessoa ===
João, 30 anos, de São Paulo

=== Somar Valores ===
Soma de 5 valores: 80.00

=== Criar Sequência ===
1       1
2       4
3       9
4       16
5       25

=== Adicionar Campo ===
Profissão:      Engenheiro

=== Tamanho Array ===
rawlen: 5, operador #: 5
Tamanho:        5

=== Criar Ponto ===
Ponto(3.50, 7.20)

=== Obter Aninhado ===
Largura:        800
*/
```

---

## 21.11 Strings e Buffers

### Trabalhando com Strings

```c
// strings_e_buffers.c

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Exemplo 1: Concatenar strings eficientemente
static int l_concatenar_lista(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);
    const char *separador = luaL_optstring(L, 2, "");

    luaL_Buffer buf;
    luaL_buffinit(L, &buf);

    int n = lua_rawlen(L, 1);
    for (int i = 1; i <= n; i++) {
        lua_rawgeti(L, 1, i);

        if (i > 1) {
            luaL_addstring(&buf, separador);
        }

        luaL_addvalue(&buf);  // Adiciona valor do topo
    }

    luaL_pushresult(&buf);
    return 1;
}

// Exemplo 2: Manipulação de strings com buffer
static int l_processar_texto(lua_State *L) {
    size_t len;
    const char *str = luaL_checklstring(L, 1, &len);

    luaL_Buffer buf;
    luaL_buffinit(L, &buf);

    // Processa cada caractere
    for (size_t i = 0; i < len; i++) {
        char c = str[i];

        // Converte para maiúscula
        c = toupper(c);

        // Substitui espaços por underscore
        if (c == ' ') {
            c = '_';
        }

        luaL_addchar(&buf, c);
    }

    luaL_pushresult(&buf);
    return 1;
}

// Exemplo 3: Criar string formatada
static int l_formatar_info(lua_State *L) {
    const char *nome = luaL_checkstring(L, 1);
    int idade = luaL_checkinteger(L, 2);
    double salario = luaL_checknumber(L, 3);

    char buffer[128];
    snprintf(buffer, sizeof(buffer), "%s (%d anos) - Salário: R$ %.2f", nome, idade, salario);
    lua_pushstring(L, buffer);
    return 1;
}

// Exemplo 4: Dividir string
static int l_dividir(lua_State *L) {
    size_t len;
    const char *str = luaL_checklstring(L, 1, &len);
    const char *delim = luaL_checkstring(L, 2);

    lua_newtable(L);
    int index = 1;

    const char *inicio = str;
    const char *fim;

    while ((fim = strstr(inicio, delim)) != NULL) {
        lua_pushlstring(L, inicio, fim - inicio);
        lua_rawseti(L, -2, index++);
        inicio = fim + strlen(delim);
    }

    // Adiciona última parte
    lua_pushstring(L, inicio);
    lua_rawseti(L, -2, index);

    return 1;
}

// Exemplo 5: Escapar caracteres especiais
static int l_escapar_html(lua_State *L) {
    size_t len;
    const char *str = luaL_checklstring(L, 1, &len);

    luaL_Buffer buf;
    luaL_buffinit(L, &buf);

    for (size_t i = 0; i < len; i++) {
        char c = str[i];

        switch (c) {
            case '<':
                luaL_addstring(&buf, "&lt;");
                break;
            case '>':
                luaL_addstring(&buf, "&gt;");
                break;
            case '&':
                luaL_addstring(&buf, "&amp;");
                break;
            case '"':
                luaL_addstring(&buf, "&quot;");
                break;
            case '\'':
                luaL_addstring(&buf, "&#39;");
                break;
            default:
                luaL_addchar(&buf, c);
        }
    }

    luaL_pushresult(&buf);
    return 1;
}

// Exemplo 6: Criar string de bytes
static int l_criar_bytes(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);

    luaL_Buffer buf;
    luaL_buffinit(L, &buf);

    int n = lua_rawlen(L, 1);
    for (int i = 1; i <= n; i++) {
        lua_rawgeti(L, 1, i);
        int byte = lua_tointeger(L, -1);
        lua_pop(L, 1);

        if (byte < 0 || byte > 255) {
            return luaL_error(L, "byte %d fora do intervalo", byte);
        }

        luaL_addchar(&buf, (char)byte);
    }

    luaL_pushresult(&buf);
    return 1;
}

// Exemplo 7: String reversa
static int l_reverter(lua_State *L) {
    size_t len;
    const char *str = luaL_checklstring(L, 1, &len);

    luaL_Buffer buf;
    luaL_buffinit(L, &buf);

    for (int i = len - 1; i >= 0; i--) {
        luaL_addchar(&buf, str[i]);
    }

    luaL_pushresult(&buf);
    return 1;
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    lua_register(L, "concatenar_lista", l_concatenar_lista);
    lua_register(L, "processar_texto", l_processar_texto);
    lua_register(L, "formatar_info", l_formatar_info);
    lua_register(L, "dividir", l_dividir);
    lua_register(L, "escapar_html", l_escapar_html);
    lua_register(L, "criar_bytes", l_criar_bytes);
    lua_register(L, "reverter", l_reverter);

    // luaL_dostring(L, R"(...)");
    if (luaL_dostring(L, R"(
        print('=== Concatenar Lista ===')
        local palavras = {'Lua', 'é', 'fantástico'}
        print(concatenar_lista(palavras, ' '))
        print()

        print('=== Processar Texto ===')
        print(processar_texto('Hello World!'))
        print()

        print('=== Formatar Info ===')
        print(formatar_info('Ana Silva', 28, 5500.50))
        print()

        print('=== Dividir ===')
        local partes = dividir('um,dois,três,quatro', ',')
        for i, v in ipairs(partes) do
            print(i, v)
        end
        print()

        print('=== Escapar HTML ===')
        print(escapar_html('<div class='test'>Olá & tchau</div>'))
        print()

        print('=== Criar Bytes ===')
        local bytes = criar_bytes({72, 101, 108, 108, 111})
        print(bytes)
        print()

        print('=== Reverter ===')
        print(reverter('Lua'))
    )") != 0) {
    fprintf(stderr, "Erro Lua: %s\n", lua_tostring(L, -1));
    lua_pop(L, 1); // remove mensagem de erro da pilha
    }

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Concatenar Lista ===
Lua é fantástico

=== Processar Texto ===
HELLO_WORLD!

=== Formatar Info ===
Ana Silva (28 anos) - Salário: R$ 5500.50

=== Dividir ===
1       um
2       dois
3       três
4       quatro

=== Escapar HTML ===
&lt;div class=&#39;test&#39;&gt;Olá &amp; tchau&lt;/div&gt;

=== Criar Bytes ===
Hello

=== Reverter ===
auL
*/
```

---

## 28.12 Userdata Completo (Full Userdata)

### Criando e Manipulando Userdata

```c
// userdata_basico.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Estrutura para armazenar em userdata
typedef struct {
    double x;
    double y;
} Ponto;

// Cria novo ponto
static int ponto_novo(lua_State *L) {
    double x = luaL_checknumber(L, 1);
    double y = luaL_checknumber(L, 2);

    // Aloca userdata
    Ponto *p = (Ponto *)lua_newuserdata(L, sizeof(Ponto));
    p->x = x;
    p->y = y;

    // Define metatable
    luaL_getmetatable(L, "Ponto");
    lua_setmetatable(L, -2);

    return 1;
}

// Obtém coordenadas
static int ponto_obter(lua_State *L) {
    Ponto *p = (Ponto *)luaL_checkudata(L, 1, "Ponto");
    lua_pushnumber(L, p->x);
    lua_pushnumber(L, p->y);
    return 2;
}

// Define coordenadas
static int ponto_definir(lua_State *L) {
    Ponto *p = (Ponto *)luaL_checkudata(L, 1, "Ponto");
    p->x = luaL_checknumber(L, 2);
    p->y = luaL_checknumber(L, 3);
    return 0;
}

// Calcula distância
static int ponto_distancia(lua_State *L) {
    Ponto *p1 = (Ponto *)luaL_checkudata(L, 1, "Ponto");
    Ponto *p2 = (Ponto *)luaL_checkudata(L, 2, "Ponto");

    double dx = p2->x - p1->x;
    double dy = p2->y - p1->y;
    double dist = sqrt(dx*dx + dy*dy);

    lua_pushnumber(L, dist);
    return 1;
}

// Metamétodo __tostring
static int ponto_tostring(lua_State *L) {
    Ponto *p = (Ponto *)luaL_checkudata(L, 1, "Ponto");
    char buffer[64];
    snprintf(buffer, sizeof(buffer), "Ponto(%.2f, %.2f)", p->x, p->y);
    lua_pushstring(L, buffer);
    return 1;
}

// Metamétodo __add
static int ponto_add(lua_State *L) {
    Ponto *p1 = (Ponto *)luaL_checkudata(L, 1, "Ponto");
    Ponto *p2 = (Ponto *)luaL_checkudata(L, 2, "Ponto");

    Ponto *resultado = (Ponto *)lua_newuserdata(L, sizeof(Ponto));
    resultado->x = p1->x + p2->x;
    resultado->y = p1->y + p2->y;

    luaL_getmetatable(L, "Ponto");
    lua_setmetatable(L, -2);

    return 1;
}

// Metamétodo __gc (finalizer)
static int ponto_gc(lua_State *L) {
    Ponto *p = (Ponto *)luaL_checkudata(L, 1, "Ponto");
    printf("Coletando Ponto(%.2f, %.2f)\n", p->x, p->y);
    return 0;
}

// Métodos do Ponto
static const luaL_Reg ponto_metodos[] = {
    {"obter", ponto_obter},
    {"definir", ponto_definir},
    {"distancia", ponto_distancia},
    {NULL, NULL}
};

// Metamétodos
static const luaL_Reg ponto_metamethods[] = {
    {"__tostring", ponto_tostring},
    {"__add", ponto_add},
    {"__gc", ponto_gc},
    {NULL, NULL}
};

// Registra o tipo Ponto
void registrar_ponto(lua_State *L) {
    // Cria metatable
    luaL_newmetatable(L, "Ponto");

    // Define __index para apontar para si mesmo
    lua_pushvalue(L, -1);
    lua_setfield(L, -2, "__index");

    // Registra métodos
    luaL_setfuncs(L, ponto_metodos, 0);
    luaL_setfuncs(L, ponto_metamethods, 0);

    lua_pop(L, 1);  // Remove metatable
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    registrar_ponto(L);
    lua_register(L, "Ponto", ponto_novo);

    const char *script = R"(
        print('=== Criando Pontos ===')
        local p1 = Ponto(3, 4)
        local p2 = Ponto(6, 8)

        print('p1:', p1)
        print('p2:', p2)
        print()

        print('=== Obtendo Coordenadas ===')
        local x, y = p1:obter()
        print(string.format('p1 = (%.1f, %.1f)', x, y))
        print()

        print('=== Definindo Coordenadas ===')
        p1:definir(10, 20)
        print('p1 após definir:', p1)
        print()

        print('=== Calculando Distância ===')
        print('Distância p1-p2:', p1:distancia(p2))
        print()

        print('=== Somando Pontos ===')
        local p3 = p1 + p2
        print('p1 + p2 =', p3)
        print()

        print('=== Garbage Collection ===')
        collectgarbage()
    )";

    if (luaL_dostring(L, script) != LUA_OK) {
    fprintf(stderr, "Erro Lua: %s\n", lua_tostring(L, -1));
    lua_pop(L, 1);
}

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Criando Pontos ===
p1:     Ponto(3.00, 4.00)
p2:     Ponto(6.00, 8.00)

=== Obtendo Coordenadas ===
p1 = (3.0, 4.0)

=== Definindo Coordenadas ===
p1 após definir:        Ponto(10.00, 20.00)

=== Calculando Distância ===
Distância p1-p2:        12.649110640674

=== Somando Pontos ===
p1 + p2 =       Ponto(16.00, 28.00)

=== Garbage Collection ===
Coletando Ponto(16.00, 28.00)
Coletando Ponto(6.00, 8.00)
Coletando Ponto(10.00, 20.00)
*/
```

### Userdata Avançado e Gerenciamento de Recursos Externos

```c
// arquivo_userdata.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Estrutura para arquivo
typedef struct {
    FILE *fp;
    char modo[4];
    int fechado;
} Arquivo;

// Cria novo arquivo
static int arquivo_abrir(lua_State *L) {
    const char *nome = luaL_checkstring(L, 1);
    const char *modo = luaL_optstring(L, 2, "r");

    Arquivo *arq = (Arquivo *)lua_newuserdata(L, sizeof(Arquivo));
    arq->fp = NULL;
    arq->fechado = 0;

    // Tenta abrir arquivo
    arq->fp = fopen(nome, modo);
    if (arq->fp == NULL) {
        return luaL_error(L, "não foi possível abrir '%s'", nome);
    }

    // Copia modo
    snprintf(arq->modo, sizeof(arq->modo), "%s", modo);

    // Define metatable
    luaL_getmetatable(L, "Arquivo");
    lua_setmetatable(L, -2);

    return 1;
}

// Verifica se arquivo está aberto
static Arquivo* arquivo_check(lua_State *L, int index) {
    Arquivo *arq = (Arquivo *)luaL_checkudata(L, index, "Arquivo");
    if (arq->fechado) {
        luaL_error(L, "operação em arquivo fechado");
    }
    return arq;
}

// Fecha arquivo
static int arquivo_fechar(lua_State *L) {
    Arquivo *arq = (Arquivo *)luaL_checkudata(L, 1, "Arquivo");

    if (!arq->fechado && arq->fp != NULL) {
        fclose(arq->fp);
        arq->fechado = 1;
        printf("Arquivo fechado explicitamente\n");
    }

    return 0;
}

// Escreve no arquivo
static int arquivo_escrever(lua_State *L) {
    Arquivo *arq = arquivo_check(L, 1);
    const char *str = luaL_checkstring(L, 2);

    fprintf(arq->fp, "%s", str);

    // Retorna self para encadeamento
    lua_pushvalue(L, 1);
    return 1;
}

// Lê linha do arquivo
static int arquivo_ler_linha(lua_State *L) {
    Arquivo *arq = arquivo_check(L, 1);

    char buffer[1024];
    if (fgets(buffer, sizeof(buffer), arq->fp) != NULL) {
        // Remove newline
        size_t len = strlen(buffer);
        if (len > 0 && buffer[len-1] == '\n') {
            buffer[len-1] = '\0';
        }
        lua_pushstring(L, buffer);
        return 1;
    }

    // EOF
    lua_pushnil(L);
    return 1;
}

// Lê tudo
static int arquivo_ler_tudo(lua_State *L) {
    Arquivo *arq = arquivo_check(L, 1);

    luaL_Buffer buf;
    luaL_buffinit(L, &buf);

    char chunk[1024];
    size_t lido;

    while ((lido = fread(chunk, 1, sizeof(chunk), arq->fp)) > 0) {
        luaL_addlstring(&buf, chunk, lido);
    }

    luaL_pushresult(&buf);
    return 1;
}

// Verifica se chegou ao fim
static int arquivo_eof(lua_State *L) {
    Arquivo *arq = arquivo_check(L, 1);
    lua_pushboolean(L, feof(arq->fp));
    return 1;
}

// __tostring
static int arquivo_tostring(lua_State *L) {
    Arquivo *arq = (Arquivo *)luaL_checkudata(L, 1, "Arquivo");
    if (arq->fechado) {
        lua_pushstring(L, "Arquivo (fechado)");
    } else {
        lua_pushfstring(L, "Arquivo (aberto, modo: %s)", arq->modo);
    }
    return 1;
}

// __gc (finalizer)
static int arquivo_gc(lua_State *L) {
    Arquivo *arq = (Arquivo *)luaL_checkudata(L, 1, "Arquivo");

    if (!arq->fechado && arq->fp != NULL) {
        fclose(arq->fp);
        arq->fechado = 1;
        printf("Arquivo fechado pelo GC\n");
    }

    return 0;
}

// Métodos
static const luaL_Reg arquivo_metodos[] = {
    {"fechar", arquivo_fechar},
    {"escrever", arquivo_escrever},
    {"lerLinha", arquivo_ler_linha},
    {"lerTudo", arquivo_ler_tudo},
    {"eof", arquivo_eof},
    {NULL, NULL}
};

// Metamétodos
static const luaL_Reg arquivo_metamethods[] = {
    {"__tostring", arquivo_tostring},
    {"__gc", arquivo_gc},
    {NULL, NULL}
};

void registrar_arquivo(lua_State *L) {
    luaL_newmetatable(L, "Arquivo");

    lua_pushvalue(L, -1);
    lua_setfield(L, -2, "__index");

    luaL_setfuncs(L, arquivo_metodos, 0);
    luaL_setfuncs(L, arquivo_metamethods, 0);

    lua_pop(L, 1);
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    registrar_arquivo(L);
    lua_register(L, "Arquivo", arquivo_abrir);

    luaL_dostring(L, R"(
        print('=== Escrevendo em Arquivo ===')
        local arq = Arquivo('teste.txt', 'w')
        print(arq)

        arq:escrever('Primeira linha\n')
           :escrever('Segunda linha\n')
           :escrever('Terceira linha\n')

        arq:fechar()
        print()

        print('=== Lendo Arquivo ===')
        local arq2 = Arquivo('teste.txt', 'r')

        while not arq2:eof() do
            local linha = arq2:lerLinha()
            if linha then
                print('Lido:', linha)
            end
        end

        arq2:fechar()
        print()

        print('=== Lendo Tudo de Uma Vez ===')
        local arq3 = Arquivo('teste.txt', 'r')
        local conteudo = arq3:lerTudo()
        print('Conteúdo:')
        print(conteudo)
        arq3:fechar()
        print()

        print('=== Testando GC ===')
        do
            local temp = Arquivo('teste.txt', 'r')
            -- Arquivo não fechado explicitamente
        end
        collectgarbage()
    )");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Escrevendo em Arquivo ===
Arquivo (aberto, modo: w)
Arquivo fechado explicitamente

=== Lendo Arquivo ===
Lido:   Primeira linha
Lido:   Segunda linha
Lido:   Terceira linha
Arquivo fechado explicitamente

=== Lendo Tudo de Uma Vez ===
Conteúdo:
Primeira linha
Segunda linha
Terceira linha

Arquivo fechado explicitamente

=== Testando GC ===
Arquivo fechado pelo GC
*/
```

### Usando Light Userdata

```c
// light_userdata.c

#include <stdio.h>
#include <stdlib.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Estrutura externa (gerenciada por C)
typedef struct {
    int id;
    char nome[50];
    double valor;
} DadosExternos;

// Cache global de dados (em aplicação real seria mais sofisticado)
#define MAX_DADOS 100
static DadosExternos cache[MAX_DADOS];
static int proximo_id = 0;

// Cria dados externos e retorna light userdata
static int criar_dados_externos(lua_State *L) {
    const char *nome = luaL_checkstring(L, 1);
    double valor = luaL_checknumber(L, 2);

    if (proximo_id >= MAX_DADOS) {
        return luaL_error(L, "cache cheio");
    }

    // Aloca em C (não gerenciado por Lua)
    DadosExternos *dados = &cache[proximo_id++];
    dados->id = proximo_id - 1;
    snprintf(dados->nome, sizeof(dados->nome), "%s", nome);
    dados->valor = valor;

    // Retorna light userdata (apenas ponteiro)
    lua_pushlightuserdata(L, dados);

    return 1;
}

// Acessa dados via light userdata
static int obter_info_dados(lua_State *L) {
    // Verifica se é light userdata
    if (!lua_islightuserdata(L, 1)) {
        return luaL_error(L, "esperado light userdata");
    }

    DadosExternos *dados = (DadosExternos *)lua_touserdata(L, 1);

    lua_pushinteger(L, dados->id);
    lua_pushstring(L, dados->nome);
    lua_pushnumber(L, dados->valor);

    return 3;
}

// Modifica dados via light userdata
static int modificar_dados(lua_State *L) {
    if (!lua_islightuserdata(L, 1)) {
        return luaL_error(L, "esperado light userdata");
    }

    DadosExternos *dados = (DadosExternos *)lua_touserdata(L, 1);
    dados->valor = luaL_checknumber(L, 2);

    return 0;
}

// Exemplo: Usando registry com light userdata como chave
static int associar_com_registry(lua_State *L) {
    void *ptr = lua_touserdata(L, 1);
    const char *info = luaL_checkstring(L, 2);

    // Usa light userdata como chave no registry
    lua_pushlightuserdata(L, ptr);
    lua_pushstring(L, info);
    lua_settable(L, LUA_REGISTRYINDEX);

    return 0;
}

static int recuperar_do_registry(lua_State *L) {
    void *ptr = lua_touserdata(L, 1);

    lua_pushlightuserdata(L, ptr);
    lua_gettable(L, LUA_REGISTRYINDEX);

    return 1;
}

// Comparação entre full e light userdata
static int demonstrar_diferencas(lua_State *L) {
    printf("\n=== Diferenças Full vs Light Userdata ===\n");

    // Full userdata
    int *full = (int *)lua_newuserdata(L, sizeof(int));
    *full = 42;
    printf("Full userdata criado (gerenciado por Lua)\n");
    printf("  Tamanho: %zu bytes\n", sizeof(int));
    printf("  Pode ter metatable: Sim\n");
    printf("  Garbage collected: Sim\n");

    // Light userdata
    static int valor = 99;
    lua_pushlightuserdata(L, &valor);
    printf("\nLight userdata criado (apenas ponteiro)\n");
    printf("  Tamanho: apenas o ponteiro\n");
    printf("  Pode ter metatable: Não\n");
    printf("  Garbage collected: Não\n");

    return 2;
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    lua_register(L, "criar_dados_externos", criar_dados_externos);
    lua_register(L, "obter_info_dados", obter_info_dados);
    lua_register(L, "modificar_dados", modificar_dados);
    lua_register(L, "associar_com_registry", associar_com_registry);
    lua_register(L, "recuperar_do_registry", recuperar_do_registry);
    lua_register(L, "demonstrar_diferencas", demonstrar_diferencas);

    luaL_dostring(L, R"(
        print('=== Light Userdata ===')

        -- Cria dados externos
        local dados1 = criar_dados_externos('Item A', 100.5)
        local dados2 = criar_dados_externos('Item B', 200.75)

        print('\nInformações dos dados:')
        local id, nome, valor = obter_info_dados(dados1)
        print(string.format('  [%d] %s: %.2f', id, nome, valor))

        id, nome, valor = obter_info_dados(dados2)
        print(string.format('  [%d] %s: %.2f', id, nome, valor))

        -- Modifica valor
        print('\nModificando dados1...')
        modificar_dados(dados1, 150.25)

        id, nome, valor = obter_info_dados(dados1)
        print(string.format('  [%d] %s: %.2f (modificado)', id, nome, valor))

        -- Usa registry
        print("\nUsando Registry:")
        associar_com_registry(dados1, "Informação associada ao dados1")
        local info = recuperar_do_registry(dados1)
        print("  Recuperado:", info)

        -- Demonstra diferenças
        demonstrar_diferencas()
    )");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Light Userdata ===

Informações dos dados:
  [0] Item A: 100.50
  [1] Item B: 200.75

Modificando dados1...
  [0] Item A: 150.25 (modificado)

Usando Registry:
  Recuperado:   Informação associada ao dados1

=== Diferenças Full vs Light Userdata ===
Full userdata criado (gerenciado por Lua)
  Tamanho: 4 bytes
  Pode ter metatable: Sim
  Garbage collected: Sim

Light userdata criado (apenas ponteiro)
  Tamanho: apenas o ponteiro
  Pode ter metatable: Não
  Garbage collected: Não
*/
```

---

## 21.13 Gerenciando Recursos, Registry e Referências

### Usando o Registry

```c
// registry_referencias.c

#include <stdio.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Demonstração do Registry
static int l_demonstrar_registry(lua_State *L) {
    printf("\n=== Registry do Lua ===\n");

    // Registry é uma tabela especial no índice LUA_REGISTRYINDEX

    // 1. Acessar _G (ambiente global)
    lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS);
    printf("Acessou ambiente global\n");
    lua_pop(L, 1);

    // 2. Acessar main thread
    lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_MAINTHREAD);
    printf("Acessou thread principal\n");
    lua_pop(L, 1);

    // 3. Armazenar valor customizado
    lua_pushstring(L, "meu_valor");
    lua_pushinteger(L, 12345);
    lua_settable(L, LUA_REGISTRYINDEX);
    printf("Armazenou valor no registry\n");

    // 4. Recuperar valor
    lua_pushstring(L, "meu_valor");
    lua_gettable(L, LUA_REGISTRYINDEX);
    int valor = lua_tointeger(L, -1);
    printf("Recuperou valor: %d\n", valor);
    lua_pop(L, 1);

    return 0;
}

// Sistema de referências
static int l_criar_referencia(lua_State *L) {
    // Argumento: valor a ser referenciado
    // Retorna: número da referência

    int ref = luaL_ref(L, LUA_REGISTRYINDEX);
    lua_pushinteger(L, ref);

    printf("Referência criada: %d\n", ref);
    return 1;
}

static int l_obter_referencia(lua_State *L) {
    int ref = luaL_checkinteger(L, 1);

    // Recupera valor da referência
    lua_rawgeti(L, LUA_REGISTRYINDEX, ref);

    return 1;
}

static int l_liberar_referencia(lua_State *L) {
    int ref = luaL_checkinteger(L, 1);

    luaL_unref(L, LUA_REGISTRYINDEX, ref);
    printf("Referência %d liberada\n", ref);

    return 0;
}

// Exemplo prático: Callback system
typedef struct {
    lua_State *L;
    int callback_ref;
} CallbackData;

static CallbackData* criar_callback(lua_State *L) {
    luaL_checktype(L, 1, LUA_TFUNCTION);

    CallbackData *data = (CallbackData *)lua_newuserdata(L, sizeof(CallbackData));
    data->L = L;

    // Cria referência para a função
    lua_pushvalue(L, 1);  // Duplica função
    data->callback_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    printf("Callback registrado (ref: %d)\n", data->callback_ref);

    return data;
}

static int l_criar_callback(lua_State *L) {
    criar_callback(L);  // chama a função original
    return 1;           // retorna 1 valor (o userdata)
}

static int l_executar_callback(lua_State *L) {
    CallbackData *data = (CallbackData *)lua_touserdata(L, 1);
    const char *msg = luaL_checkstring(L, 2);

    // Recupera função do registry
    lua_rawgeti(L, LUA_REGISTRYINDEX, data->callback_ref);

    // Prepara argumentos
    lua_pushstring(L, msg);

    // Executa callback
    if (lua_pcall(L, 1, 0, 0) != LUA_OK) {
        fprintf(stderr, "Erro no callback: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }

    return 0;
}

static int l_limpar_callback(lua_State *L) {
    CallbackData *data = (CallbackData *)lua_touserdata(L, 1);

    luaL_unref(L, LUA_REGISTRYINDEX, data->callback_ref);
    printf("Callback liberado (ref: %d)\n", data->callback_ref);
    data->callback_ref = LUA_NOREF;

    return 0;
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    lua_register(L, "demonstrar_registry", l_demonstrar_registry);
    lua_register(L, "criar_referencia", l_criar_referencia);
    lua_register(L, "obter_referencia", l_obter_referencia);
    lua_register(L, "liberar_referencia", l_liberar_referencia);
    lua_register(L, "criar_callback", l_criar_callback);
    lua_register(L, "executar_callback", l_executar_callback);
    lua_register(L, "limpar_callback", l_limpar_callback);

    luaL_dostring(L, R"(
        demonstrar_registry()

        print('\n=== Sistema de Referências ===')

        -- Cria referências para valores
        local tabela = {nome = 'Teste', valor = 100}
        local ref1 = criar_referencia(tabela)

        local funcao = function() return 'Olá!' end
        local ref2 = criar_referencia(funcao)

        print('\nRecuperando valores:')
        local t = obter_referencia(ref1)
        print('Tabela:', t.nome, t.valor)

        local f = obter_referencia(ref2)
        print('Função:', f())

        -- Libera referências
        print('\nLiberando:')
        liberar_referencia(ref1)
        liberar_referencia(ref2)

        print('\n=== Sistema de Callbacks ===')

        local callback = criar_callback(function(msg)
            print('Callback executado:', msg)
        end)

        executar_callback(callback, 'Primeira chamada')
        executar_callback(callback, 'Segunda chamada')

        limpar_callback(callback)
    )");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Registry do Lua ===
Acessou ambiente global
Acessou thread principal
Armazenou valor no registry
Recuperou valor: 12345

=== Sistema de Referências ===
Referência criada: 4
Referência criada: 5

Recuperando valores:
Tabela: Teste   100
Função: Olá!

Liberando:
Referência 4 liberada
Referência 5 liberada

=== Sistema de Callbacks ===
Callback registrado (ref: 5)
Callback executado:     Primeira chamada
Callback executado:     Segunda chamada
Callback liberado (ref: 5)
*/
```

---

## 21.14 Upvalues em Closures C

### Criando Closures com Estado

```c
// closures_c.c

#include <stdio.h>
#include <string.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Exemplo 1: Contador com upvalue
static int contador(lua_State *L) {
    // Acessa upvalue (índice 1)
    int valor = lua_tointeger(L, lua_upvalueindex(1));

    valor++;

    // Atualiza upvalue
    lua_pushinteger(L, valor);
    lua_replace(L, lua_upvalueindex(1));

    // Retorna novo valor
    lua_pushinteger(L, valor);
    return 1;
}

static int criar_contador(lua_State *L) {
    int inicial = luaL_optinteger(L, 1, 0);

    // Cria upvalue
    lua_pushinteger(L, inicial);

    // Cria closure com 1 upvalue
    lua_pushcclosure(L, contador, 1);

    return 1;
}

// Exemplo 2: Múltiplos upvalues
static int operacao_matematica(lua_State *L) {
    double x = luaL_checknumber(L, 1);

    // Acessa upvalues
    double a = lua_tonumber(L, lua_upvalueindex(1));  // coeficiente
    double b = lua_tonumber(L, lua_upvalueindex(2));  // constante
    const char *op = lua_tostring(L, lua_upvalueindex(3));  // operação

    double resultado;

    if (strcmp(op, "linear") == 0) {
        resultado = a * x + b;
    } else if (strcmp(op, "quadratica") == 0) {
        resultado = a * x * x + b;
    } else {
        resultado = x;
    }

    lua_pushnumber(L, resultado);
    return 1;
}

static int criar_funcao_matematica(lua_State *L) {
    double a = luaL_checknumber(L, 1);
    double b = luaL_checknumber(L, 2);
    const char *op = luaL_checkstring(L, 3);

    // Cria upvalues
    lua_pushnumber(L, a);
    lua_pushnumber(L, b);
    lua_pushstring(L, op);

    // Cria closure com 3 upvalues
    lua_pushcclosure(L, operacao_matematica, 3);

    return 1;
}

// Exemplo 3: Estado compartilhado entre funções com tabela como upvalue
static int incrementar(lua_State *L) {
    lua_getfield(L, lua_upvalueindex(1), "valor");
    int valor = lua_tointeger(L, -1);
    lua_pop(L, 1);

    valor++;

    lua_pushinteger(L, valor);
    lua_setfield(L, lua_upvalueindex(1), "valor");

    lua_pushinteger(L, valor);
    return 1;
}

static int decrementar(lua_State *L) {
    lua_getfield(L, lua_upvalueindex(1), "valor");
    int valor = lua_tointeger(L, -1);
    lua_pop(L, 1);

    valor--;

    lua_pushinteger(L, valor);
    lua_setfield(L, lua_upvalueindex(1), "valor");

    lua_pushinteger(L, valor);
    return 1;
}

static int obter_valor(lua_State *L) {
    lua_getfield(L, lua_upvalueindex(1), "valor");
    int valor = lua_tointeger(L, -1);
    lua_pop(L, 1);

    lua_pushinteger(L, valor);
    return 1;
}

static int criar_contador_completo(lua_State *L) {
    int inicial = luaL_optinteger(L, 1, 0);

    // Cria tabela de retorno
    lua_newtable(L);              // [tabela]
    lua_newtable(L);              // [tabela][estado]

    // Upvalue compartilhado
    lua_pushinteger(L, inicial);
    lua_setfield(L, -2, "valor"); // estado.valor = inicial

    // Função incrementar
    lua_pushvalue(L, -1); // duplica upvalue para cada função
    lua_pushcclosure(L, incrementar, 1);
    lua_setfield(L, -3, "incrementar");

    // Função decrementar
    lua_pushvalue(L, -1);
    lua_pushcclosure(L, decrementar, 1);
    lua_setfield(L, -3, "decrementar");

    // Função obter
    lua_pushvalue(L, -1);
    lua_pushcclosure(L, obter_valor, 1);
    lua_setfield(L, -3, "obter");

    lua_pop(L, 1); // remove estado da pilha

    return 1;
}

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    lua_register(L, "criar_contador", criar_contador);
    lua_register(L, "criar_funcao_matematica", criar_funcao_matematica);
    lua_register(L, "criar_contador_completo", criar_contador_completo);

    luaL_dostring(L, R"(
        print('=== Contador Simples ===')
        local c1 = criar_contador(10)
        local c2 = criar_contador(100)

        print('c1:', c1(), c1(), c1())
        print('c2:', c2(), c2())
        print('c1 novamente:', c1())
        print()

        print('=== Funções Matemáticas ===')
        local linear = criar_funcao_matematica(2, 3, 'linear')      -- 2x + 3
        local quadratica = criar_funcao_matematica(1, -4, 'quadratica')  -- x² - 4

        print('Linear (x=5):', linear(5))      -- 2*5 + 3 = 13
        print('Linear (x=10):', linear(10))    -- 2*10 + 3 = 23
        print('Quadrática (x=3):', quadratica(3))  -- 3² - 4 = 5
        print('Quadrática (x=5):', quadratica(5))  -- 5² - 4 = 21
        print()

        print('=== Contador Completo ===')
        local contador = criar_contador_completo(50)

        print('Valor inicial:', contador.obter())
        print('Incrementar:', contador.incrementar())
        print('Incrementar:', contador.incrementar())
        print('Decrementar:', contador.decrementar())
        print('Valor final:', contador.obter())
    )");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Contador Simples ===
c1:     11      12      13
c2:     101     102
c1 novamente:   14

=== Funções Matemáticas ===
Linear (x=5):   13.0
Linear (x=10):  23.0
Quadrática (x=3):       5.0
Quadrática (x=5):       21.0

=== Contador Completo ===
Valor inicial:  50
Incrementar:    51
Incrementar:    52
Decrementar:    51
Valor final:    51
*/
```

---

## 21.15 Threads e Múltiplos Estados Lua

### Criando e Gerenciando Estados

```c
// multiplos_estados.c

#include <stdio.h>
#include <stdlib.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Executa código em um estado
void executar_no_estado(lua_State *L, const char *nome, const char *codigo) {
    printf("\n=== Estado: %s ===\n", nome);

    if (luaL_dostring(L, codigo) != LUA_OK) {
        fprintf(stderr, "Erro: %s\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }
}

// Demonstra isolamento entre estados
void demonstrar_isolamento() {
    printf("=== Isolamento entre Estados ===\n");

    // Cria dois estados independentes
    lua_State *L1 = luaL_newstate();
    lua_State *L2 = luaL_newstate();

    luaL_openlibs(L1);
    luaL_openlibs(L2);

    // Define variável apenas em L1
    executar_no_estado(L1, "L1", "x = 42; print('L1: x =', x)");

    // Tenta acessar em L2 (não existe)
    executar_no_estado(L2, "L2", "print('L2: x =', x)");

    // Define em L2
    executar_no_estado(L2, "L2", "x = 99; print('L2: x =', x)");

    // L1 ainda tem o valor original
    executar_no_estado(L1, "L1", "print('L1: x =', x)");

    lua_close(L1);
    lua_close(L2);
}

// Compartilhar dados entre estados
void compartilhar_dados() {
    printf("\n\n=== Compartilhamento Manual ===\n");

    lua_State *L1 = luaL_newstate();
    lua_State *L2 = luaL_newstate();

    luaL_openlibs(L1);
    luaL_openlibs(L2);

    // Define tabela em L1
    luaL_dostring(L1, "dados = {nome = 'João', idade = 30}");

    // Transfere manualmente para L2
    lua_getglobal(L1, "dados");
    lua_getfield(L1, -1, "nome");
    const char *nome = lua_tostring(L1, -1);
    lua_pop(L1, 1);

    lua_getfield(L1, -1, "idade");
    int idade = lua_tointeger(L1, -1);
    lua_pop(L1, 2);

    // Cria em L2
    lua_newtable(L2);
    lua_pushstring(L2, nome);
    lua_setfield(L2, -2, "nome");
    lua_pushinteger(L2, idade);
    lua_setfield(L2, -2, "idade");
    lua_setglobal(L2, "dados");

    // Verifica em L2
    executar_no_estado(L2, "L2",
        "print('Dados transferidos:', dados.nome, dados.idade)");

    lua_close(L1);
    lua_close(L2);
}

// Sistema de sandbox
typedef struct {
    lua_State *L;
    int limite_memoria;
    int memoria_usada;
} Sandbox;

// Alocador customizado para controlar memória
void* sandbox_alloc(void *ud, void *ptr, size_t osize, size_t nsize) {
    Sandbox *sb = (Sandbox *)ud;

    if (nsize == 0) {
        // Liberação
        sb->memoria_usada -= osize;
        free(ptr);
        return NULL;
    }

    // Verifica limite
    int nova_memoria = sb->memoria_usada - osize + nsize;
    if (nova_memoria > sb->limite_memoria) {
        return NULL;  // Limite excedido
    }

    void *novo_ptr = realloc(ptr, nsize);
    if (novo_ptr) {
        sb->memoria_usada = nova_memoria;
    }

    return novo_ptr;
}

Sandbox* criar_sandbox(int limite_kb) {
    Sandbox *sb = (Sandbox *)malloc(sizeof(Sandbox));
    sb->limite_memoria = limite_kb * 1024;
    sb->memoria_usada = 0;

    sb->L = lua_newstate(sandbox_alloc, sb);
    luaL_openlibs(sb->L);

    printf("Sandbox criado (limite: %d KB)\n", limite_kb);
    return sb;
}

void destruir_sandbox(Sandbox *sb) {
    printf("Memória usada: %.2f KB\n", sb->memoria_usada / 1024.0);
    lua_close(sb->L);
    free(sb);
}

void testar_sandbox() {
    printf("\n\n=== Sistema de Sandbox ===\n");

    Sandbox *sb = criar_sandbox(100);  // Limite de 100 KB

    // Código seguro
    printf("\nExecutando código seguro:\n");
    if (luaL_dostring(sb->L, "x = 42; print('x =', x)") != LUA_OK) {
        fprintf(stderr, "Erro: %s\n", lua_tostring(sb->L, -1));
        lua_pop(sb->L, 1);
    }

    // Tenta alocar muita memória
    printf("\nTentando alocar muita memória:\n");
    if (luaL_dostring(sb->L, "t = {}; for i=1,1000000 do t[i] = {} end") != LUA_OK) {
        fprintf(stderr, "Erro: %s\n", lua_tostring(sb->L, -1));
        lua_pop(sb->L, 1);
    }

    destruir_sandbox(sb);
}

int main(void) {
    demonstrar_isolamento();
    compartilhar_dados();
    testar_sandbox();

    return 0;
}

/*
Saída esperada>
=== Isolamento entre Estados ===

=== Estado: L1 ===
L1: x = 42

=== Estado: L2 ===
L2: x = nil

=== Estado: L2 ===
L2: x = 99

=== Estado: L1 ===
L1: x = 42

=== Compartilhamento Manual ===

=== Estado: L2 ===
Dados transferidos:     João    30

=== Sistema de Sandbox ===
Sandbox criado (limite: 100 KB)

Executando código seguro:
x =     42

Tentando alocar muita memória:
Erro: not enough memory
Memória usada: 86.68 KB
*/
```

---

## 21.16 Corrotinas (Threads Lua)

### Operações Básicas com Corrotinas

```c
// corrotinas_basicas.c

#include <stdio.h>
#include <string.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Função auxiliar para imprimir o status de uma corrotina
const char* get_coroutine_status(lua_State *L, int idx) {
    int status = lua_status(L);

    if (status == LUA_OK) {
        // Pode estar morta ou suspensa
        lua_Debug ar;
        if (lua_getstack(L, 0, &ar) > 0) {
            return "suspended";
        } else {
            return "dead";
        }
    } else if (status == LUA_YIELD) {
        return "suspended";
    } else {
        return "error";
    }
}

// Exemplo de função Lua que será executada na corrotina
const char *coroutine_function =
    "function counter(max)\n"
    "    for i = 1, max do\n"
    "        print('Corrotina contando: ' .. i)\n"
    "        coroutine.yield(i)  -- Suspende e retorna i\n"
    "    end\n"
    "    return 'Finalizado!'\n"
    "end\n";

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    printf("=== Exemplo 1: Corrotinas Básicas ===\n\n");

    // Carregar a função contador
    if (luaL_dostring(L, coroutine_function) != LUA_OK) {
        fprintf(stderr, "Erro ao carregar função: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 1;
    }

    // PASSO 1: Criar uma nova corrotina
    printf("1. Criando nova corrotina...\n");
    lua_State *co = lua_newthread(L);  // Cria thread e empilha em L
    printf("   Thread criada: %p\n\n", (void*)co);

    // PASSO 2: Configurar a corrotina com a função
    lua_getglobal(co, "counter");  // Pega a função no estado da corrotina
    lua_pushinteger(co, 5);        // Argumento: contar até 5

    // PASSO 3: Resumir a corrotina múltiplas vezes
    printf("2. Executando corrotina com yields...\n");
    int nres;
    int status;

    for (int i = 0; i < 10; i++) {
        status = lua_resume(co, L, (i == 0) ? 1 : 0, &nres);

        printf("   Tentativa %d - Status: ", i + 1);

        if (status == LUA_YIELD) {
            printf("YIELD (suspensa)\n");
            if (nres > 0) {
                printf("   Valor retornado: %lld\n", lua_tointeger(co, -1));
                lua_pop(co, nres);  // Limpa valores retornados
            }
        } else if (status == LUA_OK) {
            printf("OK (finalizada)\n");
            if (nres > 0) {
                printf("   Valor final: %s\n", lua_tostring(co, -1));
                lua_pop(co, nres);
            }
            break;
        } else {
            printf("ERRO\n");
            fprintf(stderr, "   Erro: %s\n", lua_tostring(co, -1));
            break;
        }
    }

    // PASSO 4: Demonstrar verificação de status
    printf("\n3. Verificando status de diferentes corrotinas...\n");

    // Criar corrotina que já está morta
    lua_State *co_dead = lua_newthread(L);
    lua_getglobal(co_dead, "counter");
    lua_pushinteger(co_dead, 1);
    lua_resume(co_dead, L, 1, &nres);  // Executa completamente (1 iteração)
    lua_resume(co_dead, L, 0, &nres);  // Tenta resumir corrotina morta

    printf("   Corrotina finalizada - Status: %s\n", get_coroutine_status(co_dead, 0));
    printf("   Corrotina principal - Status: %s\n", get_coroutine_status(co, 0));

    // PASSO 5: Exemplo usando lua_yieldk (yield do lado C)
    printf("\n4. Exemplo de corrotina com função C...\n");

    // Criar código Lua que chama função C com yield
    const char *c_yield_code =
        "function c_yielder()\n"
        "    for i = 1, 3 do\n"
        "        print('   Função C-style chamada (vez ' .. i .. ')')\n"
        "        if i < 3 then\n"
        "            coroutine.yield(i)\n"
        "        end\n"
        "    end\n"
        "    return 'Função C concluída'\n"
        "end\n";

    if (luaL_dostring(L, c_yield_code) != LUA_OK) {
        fprintf(stderr, "Erro: %s\n", lua_tostring(L, -1));
    }

    // Criar corrotina que chama a função
    lua_State *co_c = lua_newthread(L);
    lua_getglobal(co_c, "c_yielder");

    for (int i = 0; i < 4; i++) {
        status = lua_resume(co_c, L, 0, &nres);
        if (status == LUA_YIELD) {
            printf("   Yielded: %lld\n", lua_tointeger(co_c, -1));
            lua_pop(co_c, nres);
        } else if (status == LUA_OK) {
            printf("   Finalizado: %s\n", lua_tostring(co_c, -1));
            lua_pop(co_c, nres);
            break;
        }
    }

    printf("\n=== Fim do Exemplo 1 ===\n");

    lua_close(L);
    return 0;
}

/*
Saída esperada>
=== Exemplo 1: Corrotinas Básicas ===

1. Criando nova corrotina...
   Thread criada: 0x7f3e2233f928

2. Executando corrotina com yields...
Corrotina contando: 1
   Tentativa 1 - Status: YIELD (suspensa)
   Valor retornado: 1
Corrotina contando: 2
   Tentativa 2 - Status: YIELD (suspensa)
   Valor retornado: 2
Corrotina contando: 3
   Tentativa 3 - Status: YIELD (suspensa)
   Valor retornado: 3
Corrotina contando: 4
   Tentativa 4 - Status: YIELD (suspensa)
   Valor retornado: 4
Corrotina contando: 5
   Tentativa 5 - Status: YIELD (suspensa)
   Valor retornado: 5
   Tentativa 6 - Status: OK (finalizada)
   Valor final: Finalizado!

3. Verificando status de diferentes corrotinas...
Corrotina contando: 1
   Corrotina finalizada - Status: dead
   Corrotina principal - Status: dead

4. Exemplo de corrotina com função C...
   Função C-style chamada (vez 1)
   Yielded: 1
   Função C-style chamada (vez 2)
   Yielded: 2
   Função C-style chamada (vez 3)
   Finalizado: Função C concluída

=== Fim do Exemplo 1 ===
*/
```

### Padrão Produtor/Consumidor

```c
// produtor_consumidor.c

#include <stdio.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Código Lua: Produtor que gera valores
const char *producer_code =
    "function producer()\n"
    "    print('[Produtor] Iniciando produção...')\n"
    "    for i = 1, 5 do\n"
    "        local item = 'Item_' .. i\n"
    "        print('[Produtor] Produzindo: ' .. item)\n"
    "        coroutine.yield(item)  -- Envia item para consumidor\n"
    "    end\n"
    "    print('[Produtor] Produção finalizada')\n"
    "    return 'FIM'\n"
    "end\n";

// Código Lua: Consumidor que recebe valores via resume
const char *consumer_code =
    "function consumer(receive_func)\n"
    "    print('[Consumidor] Aguardando itens...')\n"
    "    while true do\n"
    "        local item = receive_func()  -- Recebe do produtor\n"
    "        if item == 'FIM' then\n"
    "            print('[Consumidor] Fim dos itens')\n"
    "            break\n"
    "        end\n"
    "        print('[Consumidor] Processando: ' .. item)\n"
    "        coroutine.yield('OK_' .. item)  -- Confirma processamento\n"
    "    end\n"
    "    return 'Consumidor finalizado'\n"
    "end\n";

// Função auxiliar para receber valores do produtor
const char *helper_code =
    "function create_receiver(producer_co)\n"
    "    return function()\n"
    "        local status, value = coroutine.resume(producer_co)\n"
    "        return value\n"
    "    end\n"
    "end\n";

// Função que implementa filtro (transforma dados entre produtor e consumidor)
const char *filter_code =
    "function filter(producer_co, transform_func)\n"
    "    return coroutine.create(function()\n"
    "        while true do\n"
    "            local status, value = coroutine.resume(producer_co)\n"
    "            if status and value ~= 'FIM' then\n"
    "                value = transform_func(value)\n"
    "                coroutine.yield(value)\n"
    "            else\n"
    "                return value\n"
    "            end\n"
    "        end\n"
    "    end)\n"
    "end\n";

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    printf("=== Exemplo 2: Produtor/Consumidor ===\n\n");

    // Carregar todos os códigos Lua
    if (luaL_dostring(L, producer_code) != LUA_OK ||
        luaL_dostring(L, consumer_code) != LUA_OK ||
        luaL_dostring(L, helper_code) != LUA_OK ||
        luaL_dostring(L, filter_code) != LUA_OK) {
        fprintf(stderr, "Erro ao carregar código: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 1;
    }

    // ====== PARTE 1: Produtor/Consumidor Simples ======
    printf("--- Parte 1: Produtor -> Consumidor Direto ---\n\n");

    // Criar e executar usando Lua diretamente
    const char *exec_code1 =
        "local producer_co = coroutine.create(producer)\n"
        "local receiver = create_receiver(producer_co)\n"
        "local consumer_co = coroutine.create(consumer)\n"
        "\n"
        "-- Primeira chamada passa receiver\n"
        "local status, result = coroutine.resume(consumer_co, receiver)\n"
        "\n"
        "-- Loop até terminar\n"
        "while coroutine.status(consumer_co) ~= 'dead' do\n"
        "    if status and result then\n"
        "        print('[C] Confirmação recebida: ' .. result .. '\\n')\n"
        "    end\n"
        "    status, result = coroutine.resume(consumer_co)\n"
        "end\n"
        "\n"
        "if status and result then\n"
        "    print('\\n[C] ' .. result .. '\\n')\n"
        "end\n";

    if (luaL_dostring(L, exec_code1) != LUA_OK) {
        fprintf(stderr, "[ERRO Parte 1] %s\n\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }

    // ====== PARTE 2: Produtor -> Filtro -> Consumidor ======
    printf("\n--- Parte 2: Produtor -> Filtro -> Consumidor ---\n\n");

    const char *exec_code2 =
        "local producer_co = coroutine.create(producer)\n"
        "local filter_co = filter(producer_co, function(s) return string.upper(s) end)\n"
        "local receiver = create_receiver(filter_co)\n"
        "local consumer_co = coroutine.create(consumer)\n"
        "\n"
        "-- Primeira chamada passa receiver\n"
        "local status, result = coroutine.resume(consumer_co, receiver)\n"
        "\n"
        "-- Loop até terminar\n"
        "while coroutine.status(consumer_co) ~= 'dead' do\n"
        "    if status and result then\n"
        "        print('[C] Confirmação com filtro: ' .. result .. '\\n')\n"
        "    end\n"
        "    status, result = coroutine.resume(consumer_co)\n"
        "end\n"
        "\n"
        "if status and result then\n"
        "    print('\\n[C] ' .. result .. '\\n')\n"
        "end\n";

    if (luaL_dostring(L, exec_code2) != LUA_OK) {
        fprintf(stderr, "[ERRO Parte 2] %s\n\n", lua_tostring(L, -1));
        lua_pop(L, 1);
    }

    // ====== PARTE 3: Pipeline com múltiplos filtros do lado C ======
    printf("\n--- Parte 3: Pipeline gerenciado em C ---\n\n");

    // Criar produtor
    lua_getglobal(L, "coroutine");
    lua_getfield(L, -1, "create");
    lua_getglobal(L, "producer");
    lua_call(L, 1, 1);
    lua_State *prod_co = lua_tothread(L, -1);
    lua_pop(L, 2);

    // Processar pipeline manualmente em C
    printf("[C Pipeline] Iniciando processamento...\n");

    int nres;
    int status = lua_resume(prod_co, L, 0, &nres);

    while (status == LUA_YIELD) {
        if (nres > 0) {
            const char *item = lua_tostring(prod_co, -1);
            printf("[C Pipeline] Recebido: %s\n", item);
            printf("[C Pipeline] Processado: %s_PROCESSED\n\n", item);
            lua_pop(prod_co, nres);
        }
        status = lua_resume(prod_co, L, 0, &nres);
    }

    printf("[C Pipeline] %s\n", lua_tostring(prod_co, -1));

    printf("\n=== Fim do Exemplo 2 ===\n");

    lua_close(L);
    return 0;
}

/*
=== Exemplo 2: Produtor/Consumidor ===

--- Parte 1: Produtor -> Consumidor Direto ---

[Consumidor] Aguardando itens...
[Produtor] Iniciando produção...
[Produtor] Produzindo: Item_1
[Consumidor] Processando: Item_1
[C] Confirmação recebida: OK_Item_1

[Produtor] Produzindo: Item_2
[Consumidor] Processando: Item_2
[C] Confirmação recebida: OK_Item_2

[Produtor] Produzindo: Item_3
[Consumidor] Processando: Item_3
[C] Confirmação recebida: OK_Item_3

[Produtor] Produzindo: Item_4
[Consumidor] Processando: Item_4
[C] Confirmação recebida: OK_Item_4

[Produtor] Produzindo: Item_5
[Consumidor] Processando: Item_5
[C] Confirmação recebida: OK_Item_5

[Produtor] Produção finalizada
[Consumidor] Fim dos itens

[C] Consumidor finalizado

--- Parte 2: Produtor -> Filtro -> Consumidor ---

[Consumidor] Aguardando itens...
[Produtor] Iniciando produção...
[Produtor] Produzindo: Item_1
[Consumidor] Processando: ITEM_1
[C] Confirmação com filtro: OK_ITEM_1

[Produtor] Produzindo: Item_2
[Consumidor] Processando: ITEM_2
[C] Confirmação com filtro: OK_ITEM_2

[Produtor] Produzindo: Item_3
[Consumidor] Processando: ITEM_3
[C] Confirmação com filtro: OK_ITEM_3

[Produtor] Produzindo: Item_4
[Consumidor] Processando: ITEM_4
[C] Confirmação com filtro: OK_ITEM_4

[Produtor] Produzindo: Item_5
[Consumidor] Processando: ITEM_5
[C] Confirmação com filtro: OK_ITEM_5

[Produtor] Produção finalizada
[Consumidor] Fim dos itens

[C] Consumidor finalizado

--- Parte 3: Pipeline gerenciado em C ---

[C Pipeline] Iniciando processamento...
[Produtor] Iniciando produção...
[Produtor] Produzindo: Item_1
[C Pipeline] Recebido: Item_1
[C Pipeline] Processado: Item_1_PROCESSED

[Produtor] Produzindo: Item_2
[C Pipeline] Recebido: Item_2
[C Pipeline] Processado: Item_2_PROCESSED

[Produtor] Produzindo: Item_3
[C Pipeline] Recebido: Item_3
[C Pipeline] Processado: Item_3_PROCESSED

[Produtor] Produzindo: Item_4
[C Pipeline] Recebido: Item_4
[C Pipeline] Processado: Item_4_PROCESSED

[Produtor] Produzindo: Item_5
[C Pipeline] Recebido: Item_5
[C Pipeline] Processado: Item_5_PROCESSED

[Produtor] Produção finalizada
[C Pipeline] FIM

=== Fim do Exemplo 2 ===
*/
```

### Sistema de Agendamento de Tarefas

```c
// agendamento.c

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

// Estrutura para representar uma tarefa
typedef struct Task {
    int id;
    lua_State *coroutine;
    int ref;  // Referência no registry
    bool completed;
    char name[64];
    struct Task *next;
} Task;

// Estrutura do agendador
typedef struct {
    lua_State *L;
    Task *head;
    Task *tail;
    int next_id;
    int active_tasks;
} Scheduler;

// Inicializar o agendador
Scheduler* scheduler_new(lua_State *L) {
    Scheduler *sched = (Scheduler*)malloc(sizeof(Scheduler));
    sched->L = L;
    sched->head = NULL;
    sched->tail = NULL;
    sched->next_id = 1;
    sched->active_tasks = 0;
    return sched;
}

// Adicionar tarefa ao agendador
int scheduler_add_task(Scheduler *sched, const char *name, const char *code) {
    Task *task = (Task*)malloc(sizeof(Task));
    task->id = sched->next_id++;
    task->completed = false;
    snprintf(task->name, sizeof(task->name), "%s", name);
    task->next = NULL;

    // Criar corrotina
    lua_State *co = lua_newthread(sched->L);
    task->ref = luaL_ref(sched->L, LUA_REGISTRYINDEX);  // Salvar referência
    task->coroutine = co;

    // Carregar código da tarefa na corrotina
    if (luaL_loadstring(co, code) != LUA_OK) {
        fprintf(stderr, "Erro ao carregar tarefa %s: %s\n",
                name, lua_tostring(co, -1));
        luaL_unref(sched->L, LUA_REGISTRYINDEX, task->ref);
        free(task);
        return -1;
    }

    // Adicionar à lista
    if (sched->tail == NULL) {
        sched->head = sched->tail = task;
    } else {
        sched->tail->next = task;
        sched->tail = task;
    }

    sched->active_tasks++;
    printf("[Scheduler] Tarefa #%d '%s' adicionada\n", task->id, task->name);

    return task->id;
}

// Executar um ciclo do agendador (round-robin)
bool scheduler_run_cycle(Scheduler *sched) {
    if (sched->head == NULL) {
        return false;  // Nenhuma tarefa
    }

    printf("\n--- Ciclo de Execução ---\n");

    Task *current = sched->head;
    Task *prev = NULL;
    bool any_active = false;

    while (current != NULL) {
        if (current->completed) {
            prev = current;
            current = current->next;
            continue;
        }

        printf("[Tarefa #%d '%s'] Executando...\n", current->id, current->name);

        int nres;
        int status = lua_resume(current->coroutine, sched->L, 0, &nres);

        if (status == LUA_YIELD) {
            printf("[Tarefa #%d '%s'] Suspensa (YIELD)", current->id, current->name);
            if (nres > 0) {
                printf(" - Retornou: %s", lua_tostring(current->coroutine, -1));
                lua_pop(current->coroutine, nres);
            }
            printf("\n");
            any_active = true;

        } else if (status == LUA_OK) {
            printf("[Tarefa #%d '%s'] CONCLUÍDA", current->id, current->name);
            if (nres > 0) {
                printf(" - Resultado: %s", lua_tostring(current->coroutine, -1));
                lua_pop(current->coroutine, nres);
            }
            printf("\n");
            current->completed = true;
            sched->active_tasks--;

        } else {
            fprintf(stderr, "[Tarefa #%d '%s'] ERRO: %s\n",
                    current->id, current->name, lua_tostring(current->coroutine, -1));
            current->completed = true;
            sched->active_tasks--;
        }

        prev = current;
        current = current->next;
    }

    return any_active;
}

// Executar todas as tarefas até completarem
void scheduler_run_all(Scheduler *sched) {
    printf("\n=== Iniciando Execução de Todas as Tarefas ===\n");

    int cycle = 1;
    while (scheduler_run_cycle(sched)) {
        printf("\n[Scheduler] Fim do ciclo %d - %d tarefa(s) ativa(s)\n",
               cycle++, sched->active_tasks);
    }

    printf("\n=== Todas as Tarefas Concluídas ===\n");
}

// Listar tarefas
void scheduler_list_tasks(Scheduler *sched) {
    printf("\n--- Lista de Tarefas ---\n");
    Task *current = sched->head;
    int count = 0;

    while (current != NULL) {
        count++;
        printf("  #%d '%s' - %s\n",
               current->id,
               current->name,
               current->completed ? "CONCLUÍDA" : "ATIVA");
        current = current->next;
    }

    printf("Total: %d tarefa(s), %d ativa(s)\n", count, sched->active_tasks);
}

// Limpar agendador
void scheduler_free(Scheduler *sched) {
    Task *current = sched->head;
    while (current != NULL) {
        Task *next = current->next;
        luaL_unref(sched->L, LUA_REGISTRYINDEX, current->ref);
        free(current);
        current = next;
    }
    free(sched);
}

// Função C para callback
static int notify_c_callback(lua_State *L) {
    const char *msg = luaL_checkstring(L, 1);
    printf("  [C Callback] Mensagem da task: %s\n", msg);
    lua_pushstring(L, "ACK from C");
    return 1;
}

// ====== Código das tarefas de exemplo ======

const char *task1_code =
    "local count = 0\n"
    "for i = 1, 3 do\n"
    "    count = count + 1\n"
    "    print('  [Task1] Iteração ' .. i)\n"
    "    coroutine.yield('step_' .. i)\n"
    "end\n"
    "return 'Task1 finalizada com ' .. count .. ' iterações'\n";

const char *task2_code =
    "print('  [Task2] Processamento pesado iniciado')\n"
    "coroutine.yield('processando...')\n"
    "print('  [Task2] Continuando processamento')\n"
    "coroutine.yield('quase lá...')\n"
    "print('  [Task2] Finalizando')\n"
    "return 'Task2 completa'\n";

const char *task3_code =
    "local sum = 0\n"
    "for i = 1, 5 do\n"
    "    sum = sum + i\n"
    "    if i % 2 == 0 then\n"
    "        print('  [Task3] Soma parcial: ' .. sum)\n"
    "        coroutine.yield('parcial_' .. sum)\n"
    "    end\n"
    "end\n"
    "return 'Task3: soma final = ' .. sum\n";

// Tarefa que usa sleep/wait
const char *task_delayed_code =
    "local steps = {'Iniciando', 'Meio', 'Finalizando'}\n"
    "for i, step in ipairs(steps) do\n"
    "    print('  [TaskDelayed] ' .. step)\n"
    "    coroutine.yield(step)\n"
    "end\n"
    "return 'TaskDelayed concluída'\n";

// Tarefa com prioridade simulada
const char *task_priority_code =
    "print('  [TaskPriority] Executando tarefa prioritária!')\n"
    "coroutine.yield('prioridade_alta')\n"
    "print('  [TaskPriority] Continuação prioritária')\n"
    "return 'TaskPriority finalizada'\n";

int main(void) {
    lua_State *L = luaL_newstate();
    luaL_openlibs(L);

    printf("╔════════════════════════════════════════════════╗\n");
    printf("║  Exemplo 3: Sistema de Tarefas com Corrotinas ║\n");
    printf("╚════════════════════════════════════════════════╝\n");

    // Criar agendador
    Scheduler *scheduler = scheduler_new(L);

    // ====== DEMONSTRAÇÃO 1: Adicionar e Listar Tarefas ======
    printf("\n▶ Demonstração 1: Adicionar Tarefas\n");

    scheduler_add_task(scheduler, "Contador", task1_code);
    scheduler_add_task(scheduler, "Processador", task2_code);
    scheduler_add_task(scheduler, "Calculadora", task3_code);

    scheduler_list_tasks(scheduler);

    // ====== DEMONSTRAÇÃO 2: Executar Todas as Tarefas ======
    printf("\n▶ Demonstração 2: Executar Round-Robin\n");

    scheduler_run_all(scheduler);
    scheduler_list_tasks(scheduler);

    // ====== DEMONSTRAÇÃO 3: Adicionar Tarefas Dinamicamente ======
    printf("\n▶ Demonstração 3: Adicionar Durante Execução\n");

    // Criar novo scheduler
    scheduler_free(scheduler);
    scheduler = scheduler_new(L);

    scheduler_add_task(scheduler, "Task1", task1_code);
    scheduler_add_task(scheduler, "Task2", task2_code);

    // Executar um ciclo
    scheduler_run_cycle(scheduler);

    // Adicionar mais tarefas
    printf("\n[Main] Adicionando novas tarefas...\n");
    scheduler_add_task(scheduler, "TaskDelayed", task_delayed_code);
    scheduler_add_task(scheduler, "TaskPriority", task_priority_code);

    // Continuar execução
    while (scheduler_run_cycle(scheduler)) {
        // Pode adicionar lógica aqui
    }

    printf("\n[Main] Execução completa!\n");
    scheduler_list_tasks(scheduler);

    // ====== DEMONSTRAÇÃO 4: Comunicação entre Tarefas ======
    printf("\n▶ Demonstração 4: Tarefas Comunicantes\n");

    scheduler_free(scheduler);
    scheduler = scheduler_new(L);

    // Criar tarefas que compartilham dados via upvalues
    const char *shared_task =
        "do\n"
        "    local shared = {counter = 0}\n"
        "    \n"
        "    function task_writer()\n"
        "        for i = 1, 3 do\n"
        "            shared.counter = shared.counter + 1\n"
        "            print('  [Writer] Escreveu: ' .. shared.counter)\n"
        "            coroutine.yield()\n"
        "        end\n"
        "        return 'Writer done'\n"
        "    end\n"
        "    \n"
        "    function task_reader()\n"
        "        for i = 1, 3 do\n"
        "            print('  [Reader] Leu: ' .. shared.counter)\n"
        "            coroutine.yield()\n"
        "        end\n"
        "        return 'Reader done'\n"
        "    end\n"
        "end\n";

    // Carregar código compartilhado
    if (luaL_dostring(L, shared_task) != LUA_OK) {
        fprintf(stderr, "Erro: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 1;
    }

    // Adicionar tarefas comunicantes
    lua_getglobal(L, "task_writer");
    lua_State *writer_co = lua_newthread(L);
    lua_pushvalue(L, -2);  // Copia função
    lua_xmove(L, writer_co, 1);  // Move para corrotina

    Task *writer = (Task*)malloc(sizeof(Task));
    writer->id = scheduler->next_id++;
    writer->coroutine = writer_co;
    writer->ref = luaL_ref(L, LUA_REGISTRYINDEX);
    writer->completed = false;
    snprintf(writer->name, sizeof(writer->name), "Writer");
    writer->next = NULL;

    lua_getglobal(L, "task_reader");
    lua_State *reader_co = lua_newthread(L);
    lua_pushvalue(L, -2);
    lua_xmove(L, reader_co, 1);

    Task *reader = (Task*)malloc(sizeof(Task));
    reader->id = scheduler->next_id++;
    reader->coroutine = reader_co;
    reader->ref = luaL_ref(L, LUA_REGISTRYINDEX);
    reader->completed = false;
    snprintf(reader->name, sizeof(reader->name), "Reader");
    reader->next = NULL;

    // Adicionar à lista
    scheduler->head = writer;
    writer->next = reader;
    scheduler->tail = reader;
    scheduler->active_tasks = 2;

    lua_pop(L, 2);  // Remove funções

    printf("[Scheduler] Tarefas comunicantes criadas\n");

    // Executar com comunicação
    while (scheduler_run_cycle(scheduler)) {
        // Loop continua até todas terminarem
    }

    printf("\n[Main] Comunicação entre tarefas concluída!\n");

    // ====== DEMONSTRAÇÃO 5: Tarefas com Callbacks C ======
    printf("\n▶ Demonstração 5: Callbacks C em Tarefas\n");

    scheduler_free(scheduler);
    scheduler = scheduler_new(L);

    // Registrar função C que pode ser chamada pelas tarefas
    lua_pushcfunction(L, notify_c_callback);
    lua_setglobal(L, "notify_c");

    const char *callback_task =
        "for i = 1, 2 do\n"
        "    local response = notify_c('Iteração ' .. i)\n"
        "    print('  [TaskCallback] C respondeu: ' .. response)\n"
        "    coroutine.yield()\n"
        "end\n"
        "return 'TaskCallback finalizada'\n";

    scheduler_add_task(scheduler, "CallbackTask", callback_task);
    scheduler_run_all(scheduler);

    // ====== DEMONSTRAÇÃO 6: Sistema de Prioridades ======
    printf("\n▶ Demonstração 6: Scheduler com Prioridades\n");

    // Criar sistema simples de prioridade usando múltiplos ciclos
    scheduler_free(scheduler);
    scheduler = scheduler_new(L);

    const char *high_priority =
        "print('  [HIGH] Tarefa prioritária executando')\n"
        "coroutine.yield('high_1')\n"
        "print('  [HIGH] Segunda execução prioritária')\n"
        "return 'HIGH concluída'\n";

    const char *low_priority =
        "for i = 1, 3 do\n"
        "    print('  [LOW] Tarefa baixa prioridade - passo ' .. i)\n"
        "    coroutine.yield('low_' .. i)\n"
        "end\n"
        "return 'LOW concluída'\n";

    scheduler_add_task(scheduler, "HighPrio", high_priority);
    scheduler_add_task(scheduler, "LowPrio", low_priority);

    // Executar high priority duas vezes por ciclo (simulação)
    printf("\n[Scheduler] Executando com prioridades simuladas...\n");

    int cycles = 0;
    while (scheduler->active_tasks > 0) {
        cycles++;
        printf("\n--- Ciclo %d (High Priority) ---\n", cycles);

        // Executar apenas tarefa high priority
        Task *high = scheduler->head;
        if (high && !high->completed) {
            printf("[Tarefa #%d '%s'] Executando (PRIORIDADE)...\n",
                   high->id, high->name);
            int nres;
            int status = lua_resume(high->coroutine, L, 0, &nres);

            if (status == LUA_YIELD) {
                printf("[Tarefa #%d] Suspensa\n", high->id);
                lua_pop(high->coroutine, nres);
            } else if (status == LUA_OK) {
                printf("[Tarefa #%d] Concluída\n", high->id);
                high->completed = true;
                scheduler->active_tasks--;
                lua_pop(high->coroutine, nres);
            }
        }

        // Executar tarefa low priority a cada 2 ciclos
        if (cycles % 2 == 0) {
            printf("\n--- Ciclo %d (Low Priority) ---\n", cycles);
            Task *low = scheduler->head->next;
            if (low && !low->completed) {
                printf("[Tarefa #%d '%s'] Executando...\n", low->id, low->name);
                int nres;
                int status = lua_resume(low->coroutine, L, 0, &nres);

                if (status == LUA_YIELD) {
                    printf("[Tarefa #%d] Suspensa\n", low->id);
                    lua_pop(low->coroutine, nres);
                } else if (status == LUA_OK) {
                    printf("[Tarefa #%d] Concluída\n", low->id);
                    low->completed = true;
                    scheduler->active_tasks--;
                    lua_pop(low->coroutine, nres);
                }
            }
        }
    }

    printf("\n[Scheduler] Sistema de prioridades concluído!\n");

    // ====== ESTATÍSTICAS FINAIS ======
    printf("\n");
    printf("╔══════════════════════════════════╗\n");
    printf("║     Estatísticas do Scheduler    ║\n");
    printf("╠══════════════════════════════════╣\n");
    printf("║ Total de ciclos: %15d ║\n", cycles);
    printf("║ Tarefas executadas: %12d ║\n", scheduler->next_id - 1);
    printf("╚══════════════════════════════════╝\n");

    // Limpeza
    scheduler_free(scheduler);
    lua_close(L);

    printf("\n=== Fim do Exemplo 3 ===\n");

    return 0;
}

/*
╔════════════════════════════════════════════════╗
║  Exemplo 3: Sistema de Tarefas com Corrotinas ║
╚════════════════════════════════════════════════╝

▶ Demonstração 1: Adicionar Tarefas
[Scheduler] Tarefa #1 'Contador' adicionada
[Scheduler] Tarefa #2 'Processador' adicionada
[Scheduler] Tarefa #3 'Calculadora' adicionada

--- Lista de Tarefas ---
  #1 'Contador' - ATIVA
  #2 'Processador' - ATIVA
  #3 'Calculadora' - ATIVA
Total: 3 tarefa(s), 3 ativa(s)

▶ Demonstração 2: Executar Round-Robin

=== Iniciando Execução de Todas as Tarefas ===

--- Ciclo de Execução ---
[Tarefa #1 'Contador'] Executando...
  [Task1] Iteração 1
[Tarefa #1 'Contador'] Suspensa (YIELD) - Retornou: step_1
[Tarefa #2 'Processador'] Executando...
  [Task2] Processamento pesado iniciado
[Tarefa #2 'Processador'] Suspensa (YIELD) - Retornou: processando...
[Tarefa #3 'Calculadora'] Executando...
  [Task3] Soma parcial: 3
[Tarefa #3 'Calculadora'] Suspensa (YIELD) - Retornou: parcial_3

[Scheduler] Fim do ciclo 1 - 3 tarefa(s) ativa(s)

--- Ciclo de Execução ---
[Tarefa #1 'Contador'] Executando...
  [Task1] Iteração 2
[Tarefa #1 'Contador'] Suspensa (YIELD) - Retornou: step_2
[Tarefa #2 'Processador'] Executando...
  [Task2] Continuando processamento
[Tarefa #2 'Processador'] Suspensa (YIELD) - Retornou: quase lá...
[Tarefa #3 'Calculadora'] Executando...
  [Task3] Soma parcial: 10
[Tarefa #3 'Calculadora'] Suspensa (YIELD) - Retornou: parcial_10

[Scheduler] Fim do ciclo 2 - 3 tarefa(s) ativa(s)

--- Ciclo de Execução ---
[Tarefa #1 'Contador'] Executando...
  [Task1] Iteração 3
[Tarefa #1 'Contador'] Suspensa (YIELD) - Retornou: step_3
[Tarefa #2 'Processador'] Executando...
  [Task2] Finalizando
[Tarefa #2 'Processador'] CONCLUÍDA - Resultado: Task2 completa
[Tarefa #3 'Calculadora'] Executando...
[Tarefa #3 'Calculadora'] CONCLUÍDA - Resultado: Task3: soma final = 15

[Scheduler] Fim do ciclo 3 - 1 tarefa(s) ativa(s)

--- Ciclo de Execução ---
[Tarefa #1 'Contador'] Executando...
[Tarefa #1 'Contador'] CONCLUÍDA - Resultado: Task1 finalizada com 3 iterações

=== Todas as Tarefas Concluídas ===

--- Lista de Tarefas ---
  #1 'Contador' - CONCLUÍDA
  #2 'Processador' - CONCLUÍDA
  #3 'Calculadora' - CONCLUÍDA
Total: 3 tarefa(s), 0 ativa(s)

▶ Demonstração 3: Adicionar Durante Execução
[Scheduler] Tarefa #1 'Task1' adicionada
[Scheduler] Tarefa #2 'Task2' adicionada

--- Ciclo de Execução ---
[Tarefa #1 'Task1'] Executando...
  [Task1] Iteração 1
[Tarefa #1 'Task1'] Suspensa (YIELD) - Retornou: step_1
[Tarefa #2 'Task2'] Executando...
  [Task2] Processamento pesado iniciado
[Tarefa #2 'Task2'] Suspensa (YIELD) - Retornou: processando...

[Main] Adicionando novas tarefas...
[Scheduler] Tarefa #3 'TaskDelayed' adicionada
[Scheduler] Tarefa #4 'TaskPriority' adicionada

--- Ciclo de Execução ---
[Tarefa #1 'Task1'] Executando...
  [Task1] Iteração 2
[Tarefa #1 'Task1'] Suspensa (YIELD) - Retornou: step_2
[Tarefa #2 'Task2'] Executando...
  [Task2] Continuando processamento
[Tarefa #2 'Task2'] Suspensa (YIELD) - Retornou: quase lá...
[Tarefa #3 'TaskDelayed'] Executando...
  [TaskDelayed] Iniciando
[Tarefa #3 'TaskDelayed'] Suspensa (YIELD) - Retornou: Iniciando
[Tarefa #4 'TaskPriority'] Executando...
  [TaskPriority] Executando tarefa prioritária!
[Tarefa #4 'TaskPriority'] Suspensa (YIELD) - Retornou: prioridade_alta

--- Ciclo de Execução ---
[Tarefa #1 'Task1'] Executando...
  [Task1] Iteração 3
[Tarefa #1 'Task1'] Suspensa (YIELD) - Retornou: step_3
[Tarefa #2 'Task2'] Executando...
  [Task2] Finalizando
[Tarefa #2 'Task2'] CONCLUÍDA - Resultado: Task2 completa
[Tarefa #3 'TaskDelayed'] Executando...
  [TaskDelayed] Meio
[Tarefa #3 'TaskDelayed'] Suspensa (YIELD) - Retornou: Meio
[Tarefa #4 'TaskPriority'] Executando...
  [TaskPriority] Continuação prioritária
[Tarefa #4 'TaskPriority'] CONCLUÍDA - Resultado: TaskPriority finalizada

--- Ciclo de Execução ---
[Tarefa #1 'Task1'] Executando...
[Tarefa #1 'Task1'] CONCLUÍDA - Resultado: Task1 finalizada com 3 iterações
[Tarefa #3 'TaskDelayed'] Executando...
  [TaskDelayed] Finalizando
[Tarefa #3 'TaskDelayed'] Suspensa (YIELD) - Retornou: Finalizando

--- Ciclo de Execução ---
[Tarefa #3 'TaskDelayed'] Executando...
[Tarefa #3 'TaskDelayed'] CONCLUÍDA - Resultado: TaskDelayed concluída

[Main] Execução completa!

--- Lista de Tarefas ---
  #1 'Task1' - CONCLUÍDA
  #2 'Task2' - CONCLUÍDA
  #3 'TaskDelayed' - CONCLUÍDA
  #4 'TaskPriority' - CONCLUÍDA
Total: 4 tarefa(s), 0 ativa(s)

▶ Demonstração 4: Tarefas Comunicantes
[Scheduler] Tarefas comunicantes criadas

--- Ciclo de Execução ---
[Tarefa #1 'Writer'] Executando...
  [Writer] Escreveu: 1
[Tarefa #1 'Writer'] Suspensa (YIELD)
[Tarefa #2 'Reader'] Executando...
  [Reader] Leu: 1
[Tarefa #2 'Reader'] Suspensa (YIELD)

--- Ciclo de Execução ---
[Tarefa #1 'Writer'] Executando...
  [Writer] Escreveu: 2
[Tarefa #1 'Writer'] Suspensa (YIELD)
[Tarefa #2 'Reader'] Executando...
  [Reader] Leu: 2
[Tarefa #2 'Reader'] Suspensa (YIELD)

--- Ciclo de Execução ---
[Tarefa #1 'Writer'] Executando...
  [Writer] Escreveu: 3
[Tarefa #1 'Writer'] Suspensa (YIELD)
[Tarefa #2 'Reader'] Executando...
  [Reader] Leu: 3
[Tarefa #2 'Reader'] Suspensa (YIELD)

--- Ciclo de Execução ---
[Tarefa #1 'Writer'] Executando...
[Tarefa #1 'Writer'] CONCLUÍDA - Resultado: Writer done
[Tarefa #2 'Reader'] Executando...
[Tarefa #2 'Reader'] CONCLUÍDA - Resultado: Reader done

[Main] Comunicação entre tarefas concluída!

▶ Demonstração 5: Callbacks C em Tarefas
[Scheduler] Tarefa #1 'CallbackTask' adicionada

=== Iniciando Execução de Todas as Tarefas ===

--- Ciclo de Execução ---
[Tarefa #1 'CallbackTask'] Executando...
  [C Callback] Mensagem da task: Iteração 1
  [TaskCallback] C respondeu: ACK from C
[Tarefa #1 'CallbackTask'] Suspensa (YIELD)

[Scheduler] Fim do ciclo 1 - 1 tarefa(s) ativa(s)

--- Ciclo de Execução ---
[Tarefa #1 'CallbackTask'] Executando...
  [C Callback] Mensagem da task: Iteração 2
  [TaskCallback] C respondeu: ACK from C
[Tarefa #1 'CallbackTask'] Suspensa (YIELD)

[Scheduler] Fim do ciclo 2 - 1 tarefa(s) ativa(s)

--- Ciclo de Execução ---
[Tarefa #1 'CallbackTask'] Executando...
[Tarefa #1 'CallbackTask'] CONCLUÍDA - Resultado: TaskCallback finalizada

=== Todas as Tarefas Concluídas ===

▶ Demonstração 6: Scheduler com Prioridades
[Scheduler] Tarefa #1 'HighPrio' adicionada
[Scheduler] Tarefa #2 'LowPrio' adicionada

[Scheduler] Executando com prioridades simuladas...

--- Ciclo 1 (High Priority) ---
[Tarefa #1 'HighPrio'] Executando (PRIORIDADE)...
  [HIGH] Tarefa prioritária executando
[Tarefa #1] Suspensa

--- Ciclo 2 (High Priority) ---
[Tarefa #1 'HighPrio'] Executando (PRIORIDADE)...
  [HIGH] Segunda execução prioritária
[Tarefa #1] Concluída

--- Ciclo 2 (Low Priority) ---
[Tarefa #2 'LowPrio'] Executando...
  [LOW] Tarefa baixa prioridade - passo 1
[Tarefa #2] Suspensa

--- Ciclo 3 (High Priority) ---

--- Ciclo 4 (High Priority) ---

--- Ciclo 4 (Low Priority) ---
[Tarefa #2 'LowPrio'] Executando...
  [LOW] Tarefa baixa prioridade - passo 2
[Tarefa #2] Suspensa

--- Ciclo 5 (High Priority) ---

--- Ciclo 6 (High Priority) ---

--- Ciclo 6 (Low Priority) ---
[Tarefa #2 'LowPrio'] Executando...
  [LOW] Tarefa baixa prioridade - passo 3
[Tarefa #2] Suspensa

--- Ciclo 7 (High Priority) ---

--- Ciclo 8 (High Priority) ---

--- Ciclo 8 (Low Priority) ---
[Tarefa #2 'LowPrio'] Executando...
[Tarefa #2] Concluída

[Scheduler] Sistema de prioridades concluído!

╔══════════════════════════════════╗
║     Estatísticas do Scheduler    ║
╠══════════════════════════════════╣
║ Total de ciclos:               8 ║
║ Tarefas executadas:            2 ║
╚══════════════════════════════════╝

=== Fim do Exemplo 3 ===
*/
```

Boas Práticas

-   Compile módulos com opções seguras (-Wall, -O2)
-   Regra de ouro: Toda função que empilha deve documentar quantos valores deixa na pilha
-   Valide argumentos: `luaL_checkstring()`, `luaL_checkinteger()` em vez de `lua_to...()`
-   Limpe após uso: `lua_pop()` ou `lua_settop(L, 0)` para evitar vazamentos
-   Sempre consulte a versão correta do Lua que está usando (5.1/5.2/5.3/5.4 têm diferenças)
-   Minimize chamadas C ↔ Lua: Cada travessia tem custo
