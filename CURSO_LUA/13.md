# Capítulo 13: Coroutines

Corrotinas em Lua são uma forma de multitarefa cooperativa. Elas permitem que funções cedam o controle umas às outras de forma controlada, sem a complexidade do multitarefa preemptiva.

Corrotinas são criadas com `coroutine.create()` e podem ser suspensas com `coroutine.yield()` e retomadas com `coroutine.resume()`.

`coroutine.status()` Retorna o estado da corrotina:

-   "**running**": A corrotina está atualmente em execução, o que significa que ela chamou a função status.
-   "**suspended**": A corrotina está suspensa. Isso ocorre se ela foi suspensa por uma chamada a yield ou se ainda não começou a executar.
-   "**normal**": A corrotina está ativa, mas não está executando no momento. Isso acontece quando ela retomou outra corrotina.
-   "**dead**": A corrotina terminou a execução de sua função principal ou parou devido a um erro.

Uso de coroutines para paralelismo.

## Exemplo 1: Corrotina Básica resume/yield:

```lua
-- Cria uma corrotina
local function produtor_corrotina()
    print("Corrotina: Iniciando...")
    coroutine.yield(1) -- Pausa e retorna 1
    print("Corrotina: Retomada e continuando...")
    coroutine.yield(2) -- Pausa e retorna 2
    print("Corrotina: Terminando.")
    return ">>Resultado da corrotina<<" -- Valor de retorno
end

local minha_corrotina = coroutine.create(produtor_corrotina)

print("Main: Resumindo corrotina...")

-- Resume a corrotina pela primeira vez
local status1, retorno1 = coroutine.resume(minha_corrotina)
print("Main 1: Corrotina retornou (ok: " .. tostring(status1) .. ", valor: " .. retorno1 .. ")")
-- Corrotina: Iniciando...
-- Main: Corrotina retornou (ok: true, valor: 1)

local status2, retorno2 = coroutine.resume(minha_corrotina)
print("Main 2: Corrotina retornou (ok: " .. tostring(status2) .. ", valor: " .. retorno2 .. ")")
-- Corrotina: Retomada e continuando...
-- Main 2: Corrotina retornou (ok: true, valor: 2)

local status3, resultado_final = coroutine.resume(minha_corrotina)
print("Main 3: Corrotina retornou (ok: " .. tostring(status3) .. ", valor: " .. resultado_final .. ")")
-- Corrotina: Terminando.
-- Main 3: Corrotina retornou (ok: true, valor: >>Resultado da corrotina<<)

-- Tentar resumir uma corrotina já terminada
local status4, erro = coroutine.resume(minha_corrotina)
print("Main 4: Corrotina retornou (ok: " .. tostring(status4) .. ", valor: " .. erro .. ")")
-- Main 4: Corrotina retornou (ok: false, valor: cannot resume dead coroutine)
```

`coroutine.wrap()` é uma função que cria e retorna um corrotina a partir de uma função, que retoma a corrotina cada vez que ela é chamada. Quaisquer argumentos extras passados para a função comportam-se como os argumentos extras para resume.

## Exemplo 2: Corrotina como Gerador

```lua
local function gerador_numeros()
    local n = 0
    while true do
        n = n + 1
        coroutine.yield(n) -- Produz o próximo número
    end
end

local gen = coroutine.wrap(gerador_numeros)

print(gen()) -- 1
print(gen()) -- 2
print(gen()) -- 3
```

## Exemplo 3: Pipes e Filtros

Corrotinas são ideais para implementar o padrão de "pipes and filters", onde dados fluem sequencialmente através de uma série de transformações.

```lua
-- Filtro 1: Gera números pares
local function gerador_pares(limite)
    return coroutine.wrap(function()
        for i = 0, limite, 2 do
            print("Gerador de pares:", i)
            coroutine.yield(i) -- Envia um número par
        end
    end
    )
end

-- Filtro 2: Dobra os números recebidos
local function dobrador(entrada)
    return coroutine.wrap(function()
        for num in entrada do -- Recebe números do iterador de entrada
            print("Dobrador:", num * 2)
            coroutine.yield(num * 2) -- Envia o dobro
        end
    end
    )
end

-- Filtro 3: Acumula a soma
local function somador(entrada)
    return coroutine.wrap(function()
        local total = 0

        for num in entrada do
            total = total + num
        end

        print("Somador:", total)
        coroutine.yield(total) -- Envia a soma final
    end
    )
end

-- Montando o pipeline
local limite_geracao = 10
local gerador = gerador_pares(limite_geracao)
local dobrando = dobrador(gerador)
local somando = somador(dobrando)

-- Executando o pipeline
print("Executando o pipeline:")
for resultado in somando do
  print("Resultado final:", resultado) -- Deve imprimir a soma dos números dobrados
end
-- Resultado final: 60
-- 0*2 + 2*2 + 4*2 + 6*2 + 8*2 + 10*2 = 0 + 4 + 8 + 12 + 16 + 20 = 60
```

## Exemplo 4: Comunicação Bidirecional com resume e yield:

```lua
local function comunicador()
    print("Comunicador: Esperando mensagem...")
    local msg1 = coroutine.yield("Olá, remetente!") -- Envia msg e espera a próxima
    print("Comunicador: " .. msg1 .. " (Recebida do remetente)")
    -- Comunicador: Comunicador como esta o dia? (Recebida do remetente)
    print("Comunicador: Enviando resposta...")
    local msg2 = coroutine.yield("Esta ótimo e o seu dia como esta indo?")
    print("Comunicador: " .. msg2 .. " (Recebida do remetente)")
    -- Comunicador: Esta tudo bem por aqui (Recebida do remetente)
    print("Comunicador: Terminando.")
    return "Comunicação finalizada."
end

local co_com = coroutine.create(comunicador)

local _, resp1 = coroutine.resume(co_com)
print("Remetente: " .. resp1 .. " (Recebida do comunicador)")
-- Remetente: Olá, remetente! (Recebida do comunicador)

local _, resp2 = coroutine.resume(co_com, "Comunicador como esta o dia?")
print("Remetente: " .. resp2 .. " (Recebida do comunicador)")
-- Remetente: Esta ótimo e o seu dia como esta indo? (Recebida do comunicador)

local _, resp3 = coroutine.resume(co_com, "Esta tudo bem por aqui")
print("Remetente: (Resultado final)", resp3) -- Remetente: (Resultado final) Comunicação finalizada.
```
