# Capítulo 6: Funções

As funções são o principal mecanismo de abstração de declarações e expressões em Lua.

Declaração de uma função `function nome(args) ... end`

## Exemplo 1: Função básica

```lua
local function soma(a, b)
    return a + b
end

print("Soma:", soma(10, 20))
```

## Exemplo 2: Função anônima

```lua
local quadrado = function(x)
    return x \* x
end

print("Quadrado de 5:", quadrado(5))
```

## Exemplo 3: Parâmetros padrão

```lua
local function exibe(nome, sobrenome)
    print("Nome:", nome or "Desconhecido", "Sobrenome:", sobrenome or "")
end

exibe("Lua") -- Sobrenome padrão ""
```

## Múltiplos Retornos

Lua permite que funções retornem múltiplos valores, o que é uma característica distintiva e poderosa da linguagem.

```lua
-- Função que retorna o mínimo e o máximo de dois números
function min_max(a, b)
    if a < b then
        return a, b -- Retorna 'a' como mínimo e 'b' como máximo
    else
        return b, a -- Retorna 'b' como mínimo e 'a' como máximo
    end
end

local minimo, maximo = min_max(5, 2)
print("Mínimo:", minimo, "Máximo:", maximo) -- Saída: Mínimo: 2 Máximo: 5

-- Exemplo com string.find que retorna múltiplos valores
local texto = "Lua é uma linguagem poderosa"
local inicio, fim = string.find(texto, "linguagem")

if inicio then
    print("Palavra encontrada entre os índices:", inicio, "e", fim) -- Saída: Palavra encontrada entre os índices: 11 e 19
end
```

## Argumentos Variádicos (...)

O operador `...` (chamado "varargs") permite que uma função aceite um número arbitrário de argumentos.

```lua
-- Função que soma todos os seus argumentos
function somar_todos(...)
local total = 0
local args = {...} -- Coleta todos os argumentos em uma tabela 'args'

    for _, valor in ipairs(args) do
        total = total + valor
    end

    return total
end

print("Soma (1, 2, 3):", somar_todos(1, 2, 3)) -- Saída: Soma (1, 2, 3): 6
print("Soma (10, 20, 30, 40):", somar_todos(10, 20, 30, 40)) -- Saída: Soma (10, 20, 30, 40): 100
print("Soma (sem argumentos):", somar_todos()) -- Saída: Soma (sem argumentos): 0
```

## Argumentos Nomeados (em alguns contextos)

Lua não suporta argumentos nomeados diretamente na sintaxe da função como em algumas outras linguagens. No entanto, a combinação de tabelas como argumentos e múltiplos retornos permite simular esse comportamento de forma elegante.

```lua
local rename = {old="temp.lua", new="temp1.lua"}

    function renameFn (arg)
      return print(arg.old, arg.new)
    end

renameFn(rename)

-- Função que aceita uma tabela de opções (simulando argumentos nomeados)
function configurar_janela(opcoes)
  local largura = opcoes.largura or 800 -- Usa valor padrão se não especificado
  local altura = opcoes.altura or 600
  local titulo = opcoes.titulo or "Janela Padrão"

  print("Configurando janela:")
  print("  Título:", titulo)
  print("  Largura:", largura)
  print("  Altura:", altura)
end

-- Chamada com argumentos nomeados simulados
configurar_janela({
  largura = 1024,
  titulo = "Meu Jogo",
  altura = 768
})

-- Chamada com apenas alguns argumentos
configurar_janela({ titulo = "Configurações" })
```

# Mais sobre Funções

Vamos aprofundar em conceitos mais avançados de funções, como closures e chamadas de cauda, que são essenciais para programação mais sofisticada.

## Closures

Uma closure é uma função que "lembra" do ambiente onde foi criada, mesmo que esse ambiente não exista mais. Isso permite que funções retenham estado. Isso é útil para criar funções que mantêm um estado ou comportamento específico.

```lua
-- Função que cria contadores
function criar_contador()
    local contador = 0 -- Variável local que será "lembrada"

    -- Retorna uma nova função (a closure)
    return function()
        contador = contador + 1
        return contador
    end
end

local contador1 = criar_contador() -- Cria uma funcao contador
local contador2 = criar_contador() -- Cria outro funcao contador

print(contador1()) -- Saída: 1
print(contador1()) -- Saída: 2
print(contador2()) -- Saída: 1 (contador2 tem seu próprio estado)
print(contador1()) -- Saída: 3
```

## Recursão

```lua
function fatorial(n)
    if n == 0 then
        return 1
    else
        return n * fatorial(n - 1)
    end
end

print("Fatorial de 5:", fatorial(5)) -- Output: Fatorial de 5: 120
```

## Funções Não Globais

Embora funções possam ser globais, é uma prática comum e recomendada mantê-las locais ou associadas a tabelas (como métodos de objetos).

```lua
-- Definindo uma função local
local function saudacao_local(nome)
    print("Olá localmente, " .. nome .. "!")
end

saudacao_local("Alice") -- Funciona perfeitamente

-- Funções como métodos de uma tabela
local Calculadora = {} -- Cria uma tabela para agrupar funções

function Calculadora.somar(a, b)
    return a + b
end

function Calculadora.subtrair(a, b)
    return a - b
end

print("2 + 3 =", Calculadora.somar(2, 3)) -- Saída: 2 + 3 = 5
print("10 - 7 =", Calculadora.subtrair(10, 7)) -- Saída: 10 - 7 = 3
```
