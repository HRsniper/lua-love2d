# Capítulo 19: Gerenciamento de Memória, Desempenho e Otimização

Como o coletor de lixo funciona (geracional, incremental). Ciclos de coleta.

`collectgarbage()`: Funções para controlar a coleta de lixo.

Opções:

-   **collect** (Padrão): Executa um ciclo completo de coleta de lixo. É a ação mais abrangente, garantindo que toda a memória não utilizada seja recuperada.
-   **stop**: Interrompe a execução automática do coletor de lixo. O coletor só será acionado quando você o invocar explicitamente. Para reativar o funcionamento automático, use - **restart**.
-   **restart**: Retoma a execução automática do coletor de lixo, que havia sido pausada com - **stop**.
-   **count**: Retorna a quantidade de memória em uso pelo Lua. Ele devolve dois valores:
    -   A memória total em uso em KiloBytes (com parte fracionária).
    -   A memória total em bytes, dividida por 1024 (o módulo 1024). A igualdade memória_em_kbytes = memória_em_bytes / 1024 é sempre verdadeira.
-   **step**: Realiza um passo da coleta de lixo. O tamanho desse passo pode ser influenciado pelo argumento arg (valores maiores indicam passos maiores), embora a maneira exata como arg afeta o passo não seja especificada. Se você precisa de um controle preciso sobre o tamanho do passo, a experimentação com arg é recomendada. Retorna true se o passo atual completou um ciclo de coleta.
-   **setpause**: Define o novo valor para a pausa do coletor de lixo (conforme descrito em §2.5 da documentação do Lua). A função retorna o valor anterior da pausa.
-   **setstepmul**: Define o novo valor para o multiplicador de passo do coletor de lixo (conforme descrito em §2.5 da documentação do Lua). A função retorna o valor anterior do multiplicador de passo.
-   **isrunning**: Retorna um valor booleano indicando se o coletor de lixo está em execução automática (ou seja, se não foi parado com - **stop**).
-   **generational**: Transfere o coletor de lixo para o modo generacional. Esta é uma funcionalidade experimental.
-   **incremental**: Muda o coletor para o modo incremental. Este é o modo de operação padrão do coletor em versões mais recentes do Lua.

`gcinfo()`: Obter informações sobre o coletor de lixo.

## Exemplo 1: Liberando Referências para Objeto Grandes

```lua
local dados_grandes = {}
-- Simulando a alocação de memória
for i = 1, 100000 do
    dados_grandes[i] = string.rep("X", 100) -- String de 100 'X'
end

print("Memória usada antes de liberar:", collectgarbage("count"))
-- Memória usada antes de liberar: 14278.653320312

-- Para liberar memória, removemos a referência
dados_grandes = nil

-- Forçar uma coleta de lixo para demonstrar a liberação
collectgarbage("collect")

print("Memória usada após liberar:", collectgarbage("count"))
-- Memória usada após liberar: 23.5439453125
```

## Exemplo 2: Monitorando a Coleta de Lixo

```lua
print("Informações do GC:", collectgarbage("count")) -- retorna a quantidade de memória usada pelo GC
-- Informações do GC: 23.2763671875

collectgarbage("collect") -- Força a coleta
print("Informações do GC após coleta:", collectgarbage("count"))
-- Informações do GC após coleta: 22.9921875
```

Técnicas de otimização: uso de tabelas, funções e loops.
Evitar operações caras.
Exemplos:

## Exemplo 3: Otimização de loops

Loops são pontos críticos em muitas aplicações. Pequenas otimizações aqui podem ter um grande impacto.

Calcule Fora do Loop: Se um valor é calculado repetidamente dentro de um loop e não muda a cada iteração, calcule-o antes do loop.

Evite Chamadas de Função Dentro de Loops: Se possível, mova chamadas de função para fora do loop.

Iteradores Eficientes: Em Lua 5.4, `ipairs` é geralmente mais eficiente para iterar sobre sequências numéricas contínuas. pairs é mais genérico e pode ser mais lento.

```lua
-- Exemplo: Movendo cálculo para fora do loop
local lista = {1, 2, 3, 4, 5}
local soma_total = 0
local tamanho_lista = #lista -- Calcula o tamanho uma vez

for i = 1, tamanho_lista do
    soma_total = soma_total + lista[i]
end
print(soma_total) -- 15
```

# Exemplo 4: A melhor maneira de identificar gargalos de desempenho é profiling

```lua
-- Função de exemplo que realiza um cálculo intensivo
local function calcular_fibonacci(n)
    if n <= 1 then
        return n
    else
        return calcular_fibonacci(n - 1) + calcular_fibonacci(n - 2)
    end
end

-- --- INÍCIO DO PROFILING ---
-- Habilita o profiling, especificando o que você quer coletar.
--[[
"c": Chama func toda vez que uma função é chamada.
"r": Chama func toda vez que uma função retorna.
"l": Chama func toda vez que uma nova linha de código é executada.
"u": Chama func para cada instrução de máquina.
]]
debug.sethook(function(event)
    -- Opcional: você pode adicionar lógica aqui para registrar eventos específicos
    -- se precisar de um controle mais granular. Para este exemplo, apenas habilitamos.
end, "crl")

local start_time = os.clock()

-- Chamando a função que queremos otimizar/analisar
local resultado = calcular_fibonacci(35) -- Um valor que leva algum tempo para calcular

local end_time = os.clock()
local elapsed_time = end_time - start_time

-- --- ANÁLISE DOS DADOS DE PROFILING ---
-- Você pode querer chamar debug.profile() *antes* de desabilitar o hook se quiser dados mais detalhados.
--[[
local profile_data = debug.profile("call") -- Exemplo de obtenção de dados de profiling de chamadas
print("\n--- Dados de Profiling (Exemplo Conceitual) ---")
if profile_data then
    for func_name, stats in pairs(profile_data) do
        print(string.format("Função: %s, Chamadas: %d, Tempo Total: %.4f", func_name, stats.count, stats.total_time))
    end
else
    print("Nenhum dado de profiling disponível.")
end
]]

-- --- FIM DO PROFILING ---
-- Desabilita o profiling
debug.sethook()

print("Resultado do Fibonacci(35):", resultado)
print("Tempo de execução (CPU):", elapsed_time, "segundos")
-- Resultado do Fibonacci(35):     9227465
-- Tempo de execução (CPU):        13.057349       segundos
```
