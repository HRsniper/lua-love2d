# Capítulo 15: Módulos

organizar o código em módulos reutilizáveis. Criação de módulos com funções e dados privados (clausura) e públicos.

## Exemplo 1: Criação de módulo `matematica.lua`

```lua
-- matematica.lua
local M = {} -- A tabela que será retornada

M.PI = 3.14159 -- global acessível

function M.somar(a, b)
    return a + b
end

function M.subtrair(a, b)
    return a - b
end

return M -- Retorna a tabela com as funções e valores públicos
--[[
M {
    PI
    somar (a, b)
    subtrair (a, b)
}
]]
```

## Exemplo 1.1: Configurando `package.path` (Exemplo):

O Lua adiciona `.` (diretório atual) a `package.path` por padrão. caso seu modulo está no mesmo diretório ou em um caminho conhecido.

```lua
--[[
Suponha que você tenha a seguinte estrutura de diretórios:
meu_projeto/
├── main_matematica.lua
└── libs/
    └── matematica.lua
]]

-- [[ main_matematica.lua ]]
-- Se o módulo 'matematica' estiver em um subdiretório 'lib'
package.path = package.path .. ";./lib/?.lua"
-- Agora você pode fazer: require("matematica") se matematica.lua estiver em um  diretório ./lib/
```

## Exemplo 2: Usando o módulo `matematica.lua` no Arquivo: `main_matematica.lua`

```lua
-- main_matematica.lua
local mat = require("matematica") -- Assume que matematica.lua está no package.path

print("Valor de PI:", mat.PI) -- Valor de PI: 3.14159
print("Soma:", mat.somar(10, 5)) -- Soma: 15
print("Subtração:", mat.subtrair(10, 5)) -- Subtração: 5
```

## Exemplo 3: Módulo com Dados Privados (Clausura):

```lua
-- contador.lua
local Contador = {}
local valor_privado = 0 -- Variável local, não exportada

function Contador.incrementar()
    valor_privado = valor_privado + 1
    print("Contador atual:", valor_privado)
end

function Contador.getValor()
    return valor_privado
end

return Contador
```

```lua
-- main_contador.lua
local c = require("contador")

c.incrementar() -- Contador atual: 1
c.incrementar() -- Contador atual: 2
print("Valor final:", c.getValor()) -- Valor final: 2
```
