# üß† Cap√≠tulo 6: Programa√ß√£o Orientada a Objetos com Lua

## üéØ Objetivo

Ensinar como estruturar o c√≥digo com objetos e classes simuladas usando metatables e bibliotecas externas, aplicando esses conceitos diretamente em jogos com L√ñVE2D.

## üß© 6.1 Por que usar orienta√ß√£o a objetos?

### Vantagens da POO em jogos:

-   **Organiza√ß√£o**: C√≥digo mais estruturado e f√°cil de entender
-   **Reutiliza√ß√£o**: Uma classe pode ser usada para criar m√∫ltiplos objetos
-   **Manuten√ß√£o**: Mudan√ßas em uma classe afetam todas as inst√¢ncias
-   **Encapsulamento**: Dados e comportamentos ficam juntos
-   **Heran√ßa**: Classes filhas podem especializar comportamentos da classe pai

### Exemplo pr√°tico:

```lua
-- ‚ùå Sem POO - c√≥digo repetitivo e dif√≠cil de manter
jogador1 = {x = 100, y = 100, vida = 100}
jogador2 = {x = 200, y = 200, vida = 100}

function atualizarJogador1(dt)
    -- c√≥digo espec√≠fico para jogador1
end

function atualizarJogador2(dt)
    -- c√≥digo quase id√™ntico para jogador2
end

-- ‚úÖ Com POO - c√≥digo reutiliz√°vel e organizado
jogador1 = Jogador:new(100, 100)
jogador2 = Jogador:new(200, 200)

-- Mesmo m√©todo funciona para ambos
jogador1:update(dt)
jogador2:update(dt)
```

## üîß 6.2 Simulando Classes com Metatables

### Conceitos Fundamentais

Em Lua, n√£o existem classes nativas, mas podemos simular esse comportamento usando **metatables**:

```lua
-- Definindo a "classe" Jogador
local Jogador = {}
Jogador.__index = Jogador  -- Permite herdar m√©todos

function Jogador:new(x, y, velocidade)
    local objeto = {
        x = x or 0,
        y = y or 0,
        velocidade = velocidade or 200,
        largura = 50,
        altura = 50,
        vida = 100,
        cor = {0, 1, 0}  -- verde
    }
    setmetatable(objeto, Jogador)
    return objeto
end

function Jogador:update(dt)
    -- Movimento com teclado
    if love.keyboard.isDown("up", "w") then
        self.y = self.y - self.velocidade * dt
    end
    if love.keyboard.isDown("down", "s") then
        self.y = self.y + self.velocidade * dt
    end
    if love.keyboard.isDown("left", "a") then
        self.x = self.x - self.velocidade * dt
    end
    if love.keyboard.isDown("right", "d") then
        self.x = self.x + self.velocidade * dt
    end

    -- Limitar √†s bordas da tela
    self.x = math.max(0, math.min(love.graphics.getWidth() - self.largura, self.x))
    self.y = math.max(0, math.min(love.graphics.getHeight() - self.altura, self.y))
end

function Jogador:draw()
    love.graphics.setColor(self.cor)
    love.graphics.rectangle("fill", self.x, self.y, self.largura, self.altura)

    -- Barra de vida
    love.graphics.setColor(1, 0, 0)  -- vermelho
    love.graphics.rectangle("fill", self.x, self.y - 10, self.largura, 5)
    love.graphics.setColor(0, 1, 0)  -- verde
    love.graphics.rectangle("fill", self.x, self.y - 10, self.largura * (self.vida / 100), 5)
end

function Jogador:receberDano(dano)
    self.vida = self.vida - dano
    if self.vida < 0 then
        self.vida = 0
    end
    return self.vida <= 0  -- retorna true se morreu
end

function Jogador:getPosicao()
    return self.x, self.y
end

return Jogador
```

### Uso no main.lua:

```lua
local Jogador = require("jogador")

function love.load()
    jogador = Jogador:new(100, 100, 250)
end

function love.update(dt)
    jogador:update(dt)
end

function love.draw()
    jogador:draw()

    -- Informa√ß√µes na tela
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Vida: " .. jogador.vida, 10, 10)
    local x, y = jogador:getPosicao()
    love.graphics.print("Posi√ß√£o: (" .. math.floor(x) .. ", " .. math.floor(y) .. ")", 10, 30)
end
```

### Criando M√∫ltiplas Inst√¢ncias:

```lua
local Inimigo = {}
Inimigo.__index = Inimigo

function Inimigo:new(x, y, tipo)
    local objeto = {
        x = x,
        y = y,
        largura = 30,
        altura = 30,
        velocidade = math.random(50, 150),
        vida = (tipo or 1) * 2,
        tipo = tipo or 1,
        direcao = math.random() * math.pi * 2  -- dire√ß√£o aleat√≥ria
    }

    -- Propriedades baseadas no tipo
    if objeto.tipo == 1 then
        objeto.cor = {1, 0, 0}      -- vermelho
    elseif objeto.tipo == 2 then
        objeto.cor = {1, 0.5, 0}    -- laranja
        objeto.velocidade = objeto.velocidade * 1.5
    else
        objeto.cor = {0.5, 0, 0.5}  -- roxo
        objeto.largura = 40
        objeto.altura = 40
        objeto.vida = objeto.vida * 2
    end

    setmetatable(objeto, Inimigo)
    return objeto
end

function Inimigo:update(dt)
    -- Movimento baseado no tipo
    if self.tipo == 1 then
        -- Movimento linear
        self.x = self.x + math.cos(self.direcao) * self.velocidade * dt
        self.y = self.y + math.sin(self.direcao) * self.velocidade * dt
    elseif self.tipo == 2 then
        -- Movimento em espiral
        self.direcao = self.direcao + dt
        self.x = self.x + math.cos(self.direcao) * self.velocidade * dt
        self.y = self.y + math.sin(self.direcao) * self.velocidade * dt
    else
        -- Movimento lento e direto
        self.y = self.y + self.velocidade * 0.5 * dt
    end
end

function Inimigo:draw()
    love.graphics.setColor(self.cor)
    love.graphics.rectangle("fill", self.x, self.y, self.largura, self.altura)

    -- Indicador de tipo
    love.graphics.setColor(1, 1, 1)
    love.graphics.print(self.tipo, self.x + 5, self.y + 5)
end

function Inimigo:estaForaDaTela()
    return self.x < -50 or self.x > love.graphics.getWidth() + 50 or
           self.y < -50 or self.y > love.graphics.getHeight() + 50
end

return Inimigo
```

## üì¶ 6.3 Usando middleclass (biblioteca OO)

### Instala√ß√£o

1. Baixe `middleclass.lua` do [reposit√≥rio oficial](https://github.com/kikito/middleclass) **([raw file](https://raw.githubusercontent.com/kikito/middleclass/refs/heads/master/middleclass.lua))**
2. Coloque o arquivo na pasta do seu projeto
3. Importe com `local Class = require("middleclass")`

### Exemplo com middleclass:

```lua
local Class = require("middleclass")

-- Definindo a classe Player
local Player = Class("Player")

function Player:initialize(x, y, velocidade)
    self.x = x or 100
    self.y = y or 100
    self.velocidade = velocidade or 200
    self.largura = 50
    self.altura = 50
    self.vida = 100
    self.maxVida = 100
    self.cor = {0, 1, 0}
    self.pontuacao = 0
end

function Player:update(dt)
    local dx, dy = 0, 0

    -- Capturar entrada
    if love.keyboard.isDown("up", "w") then dy = dy - 1 end
    if love.keyboard.isDown("down", "s") then dy = dy + 1 end
    if love.keyboard.isDown("left", "a") then dx = dx - 1 end
    if love.keyboard.isDown("right", "d") then dx = dx + 1 end

    -- Normalizar movimento diagonal
    if dx ~= 0 or dy ~= 0 then
        local length = math.sqrt(dx*dx + dy*dy)
        dx, dy = dx/length, dy/length

        self.x = self.x + dx * self.velocidade * dt
        self.y = self.y + dy * self.velocidade * dt
    end

    -- Limitar √†s bordas
    self.x = math.max(0, math.min(love.graphics.getWidth() - self.largura, self.x))
    self.y = math.max(0, math.min(love.graphics.getHeight() - self.altura, self.y))
end

function Player:draw()
    -- Corpo do jogador
    love.graphics.setColor(self.cor)
    love.graphics.rectangle("fill", self.x, self.y, self.largura, self.altura)

    -- Barra de vida
    local barraLargura = self.largura
    local barraAltura = 6
    local barraY = self.y - 12

    love.graphics.setColor(0.2, 0.2, 0.2)  -- fundo escuro
    love.graphics.rectangle("fill", self.x, barraY, barraLargura, barraAltura)

    love.graphics.setColor(1, 0, 0)  -- vermelho
    love.graphics.rectangle("fill", self.x, barraY, barraLargura, barraAltura)

    love.graphics.setColor(0, 1, 0)  -- verde
    local vidaPorcentagem = self.vida / self.maxVida
    love.graphics.rectangle("fill", self.x, barraY, barraLargura * vidaPorcentagem, barraAltura)
end

function Player:receberDano(quantidade)
    self.vida = math.max(0, self.vida - quantidade)

    -- Efeito visual de dano (piscar vermelho)
    self.cor = {1, 0.3, 0.3}
    love.timer.setTimeout(0.1, function()
        self.cor = {0, 1, 0}
    end)

    return self.vida <= 0
end

function Player:curar(quantidade)
    self.vida = math.min(self.maxVida, self.vida + quantidade)
end

function Player:adicionarPontos(pontos)
    self.pontuacao = self.pontuacao + pontos
end

function Player:getCenter()
    return self.x + self.largura/2, self.y + self.altura/2
end

return Player
```

## üß† 6.4 Heran√ßa com middleclass

### Classe Base: Entidade

```lua
local Class = require("middleclass")

local Entidade = Class("Entidade")

function Entidade:initialize(x, y, largura, altura)
    self.x = x or 0
    self.y = y or 0
    self.largura = largura or 20
    self.altura = altura or 20
    self.velocidadeX = 0
    self.velocidadeY = 0
    self.ativo = true
    self.cor = {1, 1, 1}
end

function Entidade:update(dt)
    if not self.ativo then return end

    self.x = self.x + self.velocidadeX * dt
    self.y = self.y + self.velocidadeY * dt
end

function Entidade:draw()
    if not self.ativo then return end

    love.graphics.setColor(self.cor)
    love.graphics.rectangle("fill", self.x, self.y, self.largura, self.altura)
end

function Entidade:colideCom(outra)
    if not self.ativo or not outra.ativo then return false end

    return self.x < outra.x + outra.largura and
           outra.x < self.x + self.largura and
           self.y < outra.y + outra.altura and
           outra.y < self.y + self.altura
end

function Entidade:getCenter()
    return self.x + self.largura/2, self.y + self.altura/2
end

function Entidade:destruir()
    self.ativo = false
end

return Entidade
```

### Classe Filha: Proj√©til

```lua
local Class = require("middleclass")
local Entidade = require("entidade")

local Projetil = Class("Projetil", Entidade)

function Projetil:initialize(x, y, direcaoX, direcaoY, velocidade)
    Entidade.initialize(self, x, y, 6, 10)

    self.velocidadeX = direcaoX * velocidade
    self.velocidadeY = direcaoY * velocidade
    self.cor = {1, 1, 0}  -- amarelo
    self.dano = 10
    self.tempoVida = 3  -- segundos
    self.idade = 0
end

function Projetil:update(dt)
    Entidade.update(self, dt)

    self.idade = self.idade + dt

    -- Destruir se muito antigo ou fora da tela
    if self.idade > self.tempoVida or self:foradaTela() then
        self:destruir()
    end
end

function Projetil:foradaTela()
    return self.x < -10 or self.x > love.graphics.getWidth() + 10 or
           self.y < -10 or self.y > love.graphics.getHeight() + 10
end

return Projetil
```

### Classe Filha: Inimigo

```lua
local Class = require("middleclass")
local Entidade = require("entidade")

local Inimigo = Class("Inimigo", Entidade)

function Inimigo:initialize(x, y, tipo)
    Entidade.initialize(self, x, y, 30, 30)

    self.tipo = tipo or 1
    self.vida = self.tipo * 20
    self.maxVida = self.vida
    self.velocidade = math.random(50, 120)
    self.pontos = self.tipo * 10

    -- Propriedades espec√≠ficas por tipo
    if self.tipo == 1 then
        self.cor = {1, 0, 0}        -- vermelho - b√°sico
        self.comportamento = "linear"
    elseif self.tipo == 2 then
        self.cor = {1, 0.5, 0}      -- laranja - r√°pido
        self.velocidade = self.velocidade * 1.5
        self.comportamento = "zigzag"
    else
        self.cor = {0.8, 0, 0.8}    -- roxo - tanque
        self.largura, self.altura = 40, 40
        self.vida = self.vida * 2
        self.maxVida = self.vida
        self.comportamento = "perseguir"
    end

    self.tempoMovimento = math.random() * 10  -- para varia√ß√£o
end

function Inimigo:update(dt, jogadorX, jogadorY)
    if not self.ativo then return end

    self.tempoMovimento = self.tempoMovimento + dt

    -- Comportamento baseado no tipo
    if self.comportamento == "linear" then
        self.velocidadeY = self.velocidade
    elseif self.comportamento == "zigzag" then
        self.velocidadeX = math.sin(self.tempoMovimento * 3) * self.velocidade * 0.5
        self.velocidadeY = self.velocidade * 0.7
    elseif self.comportamento == "perseguir" and jogadorX and jogadorY then
        local dx = jogadorX - self.x
        local dy = jogadorY - self.y
        local distancia = math.sqrt(dx*dx + dy*dy)

        if distancia > 0 then
            self.velocidadeX = (dx/distancia) * self.velocidade * 0.5
            self.velocidadeY = (dy/distancia) * self.velocidade * 0.5
        end
    end

    Entidade.update(self, dt)

    -- Destruir se saiu da tela
    if self.y > love.graphics.getHeight() + 50 then
        self:destruir()
    end
end

function Inimigo:draw()
    if not self.ativo then return end

    Entidade.draw(self)

    -- Barra de vida para tipos mais fortes
    if self.tipo > 1 then
        local barraY = self.y - 8
        local vidaPorcentagem = self.vida / self.maxVida

        love.graphics.setColor(0.2, 0.2, 0.2)
        love.graphics.rectangle("fill", self.x, barraY, self.largura, 4)

        love.graphics.setColor(1, 0, 0)
        love.graphics.rectangle("fill", self.x, barraY, self.largura * vidaPorcentagem, 4)
    end

    -- Indicador de tipo
    love.graphics.setColor(1, 1, 1)
    love.graphics.print(self.tipo, self.x + 2, self.y + 2)
end

function Inimigo:receberDano(quantidade)
    self.vida = self.vida - quantidade

    -- Efeito visual de dano
    local corOriginal = self.cor
    self.cor = {1, 1, 1}  -- branco
    love.timer.setTimeout(0.1, function()
        if self.ativo then
            self.cor = corOriginal
        end
    end)

    if self.vida <= 0 then
        self:destruir()
        return true, self.pontos
    end

    return false, 0
end

return Inimigo
```

## üß© 6.5 Desafio Guiado: Sistema Completo OOP

Vamos integrar tudo em um jogo completo usando orienta√ß√£o a objetos:

```lua
-- main.lua
local Class = require("middleclass")
local Player = require("player")
local Inimigo = require("inimigo")
local Projetil = require("projetil")

local Game = Class("Game")

function Game:initialize()
    self.player = Player:new(400, 500)
    self.inimigos = {}
    self.projeteis = {}

    self.tempoSpawn = 0
    self.intervaloSpawn = 1.5
    self.pontuacao = 0
    self.wave = 1
    self.inimigosPorWave = 5
    self.inimigosSpawnados = 0

    self.estado = "jogando"  -- "jogando", "pausado", "gameover"
end

function Game:update(dt)
    if self.estado ~= "jogando" then return end

    -- Atualizar player
    self.player:update(dt)

    -- Sistema de spawn
    self.tempoSpawn = self.tempoSpawn + dt
    if self.tempoSpawn >= self.intervaloSpawn and self.inimigosSpawnados < self.inimigosPorWave then
        self:spawnInimigo()
        self.tempoSpawn = 0
        self.inimigosSpawnados = self.inimigosSpawnados + 1
    end

    -- Atualizar inimigos
    local jogadorX, jogadorY = self.player:getCenter()
    for i = #self.inimigos, 1, -1 do
        local inimigo = self.inimigos[i]
        inimigo:update(dt, jogadorX, jogadorY)

        if not inimigo.ativo then
            table.remove(self.inimigos, i)
        elseif inimigo:colideCom(self.player) then
            if self.player:receberDano(20) then
                self.estado = "gameover"
            end
            inimigo:destruir()
            table.remove(self.inimigos, i)
        end
    end

    -- Atualizar proj√©teis
    for i = #self.projeteis, 1, -1 do
        local projetil = self.projeteis[i]
        projetil:update(dt)

        if not projetil.ativo then
            table.remove(self.projeteis, i)
        else
            -- Verificar colis√£o com inimigos
            for j = #self.inimigos, 1, -1 do
                local inimigo = self.inimigos[j]
                if projetil:colideCom(inimigo) then
                    local morreu, pontos = inimigo:receberDano(projetil.dano)

                    if morreu then
                        self.pontuacao = self.pontuacao + pontos
                        table.remove(self.inimigos, j)
                    end

                    projetil:destruir()
                    table.remove(self.projeteis, i)
                    break
                end
            end
        end
    end

    -- Verificar pr√≥xima wave
    if #self.inimigos == 0 and self.inimigosSpawnados >= self.inimigosPorWave then
        self:proximaWave()
    end
end

function Game:draw()
    if self.estado == "gameover" then
        love.graphics.setColor(1, 0, 0)
        love.graphics.print("GAME OVER", 300, 250, 0, 2, 2)
        love.graphics.setColor(1, 1, 1)
        love.graphics.print("Pontua√ß√£o Final: " .. self.pontuacao, 280, 300)
        love.graphics.print("Wave Alcan√ßada: " .. self.wave, 300, 320)
        return
    end

    -- Desenhar todos os objetos
    self.player:draw()

    for _, inimigo in ipairs(self.inimigos) do
        inimigo:draw()
    end

    for _, projetil in ipairs(self.projeteis) do
        projetil:draw()
    end

    -- Interface
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Vida: " .. self.player.vida, 10, 10)
    love.graphics.print("Pontua√ß√£o: " .. self.pontuacao, 10, 30)
    love.graphics.print("Wave: " .. self.wave, 10, 50)
    love.graphics.print("Inimigos: " .. #self.inimigos, 10, 70)
end

function Game:spawnInimigo()
    local x = math.random(0, love.graphics.getWidth() - 40)
    local tipo = math.random(1, math.min(3, self.wave))
    table.insert(self.inimigos, Inimigo:new(x, -50, tipo))
end

function Game:atirar()
    if self.estado ~= "jogando" then return end

    local playerX, playerY = self.player:getCenter()
    table.insert(self.projeteis, Projetil:new(playerX, playerY, 0, -1, 400))
end

function Game:proximaWave()
    self.wave = self.wave + 1
    self.inimigosPorWave = self.inimigosPorWave + 2
    self.inimigosSpawnados = 0
    self.intervaloSpawn = math.max(0.3, self.intervaloSpawn - 0.1)

    -- Curar player um pouco
    self.player:curar(25)
end

-- Inst√¢ncia global do jogo
local jogo

function love.load()
    jogo = Game:new()
end

function love.update(dt)
    jogo:update(dt)
end

function love.draw()
    jogo:draw()
end

function love.keypressed(key)
    if key == "space" then
        jogo:atirar()
    elseif key == "r" and jogo.estado == "gameover" then
        jogo = Game:new()  -- reiniciar
    end
end
```

## ‚úÖ Conclus√£o do Cap√≠tulo

Voc√™ aprendeu:

-   Como simular orienta√ß√£o a objetos em Lua usando metatables
-   Como usar a biblioteca middleclass para facilitar a cria√ß√£o de classes
-   Como implementar heran√ßa para reutilizar c√≥digo entre classes similares
-   Como aplicar POO em jogos para criar sistemas mais organizados e escal√°veis
-   Como integrar m√∫ltiplas classes em um jogo completo e funcional

## üí° Conceitos Importantes

-   **Metatables**: Mecanismo do Lua para simular orienta√ß√£o a objetos
-   **Heran√ßa**: Permite que classes filhas especializem comportamentos da classe pai
-   **Encapsulamento**: Manter dados e m√©todos relacionados juntos na mesma classe
-   **Polimorfismo**: Diferentes classes podem implementar os mesmos m√©todos de formas espec√≠ficas
-   **Organiza√ß√£o**: POO ajuda a estruturar projetos complexos de forma mais clara
