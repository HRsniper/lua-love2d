# 🧠 Capítulo 12: Técnicas Avançadas

## 🎯 Objetivo

Apresentar funcionalidades avançadas do LÖVE2D que permitem criar jogos mais complexos e eficientes, incluindo física com `love.physics`, câmeras com `love.graphics.translate`, canvases para efeitos visuais e threads para processamento paralelo.

## ⚙️ 12.1 Física com `love.physics`

LÖVE2D possui integração com Box2D, um motor de física 2D robusto usado em muitos jogos comerciais.

### Conceitos Básicos:

-   **World**: O mundo físico onde tudo acontece
-   **Body**: Representa um objeto no mundo físico
-   **Shape**: Define a forma geométrica do objeto
-   **Fixture**: Conecta um corpo a uma forma e define propriedades físicas

### Corpo Dinâmico com Gravidade

```lua
function love.load()
    -- Cria um mundo físico com gravidade (x=0, y=500)
    mundo = love.physics.newWorld(0, 500, true)

    -- Cria uma caixa dinâmica
    corpo = love.physics.newBody(mundo, 400, 100, "dynamic")
    forma = love.physics.newRectangleShape(50, 50)
    fixture = love.physics.newFixture(corpo, forma)
end

function love.update(dt)
    mundo:update(dt)
end

function love.draw()
    love.graphics.rectangle("line", corpo:getX(), corpo:getY(), 50, 50)
end
```

### Corpo Dinâmico com Gravidade e chão estático

```lua
function love.load()
    -- Cria um mundo físico com gravidade (x=0, y=500)
    mundo = love.physics.newWorld(0, 500, true)

    -- Cria uma caixa dinâmica
    caixaCorpo = love.physics.newBody(mundo, 400, 100, "dynamic")
    caixaForma = love.physics.newRectangleShape(50, 50)
    caixaFixture = love.physics.newFixture(caixaCorpo, caixaForma)
    caixaFixture:setRestitution(0.8) -- Elasticidade (quique)

    -- Cria o chão estático
    chaoCorpo = love.physics.newBody(mundo, 400, 550, "static")
    chaoForma = love.physics.newRectangleShape(800, 50)
    chaoFixture = love.physics.newFixture(chaoCorpo, chaoForma)
end

function love.update(dt)
    mundo:update(dt)
end

function love.draw()
    -- Desenha a caixa
    love.graphics.push()
    love.graphics.translate(caixaCorpo:getX(), caixaCorpo:getY())
    love.graphics.rotate(caixaCorpo:getAngle())
    love.graphics.setColor(1, 0.5, 0.5)
    love.graphics.rectangle("fill", -25, -25, 50, 50)
    love.graphics.pop()

    -- Desenha o chão
    love.graphics.setColor(0.5, 0.5, 0.5)
    love.graphics.rectangle("fill",
        chaoCorpo:getX() - 400, chaoCorpo:getY() - 25,
        800, 50
    )

    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Pressione o mouse para aplicar impulso", 0, 0)
end

function love.mousepressed(x, y, button)
    if button == 1 then
        -- Aplica impulso na direção do mouse
        local impulseX = (x - caixaCorpo:getX()) * 10
        local impulseY = (y - caixaCorpo:getY()) * 10
        caixaCorpo:applyLinearImpulse(impulseX, impulseY)
    end
end
```

### Sistema de Física Mais Completo:

```lua
local fisica = {}

function fisica.load()
    fisica.mundo = love.physics.newWorld(0, 800, true)
    fisica.objetos = {}

    -- Chão
    fisica.criarChao(400, 550, 800, 50)

    -- Plataformas
    fisica.criarPlataforma(200, 400, 150, 20)
    fisica.criarPlataforma(600, 300, 150, 20)
end

function fisica.criarCaixa(x, y, largura, altura)
    local obj = {}
    obj.corpo = love.physics.newBody(fisica.mundo, x, y, "dynamic")
    obj.forma = love.physics.newRectangleShape(largura, altura)
    obj.fixture = love.physics.newFixture(obj.corpo, obj.forma)
    obj.fixture:setRestitution(0.3)
    obj.fixture:setFriction(0.7)
    obj.largura = largura
    obj.altura = altura
    obj.tipo = "caixa"

    table.insert(fisica.objetos, obj)
    return obj
end

function fisica.criarBola(x, y, raio)
    local obj = {}
    obj.corpo = love.physics.newBody(fisica.mundo, x, y, "dynamic")
    obj.forma = love.physics.newCircleShape(raio)
    obj.fixture = love.physics.newFixture(obj.corpo, obj.forma)
    obj.fixture:setRestitution(0.8)
    obj.raio = raio
    obj.tipo = "bola"

    table.insert(fisica.objetos, obj)
    return obj
end

function fisica.criarChao(x, y, largura, altura)
    local obj = {}
    obj.corpo = love.physics.newBody(fisica.mundo, x, y, "static")
    obj.forma = love.physics.newRectangleShape(largura, altura)
    obj.fixture = love.physics.newFixture(obj.corpo, obj.forma)
    obj.largura = largura
    obj.altura = altura
    obj.tipo = "chao"

    table.insert(fisica.objetos, obj)
    return obj
end

function fisica.criarPlataforma(x, y, largura, altura)
    return fisica.criarChao(x, y, largura, altura)
end

function fisica.update(dt)
    fisica.mundo:update(dt)
end

function fisica.draw()
    for _, obj in ipairs(fisica.objetos) do
        love.graphics.push()
        love.graphics.translate(obj.corpo:getX(), obj.corpo:getY())
        love.graphics.rotate(obj.corpo:getAngle())

        if obj.tipo == "caixa" or obj.tipo == "chao" then
            love.graphics.setColor(0.8, 0.8, 0.8)
            if obj.tipo == "caixa" then
                love.graphics.setColor(1, 0.6, 0.6)
            end
            love.graphics.rectangle("fill",
                -obj.largura / 2, -obj.altura / 2,
                obj.largura, obj.altura
            )
        elseif obj.tipo == "bola" then
            love.graphics.setColor(0.6, 0.6, 1)
            love.graphics.circle("fill", 0, 0, obj.raio)
        end

        love.graphics.pop()
    end
    love.graphics.setColor(1, 1, 1)
end

-- Uso do sistema
function love.load()
    fisica.load()
end

function love.update(dt)
    fisica.update(dt)
end

function love.draw()
    fisica.draw()

    love.graphics.print("Clique para criar caixa, Espaço para bola", 10, 10)
end

function love.mousepressed(x, y, button)
    if button == 1 then
        fisica.criarCaixa(x, y, 40, 40)
    end
end

function love.keypressed(key)
    if key == "space" then
        local x = love.math.random(100, 700)
        fisica.criarBola(x, 50, 20)
    end
end
```

## 🎥 12.2 Câmeras com `love.graphics.translate`

Sistema de câmera permite controlar a visualização do mundo do jogo, essencial para jogos com mapas grandes.

### Câmera Básica:

```lua
local camera = {
    x = 0,
    y = 0,
    scale = 1,
    rotation = 0
}

function camera:apply()
    love.graphics.push()
    love.graphics.rotate(-self.rotation)
    love.graphics.scale(1 / self.scale, 1 / self.scale)
    love.graphics.translate(-self.x, -self.y)
end

function camera:clear()
    love.graphics.pop()
end

function camera:move(dx, dy)
    self.x = self.x + dx
    self.y = self.y + dy
end

function camera:lookAt(x, y)
    self.x = x - love.graphics.getWidth() / 2
    self.y = y - love.graphics.getHeight() / 2
end

function camera:zoom(factor)
    self.scale = self.scale * factor
end

-- Exemplo de uso seguindo o jogador
local jogador = { x = 400, y = 300, speed = 200 }

function love.update(dt)
    -- Movimento do jogador
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - jogador.speed * dt
    elseif love.keyboard.isDown("right") then
        jogador.x = jogador.x + jogador.speed * dt
    end

    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - jogador.speed * dt
    elseif love.keyboard.isDown("down") then
        jogador.y = jogador.y + jogador.speed * dt
    end

    -- Câmera segue o jogador suavemente
    local targetX = jogador.x - love.graphics.getWidth() / 2
    local targetY = jogador.y - love.graphics.getHeight() / 2

    camera.x = camera.x + (targetX - camera.x) * dt * 2
    camera.y = camera.y + (targetY - camera.y) * dt * 2
end

function love.draw()
    camera:apply()

    -- Desenha o mundo
    love.graphics.setColor(0.3, 0.7, 0.3)
    for i = -10, 10 do
        for j = -10, 10 do
            love.graphics.rectangle("line", i * 100, j * 100, 100, 100)
        end
    end

    -- Desenha o jogador
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", jogador.x - 16, jogador.y - 16, 32, 32)

    camera:clear()

    -- UI (não afetada pela câmera)
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Use as setas para mover", 10, 10)
    love.graphics.print(string.format("Posição: %.1f, %.1f", jogador.x, jogador.y), 10, 25)
end
```

### Sistema de Câmera Avançado com Limites:

```lua
-- camera.lua
local Camera = {}
Camera.__index = Camera

function Camera:new(x, y)
    local cam = {
        x = x or 0,
        y = y or 0,
        scaleX = 1,
        scaleY = 1,
        rotation = 0,
        -- Limites do mundo
        bounds = {
            minX = nil,
            maxX = nil,
            minY = nil,
            maxY = nil
        },
        -- Zona morta (área onde o jogador pode se mover sem mover a câmera)
        deadzone = {
            x = 50,
            y = 50,
            width = 100,
            height = 100
        }
    }
    setmetatable(cam, Camera)
    return cam
end

function Camera:setBounds(minX, minY, maxX, maxY)
    self.bounds.minX = minX
    self.bounds.minY = minY
    self.bounds.maxX = maxX
    self.bounds.maxY = maxY
end

function Camera:follow(target, dt)
    local lerpSpeed = dt * 3

    -- Calcula posição alvo da câmera
    local targetX = target.x - love.graphics.getWidth() / 2
    local targetY = target.y - love.graphics.getHeight() / 2

    -- Sistema de deadzone
    local screenW, screenH = love.graphics.getDimensions()
    local centerX = self.x + screenW / 2
    local centerY = self.y + screenH / 2

    local dx = target.x - centerX
    local dy = target.y - centerY

    if math.abs(dx) > self.deadzone.width / 2 then
        targetX = self.x + (dx - self.deadzone.width / 2 * (dx > 0 and 1 or -1))
    else
        targetX = self.x
    end

    if math.abs(dy) > self.deadzone.height / 2 then
        targetY = self.y + (dy - self.deadzone.height / 2 * (dy > 0 and 1 or -1))
    else
        targetY = self.y
    end

    -- Interpola suavemente
    self.x = self.x + (targetX - self.x) * lerpSpeed
    self.y = self.y + (targetY - self.y) * lerpSpeed

    -- Aplica limites
    if self.bounds.minX and self.bounds.maxX then
        self.x = math.max(self.bounds.minX,
            math.min(self.x, self.bounds.maxX - screenW))
    end

    if self.bounds.minY and self.bounds.maxY then
        self.y = math.max(self.bounds.minY,
            math.min(self.y, self.bounds.maxY - screenH))
    end
end

function Camera:apply()
    love.graphics.push()
    love.graphics.rotate(-self.rotation)
    love.graphics.scale(1 / self.scaleX, 1 / self.scaleY)
    love.graphics.translate(-self.x, -self.y)
end

function Camera:clear()
    love.graphics.pop()
end

function Camera:worldToScreen(x, y)
    return (x - self.x) / self.scaleX, (y - self.y) / self.scaleY
end

function Camera:screenToWorld(x, y)
    return x * self.scaleX + self.x, y * self.scaleY + self.y
end

return Camera
```

```lua
-- main.lua
local Camera = require("camera")

local camera
local jogador

function love.load()
    camera = Camera:new()
    camera:setBounds(-1000, -1000, 1000, 1000) -- exemplo de limites do mundo

    -- Exemplo de uso seguindo o jogador
    jogador = { x = 400, y = 300, speed = 200 }
end

function love.update(dt)
    -- Movimento do jogador
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - jogador.speed * dt
    elseif love.keyboard.isDown("right") then
        jogador.x = jogador.x + jogador.speed * dt
    end

    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - jogador.speed * dt
    elseif love.keyboard.isDown("down") then
        jogador.y = jogador.y + jogador.speed * dt
    end

    camera:follow(jogador, dt)
end

function love.draw()
    camera:apply()

    -- Desenha o mundo
    love.graphics.setColor(0.3, 0.7, 0.3)
    for i = -10, 10 do
        for j = -10, 10 do
            love.graphics.rectangle("line", i * 100, j * 100, 100, 100)
        end
    end

    -- Desenha o jogador
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", jogador.x - 16, jogador.y - 16, 32, 32)

    camera:clear()

    -- UI (não afetada pela câmera)
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Use as setas para mover", 10, 10)
    love.graphics.print(string.format("Posição: %.1f, %.1f", jogador.x, jogador.y), 10, 25)
end
```

## 🖼️ 12.3 Canvases para Efeitos Visuais

Canvases são superfícies de desenho separadas que permitem criar efeitos complexos, pós-processamento e otimizações.

### Canvas Básico:

```lua
function love.load()
    canvas = love.graphics.newCanvas(800, 600)

    -- Desenha algo no canvas
    love.graphics.setCanvas(canvas)
    love.graphics.clear(0, 0, 0, 0) -- Transparente

    love.graphics.setColor(1, 1, 0)
    love.graphics.circle("fill", 200, 200, 100)

    love.graphics.setColor(0, 1, 1)
    love.graphics.rectangle("fill", 400, 300, 100, 100)

    love.graphics.setCanvas() -- Volta ao canvas principal
end

function love.draw()
    -- Desenha o canvas com transparência
    love.graphics.setColor(1, 1, 1, 0.8)
    love.graphics.draw(canvas, 0, 0)

    -- Desenha elementos normais por cima passando com o mouse
    love.graphics.setColor(1, 0, 0)
    love.graphics.circle("fill", love.mouse.getX(), love.mouse.getY(), 20)

    love.graphics.setColor(1, 1, 1)
end
```

### Sistema de Iluminação com Canvas:

```lua
-- lighting.lua
local lighting = {}

function lighting.load()
    lighting.lightCanvas = love.graphics.newCanvas()
    lighting.shadowCanvas = love.graphics.newCanvas()
    lighting.lights = {}
    lighting.obstacles = {}

    -- Adiciona algumas luzes
    lighting.addLight(400, 300, 200, { 1, 1, 0.8 })
    lighting.addLight(100, 100, 150, { 0.8, 0.8, 1 })

    -- Adiciona obstáculos
    lighting.addObstacle(300, 250, 100, 20)
    lighting.addObstacle(500, 400, 80, 80)
end

function lighting.addLight(x, y, radius, color)
    table.insert(lighting.lights, {
        x = x,
        y = y,
        radius = radius,
        color = color or { 1, 1, 1 }
    })
end

function lighting.addObstacle(x, y, width, height)
    table.insert(lighting.obstacles, {
        x = x,
        y = y,
        width = width,
        height = height
    })
end

function lighting.draw()
    -- Desenha as sombras no canvas de sombras
    love.graphics.setCanvas(lighting.shadowCanvas)
    love.graphics.clear(0, 0, 0, 1) -- Preto opaco

    -- Remove áreas iluminadas (desenha em branco)
    love.graphics.setBlendMode("subtract")
    love.graphics.setColor(1, 1, 1)

    for _, light in ipairs(lighting.lights) do
        love.graphics.circle("fill", light.x, light.y, light.radius)
    end

    love.graphics.setBlendMode("alpha")
    love.graphics.setCanvas()

    -- Desenha o mundo normal
    love.graphics.setColor(0.7, 0.7, 0.7)
    for _, obs in ipairs(lighting.obstacles) do
        love.graphics.rectangle("fill", obs.x, obs.y, obs.width, obs.height)
    end

    -- Aplica as sombras
    love.graphics.setColor(1, 1, 1, 0.8)
    love.graphics.draw(lighting.shadowCanvas, 0, 0)

    -- Desenha as luzes como pontos brilhantes
    love.graphics.setBlendMode("add")
    for _, light in ipairs(lighting.lights) do
        love.graphics.setColor(light.color[1], light.color[2], light.color[3], 0.3)
        love.graphics.circle("fill", light.x, light.y, 30)
    end
    love.graphics.setBlendMode("alpha")

    love.graphics.setColor(1, 1, 1)
end

function lighting.update(dt)
    -- Move a primeira luz com o mouse
    if #lighting.lights > 0 then
        lighting.lights[1].x = love.mouse.getX()
        lighting.lights[1].y = love.mouse.getY()
    end
end

return lighting
```

```lua
-- main.lua
local lighting = require("lighting")

function love.load()
    lighting.load()
end

function love.update(dt)
    lighting.update(dt)
end

function love.draw()
    lighting.draw()
end
```

### Canvas para Efeito de Desfoque:

```lua
-- blur.lua
local blur = {}

function blur.load()
    blur.canvas1 = love.graphics.newCanvas()
    blur.canvas2 = love.graphics.newCanvas()
    blur.shader = love.graphics.newShader([[
        extern number blur_size;

        vec4 effect(vec4 color, Image texture, vec2 texture_coords, vec2 screen_coords) {
            vec4 sum = vec4(0.0);
            int samples = 5;

            for(int i = -samples; i <= samples; i++) {
                for(int j = -samples; j <= samples; j++) {
                    vec2 offset = vec2(i, j) * blur_size;
                    sum += Texel(texture, texture_coords + offset);
                }
            }

            return sum / float((samples * 2 + 1) * (samples * 2 + 1));
        }
]])
end

function blur.apply(sourceCanvas, blurAmount)
    blur.shader:send("blur_size", blurAmount)

    love.graphics.setCanvas(blur.canvas1)
    love.graphics.clear()
    love.graphics.setShader(blur.shader)
    love.graphics.draw(sourceCanvas)
    love.graphics.setShader()
    love.graphics.setCanvas()

    return blur.canvas1
end

return blur
```

```lua
-- main.lua
local blur = require("blur")

local lighting = {}

function love.load()
    lighting.glowCanvas = love.graphics.newCanvas()
    blur.load()
end

function love.update(dt)
end

function love.draw()
    love.graphics.setCanvas(lighting.glowCanvas)
    love.graphics.clear()
    love.graphics.setColor(1, 1, 1)
    love.graphics.circle("fill", 400, 300, 100)
    love.graphics.setCanvas()

    local blurred = blur.apply(lighting.glowCanvas, 0.005)
    love.graphics.setColor(1, 1, 1)
    love.graphics.draw(blurred, 0, 0)
end
```

## 🧵 12.4 Multithreading com `love.thread`

Threads permitem executar tarefas paralelas sem travar o loop principal do jogo, útil para carregamento de arquivos, processamento de dados ou cálculos pesados.

### Thread Básica:

```lua
-- main.lua
function love.load()
    thread = love.thread.newThread("worker.lua")
    channel = love.thread.getChannel("resultado")

    thread:start()
    resultado = nil
end

function love.update(dt)
    -- Verifica se há resultado da thread
    local msg = channel:pop()
    if msg then
        resultado = msg
    end
end

function love.draw()
    if resultado then
        love.graphics.print("Resultado da thread: " .. resultado, 100, 100)
    else
        love.graphics.print("Processando...", 100, 100)
    end
end
```

```lua
-- worker.lua
local channel = love.thread.getChannel("resultado")

-- Simula processamento pesado
local soma = 0
for i = 1, 1000000 do
    soma = soma + i
end

-- Envia resultado de volta
channel:push("Soma: " .. soma)
```

## 🔧 12.7 Otimização e Performance

### Exemplo Técnicas de Otimização com Canvas:

```lua
local optimization = {}

function optimization.init()
    optimization.staticCanvas = love.graphics.newCanvas()
    optimization.dynamicCanvas = love.graphics.newCanvas()
    optimization.needsStaticUpdate = true
    optimization.staticObjects = {}
    optimization.dynamicObjects = {}
end

function optimization.addStaticObject(obj)
    table.insert(optimization.staticObjects, obj)
    optimization.needsStaticUpdate = true
end

function optimization.addDynamicObject(obj)
    table.insert(optimization.dynamicObjects, obj)
end

function optimization.update(dt)
    -- Atualiza apenas objetos dinâmicos
    for _, obj in ipairs(optimization.dynamicObjects) do
        obj:update(dt)
    end

    -- Redesenha canvas estático apenas quando necessário
    if optimization.needsStaticUpdate then
        optimization.updateStaticCanvas()
        optimization.needsStaticUpdate = false
    end
end

function optimization.updateStaticCanvas()
    love.graphics.setCanvas(optimization.staticCanvas)
    love.graphics.clear()

    for _, obj in ipairs(optimization.staticObjects) do
        obj:draw()
    end

    love.graphics.setCanvas()
end

function optimization.draw()
    -- Desenha elementos estáticos (uma vez por frame)
    love.graphics.draw(optimization.staticCanvas)

    -- Desenha elementos dinâmicos
    for _, obj in ipairs(optimization.dynamicObjects) do
        obj:draw()
    end
end
```

### Exemplo Sistema de Culling (não desenhar objetos fora da tela):

```lua
local culling = {}

function culling.isVisible(x, y, width, height, camera)
    local screenLeft = camera.x
    local screenRight = camera.x + love.graphics.getWidth()
    local screenTop = camera.y
    local screenBottom = camera.y + love.graphics.getHeight()

    return not (x + width < screenLeft or
                x > screenRight or
                y + height < screenTop or
                y > screenBottom)
end

function culling.drawWithCulling(objects, camera)
    local drawn = 0
    local culled = 0

    for _, obj in ipairs(objects) do
        if culling.isVisible(obj.x, obj.y, obj.width, obj.height, camera) then
            obj:draw()
            drawn = drawn + 1
        else
            culled = culled + 1
        end
    end

    return drawn, culled
end
```

### Exemplo Profiler Simples para Monitorar Performance:

```lua
local profiler = {
    timers = {},
    results = {}
}

function profiler.start(name)
    profiler.timers[name] = love.timer.getTime()
end

function profiler.stop(name)
    if profiler.timers[name] then
        local elapsed = love.timer.getTime() - profiler.timers[name]
        profiler.results[name] = elapsed
        profiler.timers[name] = nil
        return elapsed
    end
end

function profiler.draw()
    local y = 10
    love.graphics.setColor(1, 1, 0)
    love.graphics.print("=== PROFILER ===", 10, y)
    y = y + 15

    for name, time in pairs(profiler.results) do
        love.graphics.print(string.format("%s: %.3fms", name, time * 1000), 10, y)
        y = y + 15
    end

    love.graphics.print(string.format("FPS: %.1f", love.timer.getFPS()), 10, y)
    love.graphics.print(string.format("Memory: %.2f MB", collectgarbage("count") / 1024), 10, y + 15)
    love.graphics.setColor(1, 1, 1)
end

-- Uso do profiler
function love.update(dt)
    profiler.start("physics")
    fisica.update(dt)
    profiler.stop("physics")

    profiler.start("effects")
    effects.update(dt)
    profiler.stop("effects")
end
```

## 🎮 12.8 Sistema de Estados Avançado

Para jogos complexos, um sistema de estados bem estruturado é essencial:

```lua
local StateManager = {}
StateManager.__index = StateManager

function StateManager:new()
    local sm = {
        states = {},
        currentState = nil,
        stateStack = {}
    }
    setmetatable(sm, StateManager)
    return sm
end

function StateManager:addState(name, state)
    self.states[name] = state
    if not state.manager then
        state.manager = self
    end
end

function StateManager:changeState(name, ...)
    if self.currentState and self.currentState.exit then
        self.currentState:exit()
    end

    self.currentState = self.states[name]

    if self.currentState and self.currentState.enter then
        self.currentState:enter(...)
    end
end

function StateManager:pushState(name, ...)
    if self.currentState then
        table.insert(self.stateStack, self.currentState)
        if self.currentState.pause then
            self.currentState:pause()
        end
    end

    self.currentState = self.states[name]

    if self.currentState and self.currentState.enter then
        self.currentState:enter(...)
    end
end

function StateManager:popState()
    if self.currentState and self.currentState.exit then
        self.currentState:exit()
    end

    self.currentState = table.remove(self.stateStack)

    if self.currentState and self.currentState.resume then
        self.currentState:resume()
    end
end

function StateManager:update(dt)
    if self.currentState and self.currentState.update then
        self.currentState:update(dt)
    end
end

function StateManager:draw()
    if self.currentState and self.currentState.draw then
        self.currentState:draw()
    end
end

-- Estados de exemplo
local MenuState = {}
function MenuState:enter() print("Entrando no menu") end

function MenuState:update(dt) end

function MenuState:draw()
    love.graphics.print("=== MENU ===", 100, 100)
    love.graphics.print("Pressione ENTER para jogar", 100, 120)
end

function MenuState:keypressed(key)
    if key == "return" then
        self.manager:changeState("game")
    end
end

local GameState = {}
function GameState:enter()
    print("Iniciando jogo")
    -- Inicializar mundo do jogo
end

function GameState:update(dt)
    -- Lógica do jogo
end

function GameState:draw()
    love.graphics.print("=== JOGO ===", 100, 100)
    love.graphics.print("Pressione P para pausar", 100, 120)
end

function GameState:keypressed(key)
    if key == "p" then
        self.manager:pushState("pause")
    elseif key == "escape" then
        self.manager:changeState("menu")
    end
end

local PauseState = {}
function PauseState:enter() print("Jogo pausado") end

function PauseState:draw()
    love.graphics.setColor(0, 0, 0, 0.5)
    love.graphics.rectangle("fill", 0, 0, love.graphics.getDimensions())
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("=== PAUSADO ===", 100, 100)
    love.graphics.print("Pressione P para continuar", 100, 120)
end

function PauseState:keypressed(key)
    if key == "p" then
        self.manager:popState()
    end
end

-- Uso do sistema
local stateManager = StateManager:new()

function love.load()
    stateManager:addState("menu", MenuState)
    stateManager:addState("game", GameState)
    stateManager:addState("pause", PauseState)

    stateManager:changeState("menu")
end

function love.update(dt)
    stateManager:update(dt)
end

function love.draw()
    stateManager:draw()
end

function love.keypressed(key)
    if stateManager.currentState and stateManager.currentState.keypressed then
        stateManager.currentState:keypressed(key)
    end
end
```

## 🧪 12.9 Debugging e Ferramentas de Desenvolvimento

### Console de Debug Integrado:

```lua
local Console = {}

function Console:new()
    local console = {
        visible = false,
        input = "",
        history = {},
        commands = {},
        logs = {},
        maxLogs = 50
    }

    setmetatable(console, { __index = self })

    -- Comandos padrão
    console:addCommand("help", function()
        console:log("Comandos disponíveis:")
        for name, _ in pairs(console.commands) do
            console:log("  " .. name)
        end
    end)

    console:addCommand("clear", function()
        console.logs = {}
    end)

    console:addCommand("fps", function()
        console:log("FPS: " .. love.timer.getFPS())
    end)

    return console
end

function Console:addCommand(name, func)
    self.commands[name] = func
end

function Console:log(message)
    table.insert(self.logs, message)
    if #self.logs > self.maxLogs then
        table.remove(self.logs, 1)
    end
end

function Console:executeCommand(command)
    local parts = {}
    for part in command:gmatch("%S+") do
        table.insert(parts, part)
    end

    if #parts > 0 then
        local cmdName = parts[1]
        local args = { unpack(parts, 2) }

        if self.commands[cmdName] then
            local success, error = pcall(self.commands[cmdName], unpack(args))
            if not success then
                self:log("Erro: " .. error)
            end
        else
            self:log("Comando não encontrado: " .. cmdName)
        end
    end
end

function Console:toggle()
    self.visible = not self.visible
    if self.visible then
        love.keyboard.setKeyRepeat(true)
    else
        love.keyboard.setKeyRepeat(false)
    end
end

function Console:textinput(text)
    if self.visible then
        self.input = self.input .. text
    end
end

function Console:keypressed(key)
    if key == "f1" then
        self:toggle()
    elseif self.visible then
        if key == "return" then
            if self.input ~= "" then
                self:log("> " .. self.input)
                self:executeCommand(self.input)
                table.insert(self.history, self.input)
                self.input = ""
            end
        elseif key == "backspace" then
            self.input = self.input:sub(1, -2)
        end
    end
end

function Console:draw()
    if not self.visible then return end

    local height = 300
    love.graphics.setColor(0, 0, 0, 0.8)
    love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), height)

    love.graphics.setColor(1, 1, 1)

    -- Desenha logs
    local y = 10
    for i = math.max(1, #self.logs - 15), #self.logs do
        love.graphics.print(self.logs[i], 10, y)
        y = y + 15
    end

    -- Desenha input
    local inputY = height - 25
    love.graphics.print("> " .. self.input .. "_", 10, inputY)

    love.graphics.setColor(1, 1, 1)
end

function love.load()
    console = Console:new()
end

function love.textinput(t)
    console:textinput(t)
end

function love.keypressed(key)
    console:keypressed(key)
end

function love.draw()
    -- Aqui você desenha seu jogo normalmente
    -- ...
    -- Depois desenha o console por cima
    love.graphics.print("Console: f1", 10, 10)
    console:draw()
end
```

## ✅ Conclusão do Capítulo

Neste capítulo você aprendeu técnicas avançadas essenciais para criar jogos profissionais:

### **Física Realista**:

-   Integração com Box2D através de `love.physics`
-   Criação de corpos dinâmicos, estáticos e cinemáticos
-   Configuração de propriedades físicas (elasticidade, fricção)
-   Detecção de colisões e aplicação de forças

### **Sistema de Câmera Sofisticado**:

-   Controle de visualização com `love.graphics.translate`
-   Câmeras que seguem objetos suavemente
-   Sistema de deadzone e limites do mundo
-   Conversão entre coordenadas de mundo e tela

### **Efeitos Visuais Avançados**:

-   Uso de Canvas para renderização em múltiplas camadas
-   Sistemas de iluminação e sombras
-   Efeitos de pós-processamento com shaders
-   Otimização de renderização

### **Processamento Paralelo**:

-   Threads para tarefas assíncronas
-   Carregamento de assets em background
-   Comunicação segura entre threads via channels
-   Tratamento de erros em operações paralelas

### **Arquitetura de Jogos Profissional**:

-   Sistema de estados para diferentes telas/modos
-   Gerenciamento de recursos e otimização
-   Ferramentas de debugging integradas
-   Profiling e monitoramento de performance

### **Técnicas de Otimização**:

-   Culling de objetos fora da tela
-   Canvas para elementos estáticos
-   Monitoramento de memory e FPS
-   Estruturação modular do código

Estas técnicas formam a base para desenvolvimento de jogos mais complexos e performáticos, preparando você para criar experiências interativas profissionais com LÖVE2D.

### Recursos Úteis:

-   [Documentação Box2D](https://box2d.org/documentation/)
-   [LÖVE2D Physics Tutorial](https://love2d.org/wiki/Tutorial:Physics)
-   [Shader Programming Guide](https://love2d.org/wiki/Shader)
-   [Thread Programming Best Practices](https://love2d.org/wiki/love.thread)
