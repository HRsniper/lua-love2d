# üß© Cap√≠tulo 4: Movimento e Intera√ß√£o

## üéØ Objetivo

Ensinar como implementar movimento com teclado, detectar colis√µes simples e criar intera√ß√µes entre objetos no jogo.

## üéÆ 4.1 Movimento com Teclado

### Entrada Cont√≠nua

Usamos `love.keyboard.isDown(tecla)` para verificar se uma tecla est√° pressionada continuamente. Isso √© ideal para movimento suave.

```lua
function love.load()
    jogador = {
        x = 300,
        y = 300,
        velocidade = 200,
        largura = 50,
        altura = 50
    }
end

function love.update(dt)
    -- Movimento vertical
    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - jogador.velocidade * dt
    end
    if love.keyboard.isDown("down") then
        jogador.y = jogador.y + jogador.velocidade * dt
    end

    -- Movimento horizontal
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - jogador.velocidade * dt
    end
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + jogador.velocidade * dt
    end
end

function love.draw()
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)
end
```

### Movimento Diagonal

Com o c√≥digo acima, o jogador pode se mover diagonalmente se pressionar duas teclas ao mesmo tempo. Para normalizar a velocidade diagonal:

```lua
function love.update(dt)
    local dx, dy = 0, 0

    -- Capturar dire√ß√µes
    if love.keyboard.isDown("up") then
        dy = dy - 1
    end
    if love.keyboard.isDown("down") then
        dy = dy + 1
    end
    if love.keyboard.isDown("left") then
        dx = dx - 1
    end
    if love.keyboard.isDown("right") then
        dx = dx + 1
    end

    -- Normalizar movimento diagonal
    if dx ~= 0 or dy ~= 0 then
        local length = math.sqrt(dx * dx + dy * dy)
        dx = dx / length
        dy = dy / length

        jogador.x = jogador.x + dx * jogador.velocidade * dt
        jogador.y = jogador.y + dy * jogador.velocidade * dt
    end
end
```

### Limitando Movimento na Tela

```lua
function love.update(dt)
    -- Movimento normal...
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + jogador.velocidade * dt
    end
    -- ... outros movimentos

    -- Limitar √†s bordas da tela
    local larguraTela = love.graphics.getWidth()
    local alturaTela = love.graphics.getHeight()

    jogador.x = math.max(0, math.min(larguraTela - jogador.largura, jogador.x))
    jogador.y = math.max(0, math.min(alturaTela - jogador.altura, jogador.y))
end
```

## üß± 4.2 Colis√µes Simples (AABB)

### O que √© AABB?

AABB (Axis-Aligned Bounding Box) √© uma t√©cnica simples para detectar colis√µes entre ret√¢ngulos alinhados aos eixos. √â r√°pida e eficiente para a maioria dos jogos 2D.

### Fun√ß√£o de Colis√£o B√°sica

```lua
function colidiu(a, b)
    return a.x < b.x + b.largura and
           b.x < a.x + a.largura and
           a.y < b.y + b.altura and
           b.y < a.y + a.altura
end
```

### Exemplo Pr√°tico com Obst√°culo

```lua
function love.load()
    jogador = {x = 100, y = 100, largura = 50, altura = 50, cor = {0, 1, 0}}
    obstaculo = {x = 200, y = 100, largura = 80, altura = 80, cor = {1, 0, 0}}
    colidindo = false
end

function love.update(dt)
    -- Movimento do jogador
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + 150 * dt
    end
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - 150 * dt
    end

    -- Verificar colis√£o
    colidindo = colidiu(jogador, obstaculo)

    if colidindo then
        print("Colis√£o detectada!")
    end
end

function love.draw()
    -- Desenhar jogador (verde ou amarelo se colidindo)
    if colidindo then
        love.graphics.setColor(1, 1, 0)  -- amarelo
    else
        love.graphics.setColor(jogador.cor)
    end
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Desenhar obst√°culo
    love.graphics.setColor(obstaculo.cor)
    love.graphics.rectangle("line", obstaculo.x, obstaculo.y, obstaculo.largura, obstaculo.altura)

    -- Reset cor
    love.graphics.setColor(1, 1, 1)

    -- Informa√ß√µes na tela
    if colidindo then
        love.graphics.print("COLIS√ÉO!", 10, 10)
    end
end
```

### Colis√£o com Resposta (Bloquear Movimento)

```lua
function love.update(dt)
    -- Salvar posi√ß√£o anterior
    local antiga_x = jogador.x
    local antiga_y = jogador.y

    -- Aplicar movimento
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + 150 * dt
    end
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - 150 * dt
    end
    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - 150 * dt
    end
    if love.keyboard.isDown("down") then
        jogador.y = jogador.y + 150 * dt
    end

    -- Se colidiu, voltar √† posi√ß√£o anterior
    if colidiu(jogador, obstaculo) then
        jogador.x = antiga_x
        jogador.y = antiga_y
        colidindo = true
    else
        colidindo = false
    end
end
```

## üß† 4.3 Intera√ß√µes com Objetos

### Sistema de Coleta de Itens

```lua
function love.load()
    jogador = {x = 100, y = 100, largura = 40, altura = 40}

    moedas = {
        {x = 300, y = 100, largura = 20, altura = 20, coletada = false},
        {x = 500, y = 200, largura = 20, altura = 20, coletada = false},
        {x = 200, y = 300, largura = 20, altura = 20, coletada = false}
    }

    pontuacao = 0
    moedasColetadas = 0
end

function love.update(dt)
    -- Movimento do jogador
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + 150 * dt
    end
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - 150 * dt
    end
    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - 150 * dt
    end
    if love.keyboard.isDown("down") then
        jogador.y = jogador.y + 150 * dt
    end

    -- Verificar coleta de moedas
    for i, moeda in ipairs(moedas) do
        if not moeda.coletada and colidiu(jogador, moeda) then
            moeda.coletada = true
            pontuacao = pontuacao + 10
            moedasColetadas = moedasColetadas + 1
            print("Moeda coletada! Pontua√ß√£o: " .. pontuacao)
        end
    end
end

function love.draw()
    -- Desenhar jogador
    love.graphics.setColor(0, 0, 1)  -- azul
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Desenhar moedas n√£o coletadas
    love.graphics.setColor(1, 1, 0)  -- amarelo
    for i, moeda in ipairs(moedas) do
        if not moeda.coletada then
            love.graphics.rectangle("fill", moeda.x, moeda.y, moeda.largura, moeda.altura)
        end
    end

    -- Reset cor
    love.graphics.setColor(1, 1, 1)

    -- Interface
    love.graphics.print("Pontua√ß√£o: " .. pontuacao, 10, 10)
    love.graphics.print("Moedas: " .. moedasColetadas .. "/3", 10, 30)

    if moedasColetadas == 3 then
        love.graphics.print("PARAB√âNS! Voc√™ coletou todas as moedas!", 200, 200)
    end
end
```

### Sistema de Inimigos Simples

```lua
function love.load()
    jogador = {x = 100, y = 300, largura = 40, altura = 40, vidas = 3}

    inimigos = {
        {x = 400, y = 100, largura = 30, altura = 30, velocidade = 100, direcao = 1},
        {x = 600, y = 200, largura = 30, altura = 30, velocidade = 80, direcao = -1}
    }

    gameOver = false
end

function love.update(dt)
    if gameOver then return end

    -- Movimento do jogador
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + 150 * dt
    end
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - 150 * dt
    end
    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - 150 * dt
    end
    if love.keyboard.isDown("down") then
        jogador.y = jogador.y + 150 * dt
    end

    -- Movimento dos inimigos
    for i, inimigo in ipairs(inimigos) do
        inimigo.x = inimigo.x + inimigo.velocidade * inimigo.direcao * dt

        -- Inverter dire√ß√£o nas bordas
        if inimigo.x <= 0 or inimigo.x + inimigo.largura >= love.graphics.getWidth() then
            inimigo.direcao = -inimigo.direcao
        end

        -- Verificar colis√£o com jogador
        if colidiu(jogador, inimigo) then
            jogador.vidas = jogador.vidas - 1
            print("Vida perdida! Vidas restantes: " .. jogador.vidas)

            -- Afastar jogador do inimigo
            jogador.x = jogador.x - 50 * inimigo.direcao

            if jogador.vidas <= 0 then
                gameOver = true
            end
        end
    end
end

function love.draw()
    if gameOver then
        love.graphics.print("GAME OVER!", 300, 300)
        love.graphics.print("Pressione R para reiniciar", 250, 320)
        return
    end

    -- Desenhar jogador
    love.graphics.setColor(0, 1, 0)  -- verde
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Desenhar inimigos
    love.graphics.setColor(1, 0, 0)  -- vermelho
    for i, inimigo in ipairs(inimigos) do
        love.graphics.rectangle("fill", inimigo.x, inimigo.y, inimigo.largura, inimigo.altura)
    end

    -- Reset cor
    love.graphics.setColor(1, 1, 1)

    -- Interface
    love.graphics.print("Vidas: " .. jogador.vidas, 10, 10)
    love.graphics.print("Use as setas para mover", 10, 30)
end

function love.keypressed(tecla)
    if tecla == "r" and gameOver then
        -- Reiniciar jogo
        jogador.vidas = 3
        jogador.x = 100
        jogador.y = 300
        gameOver = false
    end
end
```

## üß© 4.4 Desafio Guiado: Jogo Completo

Vamos criar um jogo onde o jogador precisa evitar obst√°culos m√≥veis e coletar itens:

```lua
function love.load()
    -- Configura√ß√µes da tela
    love.window.setTitle("Esquiva e Coleta")

    -- Jogador
    jogador = {
        x = 50,
        y = 200,
        largura = 30,
        altura = 30,
        velocidade = 200,
        vidas = 3,
        pontuacao = 0
    }

    -- Obst√°culos m√≥veis
    obstaculos = {}
    for i = 1, 3 do
        table.insert(obstaculos, {
            x = 300 + i * 150,
            y = 100 + i * 50,
            largura = 40,
            altura = 40,
            velocidade = 100 + i * 20,
            direcao = (i % 2 == 0) and 1 or -1
        })
    end

    -- Itens colet√°veis
    itens = {}
    for i = 1, 5 do
        table.insert(itens, {
            x = math.random(200, 700),
            y = math.random(50, 350),
            largura = 15,
            altura = 15,
            coletado = false,
            valor = 5
        })
    end

    gameOver = false
    vitoria = false
    tempo = 0
end

function love.update(dt)
    if gameOver or vitoria then return end

    tempo = tempo + dt

    -- Movimento do jogador
    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - jogador.velocidade * dt
    end
    if love.keyboard.isDown("down") then
        jogador.y = jogador.y + jogador.velocidade * dt
    end
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - jogador.velocidade * dt
    end
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + jogador.velocidade * dt
    end

    -- Limitar jogador na tela
    jogador.x = math.max(0, math.min(love.graphics.getWidth() - jogador.largura, jogador.x))
    jogador.y = math.max(0, math.min(love.graphics.getHeight() - jogador.altura, jogador.y))

    -- Movimento dos obst√°culos
    for i, obstaculo in ipairs(obstaculos) do
        obstaculo.y = obstaculo.y + obstaculo.velocidade * obstaculo.direcao * dt

        -- Inverter dire√ß√£o nas bordas
        if obstaculo.y <= 0 or obstaculo.y + obstaculo.altura >= love.graphics.getHeight() then
            obstaculo.direcao = -obstaculo.direcao
        end

        -- Verificar colis√£o com jogador
        if colidiu(jogador, obstaculo) then
            jogador.vidas = jogador.vidas - 1
            -- Afastar jogador
            jogador.x = math.max(0, jogador.x - 30)

            if jogador.vidas <= 0 then
                gameOver = true
            end
        end
    end

    -- Coleta de itens
    local itensRestantes = 0
    for i, item in ipairs(itens) do
        if not item.coletado then
            itensRestantes = itensRestantes + 1

            if colidiu(jogador, item) then
                item.coletado = true
                jogador.pontuacao = jogador.pontuacao + item.valor
            end
        end
    end

    -- Verificar vit√≥ria
    if itensRestantes == 0 then
        vitoria = true
    end
end

function love.draw()
    -- Fundo
    love.graphics.setColor(0.1, 0.1, 0.2)
    love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), love.graphics.getHeight())

    if gameOver then
        love.graphics.setColor(1, 0, 0)
        love.graphics.print("GAME OVER!", 300, 200, 0, 2, 2)
        love.graphics.setColor(1, 1, 1)
        love.graphics.print("Pontua√ß√£o final: " .. jogador.pontuacao, 280, 250)
        love.graphics.print("Pressione R para reiniciar", 270, 280)
        return
    end

    if vitoria then
        love.graphics.setColor(0, 1, 0)
        love.graphics.print("VIT√ìRIA!", 320, 200, 0, 2, 2)
        love.graphics.setColor(1, 1, 1)
        love.graphics.print("Pontua√ß√£o final: " .. jogador.pontuacao, 280, 250)
        love.graphics.print("Tempo: " .. string.format("%.1f", tempo) .. "s", 310, 270)
        love.graphics.print("Pressione R para jogar novamente", 250, 300)
        return
    end

    -- Desenhar jogador
    love.graphics.setColor(0, 1, 0)
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Desenhar obst√°culos
    love.graphics.setColor(1, 0, 0)
    for i, obstaculo in ipairs(obstaculos) do
        love.graphics.rectangle("fill", obstaculo.x, obstaculo.y, obstaculo.largura, obstaculo.altura)
    end

    -- Desenhar itens
    love.graphics.setColor(1, 1, 0)
    for i, item in ipairs(itens) do
        if not item.coletado then
            love.graphics.rectangle("fill", item.x, item.y, item.largura, item.altura)
        end
    end

    -- Interface
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Vidas: " .. jogador.vidas, 10, 10)
    love.graphics.print("Pontua√ß√£o: " .. jogador.pontuacao, 10, 30)
    love.graphics.print("Tempo: " .. string.format("%.1f", tempo), 10, 50)

    -- Instru√ß√µes
    love.graphics.print("Use as setas para mover", 10, 100)
    love.graphics.print("Evite os quadrados vermelhos", 10, 120)
    love.graphics.print("Colete todos os quadrados amarelos", 10, 140)
end

function love.keypressed(tecla)
    if tecla == "r" and (gameOver or vitoria) then
        love.load()  -- Reiniciar o jogo
    end
end
```

## ‚úÖ Conclus√£o do Cap√≠tulo

Voc√™ aprendeu:

-   Como implementar movimento suave e responsivo com teclado
-   Como detectar colis√µes usando AABB (Axis-Aligned Bounding Box)
-   Como criar intera√ß√µes entre objetos (coleta, dano, etc.)
-   Como aplicar l√≥gica de jogo com base em eventos de colis√£o
-   Como criar um jogo completo com m√∫ltiplos sistemas integrados

## üí° Conceitos Importantes

-   **Delta Time**: Fundamental para movimento consistente em diferentes framerates
-   **Colis√£o AABB**: T√©cnica eficiente para detec√ß√£o de colis√µes em jogos 2D
-   **Separa√ß√£o de Responsabilidades**: Movimento, colis√£o e renderiza√ß√£o bem organizados
-   **Estado do Jogo**: Gerenciamento de diferentes estados (jogando, game over, vit√≥ria)
