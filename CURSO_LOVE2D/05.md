# 📦 Capítulo 5: Estrutura de Dados e Organização

## 🎯 Objetivo

Ensinar como usar tabelas para representar coleções de objetos no jogo e como dividir o código em múltiplos arquivos para facilitar a manutenção e escalabilidade.

## 🧱 5.1 Tabelas como Listas de Objetos

Em Lua, tabelas podem ser usadas como arrays para armazenar múltiplos elementos. Isso é fundamental para gerenciar grupos de objetos similares.

### Lista Básica de Inimigos

```lua
function love.load()
    inimigos = {
        {x = 100, y = 100, largura = 40, altura = 40, vida = 3},
        {x = 200, y = 150, largura = 40, altura = 40, vida = 3},
        {x = 300, y = 200, largura = 40, altura = 40, vida = 3}
    }
end

function love.draw()
    love.graphics.setColor(1, 0, 0)  -- vermelho
    for i, inimigo in ipairs(inimigos) do
        love.graphics.rectangle("fill", inimigo.x, inimigo.y, inimigo.largura, inimigo.altura)
    end
    love.graphics.setColor(1, 1, 1)  -- reset para branco
end
```

### Usando Índices vs ipairs

```lua
-- ✅ Método recomendado - ipairs
for i, inimigo in ipairs(inimigos) do
    print("Inimigo", i, "está em", inimigo.x, inimigo.y)
end

-- ✅ Alternativa - índices numéricos
for i = 1, #inimigos do
    local inimigo = inimigos[i]
    print("Inimigo", i, "está em", inimigo.x, inimigo.y)
end
```

## 🔁 5.2 Atualizando Objetos em Loop

Você pode aplicar lógica a todos os elementos da tabela usando loops `for`.

### Movimento Simples

```lua
function love.update(dt)
    for i, inimigo in ipairs(inimigos) do
        -- Mover para a direita
        inimigo.x = inimigo.x + 50 * dt

        -- Se sair da tela, voltar para o início
        if inimigo.x > love.graphics.getWidth() then
            inimigo.x = -inimigo.largura
        end
    end
end
```

### Movimento Mais Complexo

```lua
function love.load()
    inimigos = {}

    -- Criar inimigos com diferentes comportamentos
    for i = 1, 5 do
        table.insert(inimigos, {
            x = math.random(0, 600),
            y = math.random(50, 200),
            largura = 30,
            altura = 30,
            velocidadeX = math.random(-100, 100),
            velocidadeY = math.random(20, 80),
            tipo = math.random(1, 3)
        })
    end
end

function love.update(dt)
    for i, inimigo in ipairs(inimigos) do
        -- Movimento baseado no tipo
        if inimigo.tipo == 1 then
            -- Movimento linear
            inimigo.x = inimigo.x + inimigo.velocidadeX * dt
            inimigo.y = inimigo.y + inimigo.velocidadeY * dt
        elseif inimigo.tipo == 2 then
            -- Movimento senoidal
            inimigo.x = inimigo.x + inimigo.velocidadeX * dt
            inimigo.y = inimigo.y + math.sin(love.timer.getTime() + i) * 50 * dt
        else
            -- Movimento circular
            local tempo = love.timer.getTime() + i
            inimigo.x = 400 + math.cos(tempo) * 100
            inimigo.y = 200 + math.sin(tempo) * 100
        end

        -- Reposicionar se sair da tela
        if inimigo.x < -50 then inimigo.x = love.graphics.getWidth() + 50 end
        if inimigo.x > love.graphics.getWidth() + 50 then inimigo.x = -50 end
        if inimigo.y > love.graphics.getHeight() + 50 then inimigo.y = -50 end
    end
end

function love.draw()
    for i, inimigo in ipairs(inimigos) do
        -- Cor diferente por tipo
        if inimigo.tipo == 1 then
            love.graphics.setColor(1, 0, 0)      -- vermelho
        elseif inimigo.tipo == 2 then
            love.graphics.setColor(0, 1, 0)      -- verde
        else
            love.graphics.setColor(0, 0, 1)      -- azul
        end

        love.graphics.rectangle("fill", inimigo.x, inimigo.y, inimigo.largura, inimigo.altura)
    end
    love.graphics.setColor(1, 1, 1)  -- reset
end
```

## 🧠 5.3 Criando Objetos Dinamicamente

### Sistema de Balas Básico

```lua
function love.load()
    balas = {}
    jogador = {x = 400, y = 500}
end

function love.keypressed(tecla)
    if tecla == "space" then
        -- Criar nova bala na posição do jogador
        table.insert(balas, {
            x = jogador.x,
            y = jogador.y,
            velocidade = 400,
            largura = 5,
            altura = 10
        })
    end
end

function love.update(dt)
    -- Atualizar todas as balas
    for i, bala in ipairs(balas) do
        bala.y = bala.y - bala.velocidade * dt
    end

    -- Remover balas que saíram da tela
    for i = #balas, 1, -1 do  -- loop reverso para remoção segura
        if balas[i].y < -10 then
            table.remove(balas, i)
        end
    end
end

function love.draw()
    -- Desenhar jogador
    love.graphics.setColor(0, 1, 0)
    love.graphics.rectangle("fill", jogador.x, jogador.y, 40, 40)

    -- Desenhar balas
    love.graphics.setColor(1, 1, 0)
    for i, bala in ipairs(balas) do
        love.graphics.rectangle("fill", bala.x, bala.y, bala.largura, bala.altura)
    end

    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Balas ativas: " .. #balas, 10, 10)
    love.graphics.print("Pressione SPACE para atirar", 10, 30)
end
```

### Sistema de Spawn Automático

```lua
function love.load()
    inimigos = {}
    tempoUltimoInimigo = 0
    intervaloSpawn = 1.0  -- segundos entre spawns
end

function love.update(dt)
    -- Sistema de spawn temporizado
    tempoUltimoInimigo = tempoUltimoInimigo + dt

    if tempoUltimoInimigo >= intervaloSpawn then
        -- Criar novo inimigo
        table.insert(inimigos, {
            x = math.random(0, love.graphics.getWidth() - 30),
            y = -30,  -- começar acima da tela
            largura = 30,
            altura = 30,
            velocidade = math.random(50, 150),
            vida = math.random(1, 3)
        })

        tempoUltimoInimigo = 0

        -- Aumentar dificuldade gradualmente
        intervaloSpawn = math.max(0.2, intervaloSpawn - 0.01)
    end

    -- Atualizar inimigos
    for i, inimigo in ipairs(inimigos) do
        inimigo.y = inimigo.y + inimigo.velocidade * dt
    end

    -- Remover inimigos que saíram da tela
    for i = #inimigos, 1, -1 do
        if inimigos[i].y > love.graphics.getHeight() + 50 then
            table.remove(inimigos, i)
        end
    end
end

function love.draw()
    for i, inimigo in ipairs(inimigos) do
        -- Cor baseada na vida
        local intensidade = inimigo.vida / 3
        love.graphics.setColor(1, 1 - intensidade, 1 - intensidade)
        love.graphics.rectangle("fill", inimigo.x, inimigo.y, inimigo.largura, inimigo.altura)
    end

    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Inimigos ativos: " .. #inimigos, 10, 10)
    love.graphics.print("Intervalo de spawn: " .. string.format("%.2f", intervaloSpawn), 10, 30)
end
```

## 📂 5.4 Separando Código em Arquivos

### Estrutura de Projeto Organizada

```
meu_jogo/
├── main.lua
├── player.lua
├── enemy.lua
├── bullet.lua
└── utils.lua
```

### player.lua

```lua
-- player.lua
local player = {}

function player.new(x, y)
    return {
        x = x or 100,
        y = y or 100,
        largura = 40,
        altura = 40,
        velocidade = 200,
        vida = 100,
        cor = {0, 1, 0}  -- verde
    }
end

function player.update(p, dt)
    -- Movimento
    if love.keyboard.isDown("up", "w") then
        p.y = p.y - p.velocidade * dt
    end
    if love.keyboard.isDown("down", "s") then
        p.y = p.y + p.velocidade * dt
    end
    if love.keyboard.isDown("left", "a") then
        p.x = p.x - p.velocidade * dt
    end
    if love.keyboard.isDown("right", "d") then
        p.x = p.x + p.velocidade * dt
    end

    -- Limitar às bordas da tela
    p.x = math.max(0, math.min(love.graphics.getWidth() - p.largura, p.x))
    p.y = math.max(0, math.min(love.graphics.getHeight() - p.altura, p.y))
end

function player.draw(p)
    love.graphics.setColor(p.cor)
    love.graphics.rectangle("fill", p.x, p.y, p.largura, p.altura)

    -- Barra de vida
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", p.x, p.y - 10, p.largura, 5)
    love.graphics.setColor(0, 1, 0)
    love.graphics.rectangle("fill", p.x, p.y - 10, p.largura * (p.vida / 100), 5)
end

function player.takeDamage(p, damage)
    p.vida = p.vida - damage
    return p.vida <= 0
end

return player
```

### enemy.lua

```lua
-- enemy.lua
local enemy = {}

function enemy.new(x, y, tipo)
    tipo = tipo or 1

    local inimigo = {
        x = x,
        y = y,
        largura = 30,
        altura = 30,
        velocidade = math.random(50, 120),
        vida = tipo * 2,
        tipo = tipo,
        direcao = math.random() > 0.5 and 1 or -1
    }

    -- Propriedades baseadas no tipo
    if tipo == 1 then
        inimigo.cor = {1, 0, 0}      -- vermelho - básico
    elseif tipo == 2 then
        inimigo.cor = {1, 0.5, 0}    -- laranja - rápido
        inimigo.velocidade = inimigo.velocidade * 1.5
    else
        inimigo.cor = {0.5, 0, 0.5}  -- roxo - tanque
        inimigo.vida = inimigo.vida * 2
        inimigo.largura = 40
        inimigo.altura = 40
    end

    return inimigo
end

function enemy.update(inimigo, dt)
    if inimigo.tipo == 1 then
        -- Movimento linear simples
        inimigo.y = inimigo.y + inimigo.velocidade * dt
    elseif inimigo.tipo == 2 then
        -- Movimento em zigue-zague
        inimigo.y = inimigo.y + inimigo.velocidade * dt
        inimigo.x = inimigo.x + math.sin(love.timer.getTime() * 3) * 100 * dt
    else
        -- Movimento lento mas direcionado ao jogador (simplificado)
        inimigo.y = inimigo.y + inimigo.velocidade * 0.7 * dt
    end
end

function enemy.draw(inimigo)
    love.graphics.setColor(inimigo.cor)
    love.graphics.rectangle("fill", inimigo.x, inimigo.y, inimigo.largura, inimigo.altura)

    -- Indicador de vida para tipos mais fortes
    if inimigo.tipo > 1 then
        local vidaMax = inimigo.tipo == 2 and 4 or 12
        love.graphics.setColor(1, 1, 1, 0.8)
        love.graphics.rectangle("line", inimigo.x, inimigo.y - 5, inimigo.largura, 3)
        love.graphics.setColor(1, 0, 0, 0.8)
        love.graphics.rectangle("fill", inimigo.x, inimigo.y - 5, inimigo.largura * (inimigo.vida / vidaMax), 3)
    end
end

function enemy.isOffScreen(inimigo)
    return inimigo.y > love.graphics.getHeight() + 50 or
           inimigo.x < -50 or
           inimigo.x > love.graphics.getWidth() + 50
end

return enemy
```

### utils.lua

```lua
-- utils.lua
local utils = {}

function utils.distance(x1, y1, x2, y2)
    return math.sqrt((x2 - x1)^2 + (y2 - y1)^2)
end

function utils.collision(obj1, obj2)
    return obj1.x < obj2.x + obj2.largura and
           obj2.x < obj1.x + obj1.largura and
           obj1.y < obj2.y + obj2.altura and
           obj2.y < obj1.y + obj1.altura
end

function utils.clamp(value, min, max)
    return math.max(min, math.min(max, value))
end

function utils.lerp(a, b, t)
    return a + (b - a) * t
end

return utils
```

### main.lua - Integrando Tudo

```lua
-- main.lua
local Player = require("player")
local Enemy = require("enemy")
local utils = require("utils")

function love.load()
    jogador = Player.new(400, 500)
    inimigos = {}
    balas = {}

    tempoSpawn = 0
    intervaloSpawn = 1.5
    pontuacao = 0
    gameOver = false
end

function love.update(dt)
    if gameOver then return end

    -- Atualizar jogador
    Player.update(jogador, dt)

    -- Sistema de spawn de inimigos
    tempoSpawn = tempoSpawn + dt
    if tempoSpawn >= intervaloSpawn then
        local tipo = math.random(1, 3)
        table.insert(inimigos, Enemy.new(math.random(0, love.graphics.getWidth() - 40), -50, tipo))
        tempoSpawn = 0

        -- Aumentar dificuldade
        intervaloSpawn = math.max(0.3, intervaloSpawn - 0.02)
    end

    -- Atualizar inimigos
    for i = #inimigos, 1, -1 do
        local inimigo = inimigos[i]
        Enemy.update(inimigo, dt)

        -- Verificar colisão com jogador
        if utils.collision(jogador, inimigo) then
            if Player.takeDamage(jogador, 20) then
                gameOver = true
            end
            table.remove(inimigos, i)
        elseif Enemy.isOffScreen(inimigo) then
            table.remove(inimigos, i)
        end
    end

    -- Criar balas
    if love.keyboard.isDown("space") then
        -- Limitar taxa de tiro
        if not ultimoTiro or love.timer.getTime() - ultimoTiro > 0.1 then
            table.insert(balas, {
                x = jogador.x + jogador.largura / 2 - 2,
                y = jogador.y,
                largura = 4,
                altura = 10,
                velocidade = 400
            })
            ultimoTiro = love.timer.getTime()
        end
    end

    -- Atualizar balas
    for i = #balas, 1, -1 do
        local bala = balas[i]
        bala.y = bala.y - bala.velocidade * dt

        -- Remover balas fora da tela
        if bala.y < -10 then
            table.remove(balas, i)
        else
            -- Verificar colisão com inimigos
            for j = #inimigos, 1, -1 do
                if utils.collision(bala, inimigos[j]) then
                    inimigos[j].vida = inimigos[j].vida - 1
                    table.remove(balas, i)

                    if inimigos[j].vida <= 0 then
                        pontuacao = pontuacao + inimigos[j].tipo * 10
                        table.remove(inimigos, j)
                    end
                    break
                end
            end
        end
    end
end

function love.draw()
    if gameOver then
        love.graphics.print("GAME OVER!", 300, 250, 0, 2, 2)
        love.graphics.print("Pontuação: " .. pontuacao, 320, 300)
        love.graphics.print("Pressione R para reiniciar", 280, 330)
        return
    end

    -- Desenhar jogador
    Player.draw(jogador)

    -- Desenhar inimigos
    for _, inimigo in ipairs(inimigos) do
        Enemy.draw(inimigo)
    end

    -- Desenhar balas
    love.graphics.setColor(1, 1, 0)
    for _, bala in ipairs(balas) do
        love.graphics.rectangle("fill", bala.x, bala.y, bala.largura, bala.altura)
    end

    -- Interface
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Vida: " .. jogador.vida, 10, 10)
    love.graphics.print("Pontuação: " .. pontuacao, 10, 30)
    love.graphics.print("Inimigos: " .. #inimigos, 10, 50)
end

function love.keypressed(tecla)
    if tecla == "r" and gameOver then
        love.load()
    end
end
```

## 🧩 5.5 Desafio Guiado: Sistema Completo de Gerenciamento

Implemente um sistema que:

1. **Spawn automático**: Adiciona inimigos a cada 2 segundos
2. **Movimento coordenado**: Todos se movem em formação
3. **Remoção inteligente**: Remove objetos fora da tela ou destruídos
4. **Diferentes tipos**: Cada tipo com comportamento único
5. **Sistema de pontuação**: Baseado no tipo e dificuldade

### Dicas importantes:

-   Use `table.remove()` com loop reverso para remoção segura
-   Use `love.timer.getTime()` ou acumulador com `dt` para temporização
-   Organize em funções separadas para cada responsabilidade
-   Considere performance: não deixe listas crescerem infinitamente

## ✅ Conclusão do Capítulo

Você aprendeu:

-   Como usar tabelas para representar múltiplos objetos do mesmo tipo
-   Como atualizar coleções de objetos eficientemente em loops
-   Como criar e remover objetos dinamicamente durante o jogo
-   Como organizar código em módulos separados usando `require`
-   Como criar sistemas de jogo mais complexos e escaláveis

## 💡 Conceitos Importantes

-   **Modularização**: Separar código em arquivos melhora organização e reutilização
-   **Loop Reverso**: Para remoção segura de elementos durante iteração
-   **Performance**: Remover objetos desnecessários previne acúmulo de memória
-   **Separação de Responsabilidades**: Cada módulo tem uma função específica
