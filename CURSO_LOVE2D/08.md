# üí• Cap√≠tulo 8: Detec√ß√£o e Resolu√ß√£o de Colis√µes

## üéØ Objetivo

Ensinar como detectar colis√µes entre objetos usando t√©cnicas simples (AABB) e como aplicar l√≥gica de resposta a essas colis√µes em jogos com L√ñVE2D.

---

## üß± 8.1 O que √© Colis√£o?

Colis√£o ocorre quando dois objetos ocupam o mesmo espa√ßo na tela. Em jogos, detectar colis√µes permite criar intera√ß√µes fundamentais como:

-   **Jogador colidindo com inimigos** (perda de vida, game over)
-   **Coleta de itens** (moedas, power-ups, chaves)
-   **Bloqueio de movimento por paredes** (f√≠sica de s√≥lidos)
-   **Proj√©teis atingindo alvos** (tiros, magias)
-   **Ativa√ß√£o de √°reas especiais** (portais, checkpoints)

### Conceitos B√°sicos

Em jogos 2D, cada objeto possui uma "caixa de colis√£o" (bounding box) que define sua √°rea f√≠sica. Quando essas caixas se sobrep√µem, temos uma colis√£o.

---

## üìê 8.2 Colis√£o AABB (Axis-Aligned Bounding Box)

AABB √© a t√©cnica mais comum e eficiente para jogos 2D. Ela verifica se dois ret√¢ngulos alinhados aos eixos se sobrep√µem.

### Fun√ß√£o de Colis√£o B√°sica

```lua
function colidiu(a, b)
    return a.x < b.x + b.largura and
           b.x < a.x + a.largura and
           a.y < b.y + b.altura and
           b.y < a.y + a.altura
end
```

### Como Funciona

A l√≥gica verifica se:

1. a est√° √† esquerda da borda direita de b
2. b est√° √† esquerda da borda direita de a
3. a est√° acima da borda inferior de b
4. b est√° acima da borda inferior de a

Se todas as condi√ß√µes s√£o verdadeiras, h√° colis√£o!

### Fun√ß√£o Melhorada com Verifica√ß√£o de Seguran√ßa

```lua
function colidiu(a, b)
    -- Verificar se os objetos existem
    if not a or not b then
        return false
    end

    -- Verificar se t√™m as propriedades necess√°rias
    if not (a.x and a.y and a.largura and a.altura and
            b.x and b.y and b.largura and b.altura) then
        return false
    end

    return a.x < b.x + b.largura and
           b.x < a.x + a.largura and
           a.y < b.y + b.altura and
           b.y < a.y + a.altura
end
```

---

## üß™ 8.3 Exemplo Pr√°tico: Jogador e Obst√°culo

### Vers√£o B√°sica

```lua
function colidiu(a, b)
    -- Verificar se os objetos existem
    if not a or not b then
        return false
    end

    -- Verificar se t√™m as propriedades necess√°rias
    if not (a.x and a.y and a.largura and a.altura and
            b.x and b.y and b.largura and b.altura) then
        return false
    end

    return a.x < b.x + b.largura and -- a est√° √† esquerda da borda direita de b
        b.x < a.x + a.largura and    -- b est√° √† esquerda da borda direita de a
        a.y < b.y + b.altura and     -- a est√° acima da borda inferior de b
        b.y < a.y + a.altura         -- b est√° acima da borda inferior de a
end

function love.load()
    jogador = {
        x = 100,
        y = 100,
        largura = 50,
        altura = 50,
        velocidade = 200
    }

    obstaculo = {
        x = 300,
        y = 100,
        largura = 50,
        altura = 50
    }

    colidindo = false
end

function love.update(dt)
    -- Movimento b√°sico
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + jogador.velocidade * dt
    end
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - jogador.velocidade * dt
    end
    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - jogador.velocidade * dt
    end
    if love.keyboard.isDown("down") then
        jogador.y = jogador.y + jogador.velocidade * dt
    end

    -- Verificar colis√£o
    colidindo = colidiu(jogador, obstaculo)

    if colidindo then
        print("Colis√£o detectada!")
    end
end

function love.draw()
    -- Jogador (azul se colidindo, verde se n√£o)
    if colidindo then
        love.graphics.setColor(0, 0, 1) -- azul
    else
        love.graphics.setColor(0, 1, 0) -- verde
    end
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Obst√°culo (vermelho)
    love.graphics.setColor(1, 0, 0)
    love.graphics.rectangle("fill", obstaculo.x, obstaculo.y, obstaculo.largura, obstaculo.altura)

    -- Interface
    love.graphics.setColor(1, 1, 1)
    if colidindo then
        love.graphics.print("COLIDINDO!", 10, 10)
    else
        love.graphics.print("Livre", 10, 10)
    end

    -- Instru√ß√µes
    love.graphics.setColor(0.8, 0.8, 0.8)
    love.graphics.print("Use setas para mover", 10, love.graphics.getHeight() - 30)
end
```

---

## üß† 8.4 Resolvendo Colis√µes: Bloqueio de Movimento

Detectar colis√£o √© s√≥ o primeiro passo. Agora vamos impedir que o jogador atravesse obst√°culos.

### Verifica√ß√£o Preventiva

```lua
function love.update(dt)
    local novoX = jogador.x
    local novoY = jogador.y

    -- Calcular nova posi√ß√£o baseada na entrada
    if love.keyboard.isDown("right") then
        novoX = novoX + jogador.velocidade * dt
    end
    if love.keyboard.isDown("left") then
        novoX = novoX - jogador.velocidade * dt
    end
    if love.keyboard.isDown("up") then
        novoY = novoY - jogador.velocidade * dt
    end
    if love.keyboard.isDown("down") then
        novoY = novoY + jogador.velocidade * dt
    end

    -- Criar objeto tempor√°rio com nova posi√ß√£o
    local futuro = {
        x = novoX,
        y = novoY,
        largura = jogador.largura,
        altura = jogador.altura
    }

    -- Verificar colis√£o
    colidindo = colidiu(futuro, obstaculo)

    -- S√≥ move se n√£o vai colidir
    if not colidindo then
        jogador.x = novoX
        jogador.y = novoY
    end
end
```

### Movimento Separado por Eixos

Exemplo:

```lua
function love.update(dt)
    local velX = 0
    local velY = 0

    -- Determinar velocidades
    if love.keyboard.isDown("right") then velX = jogador.velocidade end
    if love.keyboard.isDown("left") then velX = -jogador.velocidade end
    if love.keyboard.isDown("up") then velY = -jogador.velocidade end
    if love.keyboard.isDown("down") then velY = jogador.velocidade end

    -- Testar movimento horizontal
    local futuroX = {
        x = jogador.x + velX * dt,
        y = jogador.y,
        largura = jogador.largura,
        altura = jogador.altura
    }

    if not colidiu(futuroX, obstaculo) then
        jogador.x = futuroX.x
    end

    -- Testar movimento vertical
    local futuroY = {
        x = jogador.x,
        y = jogador.y + velY * dt,
        largura = jogador.largura,
        altura = jogador.altura
    }

    if not colidiu(futuroY, obstaculo) then
        jogador.y = futuroY.y
    end
end
```

---

## üß© 8.5 Colis√µes com M√∫ltiplos Objetos

Para verificar colis√µes com v√°rios objetos, use loops e tabelas.

### Sistema de Obst√°culos

```lua
function colidiu(a, b)
    -- Verificar se os objetos existem
    if not a or not b then
        return false
    end

    -- Verificar se t√™m as propriedades necess√°rias
    if not (a.x and a.y and a.largura and a.altura and
            b.x and b.y and b.largura and b.altura) then
        return false
    end

    return a.x < b.x + b.largura and -- a est√° √† esquerda da borda direita de b
        b.x < a.x + a.largura and    -- b est√° √† esquerda da borda direita de a
        a.y < b.y + b.altura and     -- a est√° acima da borda inferior de b
        b.y < a.y + a.altura         -- b est√° acima da borda inferior de a
end

function love.load()
    jogador = {
        x = 100,
        y = 100,
        largura = 50,
        altura = 50,
        velocidade = 200
    }

    obstaculos = {
        { x = 200, y = 100, largura = 60, altura = 60 },
        { x = 400, y = 150, largura = 80, altura = 40 },
        { x = 300, y = 300, largura = 50, altura = 100 },
        { x = 500, y = 200, largura = 40, altura = 80 }
    }

    colidindo = false
end

function love.update(dt)
    local novoX = jogador.x
    local novoY = jogador.y

    -- Calcular nova posi√ß√£o baseada na entrada
    if love.keyboard.isDown("right") then novoX = novoX + jogador.velocidade * dt end
    if love.keyboard.isDown("left") then novoX = novoX - jogador.velocidade * dt end
    if love.keyboard.isDown("up") then novoY = novoY - jogador.velocidade * dt end
    if love.keyboard.isDown("down") then novoY = novoY + jogador.velocidade * dt end

    -- Criar objeto tempor√°rio com nova posi√ß√£o
    local futuro = {
        x = novoX,
        y = novoY,
        largura = jogador.largura,
        altura = jogador.altura
    }

    -- Verificar colis√£o com todos os obst√°culos
    local podeMove = true
    for i, obstaculo in ipairs(obstaculos) do
        if colidiu(futuro, obstaculo) then
            podeMove = false
            colidindo = true
            print("Colidiu com obst√°culo " .. i)
            break -- Sair do loop na primeira colis√£o
        end
        colidindo = false
    end

    -- S√≥ move se n√£o colidir com nada
    if podeMove then
        jogador.x = novoX
        jogador.y = novoY
    end
end

function love.draw()
    -- Jogador (azul se colidindo, verde se n√£o)
    if colidindo then
        love.graphics.setColor(0, 0, 1) -- azul
    else
        love.graphics.setColor(0, 1, 0) -- verde
    end
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Obst√°culos (vermelho)
    love.graphics.setColor(1, 0, 0)
    for i, obstaculo in ipairs(obstaculos) do
        love.graphics.rectangle("fill", obstaculo.x, obstaculo.y, obstaculo.largura, obstaculo
            .altura)
    end

    -- Interface
    love.graphics.setColor(1, 1, 1)
    if colidindo then
        love.graphics.print("COLIDINDO!", 10, 10)
    else
        love.graphics.print("Livre", 10, 10)
    end

    -- Instru√ß√µes
    love.graphics.setColor(0.8, 0.8, 0.8)
    love.graphics.print("Use setas para mover", 10, love.graphics.getHeight() - 30)
end
```

### Fun√ß√£o de Verifica√ß√£o Otimizada

Exemplo:

```lua
function temColisaoComObstaculos(objeto, listaObstaculos)
    for i, obstaculo in ipairs(listaObstaculos) do
        if colidiu(objeto, obstaculo) then
            return true, i -- Retorna true e o √≠ndice do obst√°culo
        end
    end
    return false, 0
end

-- Uso:
local colidiu_resultado, indice = temColisaoComObstaculos(futuro, obstaculos)
if not colidiu_resultado then
    jogador.x = novoX
    jogador.y = novoY
end
```

---

## üéÆ 8.6 Colis√£o com Itens Colet√°veis

### Sistema de Coleta Simples

```lua
function love.load()
    jogador = {x = 100, y = 100, largura = 40, altura = 40, velocidade = 200}

    moeda = {
        x = 300,
        y = 200,
        largura = 20,
        altura = 20,
        coletada = false
    }

    pontuacao = 0
end

function love.update(dt)
    -- Movimento do jogador
    if love.keyboard.isDown("right") then
        jogador.x = jogador.x + jogador.velocidade * dt
    end
    if love.keyboard.isDown("left") then
        jogador.x = jogador.x - jogador.velocidade * dt
    end
    if love.keyboard.isDown("up") then
        jogador.y = jogador.y - jogador.velocidade * dt
    end
    if love.keyboard.isDown("down") then
        jogador.y = jogador.y + jogador.velocidade * dt
    end

    -- Verificar coleta da moeda
    if not moeda.coletada and colidiu(jogador, moeda) then
        moeda.coletada = true
        pontuacao = pontuacao + 10
        print("Moeda coletada! Pontua√ß√£o: " .. pontuacao)
    end
end

function love.draw()
    -- Jogador
    love.graphics.setColor(0, 0, 1)
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Moeda (s√≥ desenha se n√£o foi coletada)
    if not moeda.coletada then
        love.graphics.setColor(1, 1, 0)
        love.graphics.circle("fill", moeda.x + moeda.largura/2, moeda.y + moeda.altura/2, moeda.largura/2)
    end

    -- Interface
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Pontua√ß√£o: " .. pontuacao, 10, 10)
end
```

### Sistema com M√∫ltiplas Moedas

```lua
function love.load()
    jogador = {x = 100, y = 100, largura = 40, altura = 40, velocidade = 200}

    moedas = {
        {x = 200, y = 100, largura = 20, altura = 20, coletada = false},
        {x = 400, y = 200, largura = 20, altura = 20, coletada = false},
        {x = 300, y = 300, largura = 20, altura = 20, coletada = false},
        {x = 150, y = 250, largura = 20, altura = 20, coletada = false},
        {x = 500, y = 150, largura = 20, altura = 20, coletada = false}
    }

    pontuacao = 0
    totalMoedas = #moedas
    moedasColetadas = 0
end

function love.update(dt)
    -- Movimento do jogador
    if love.keyboard.isDown("right") then jogador.x = jogador.x + jogador.velocidade * dt end
    if love.keyboard.isDown("left") then jogador.x = jogador.x - jogador.velocidade * dt end
    if love.keyboard.isDown("up") then jogador.y = jogador.y - jogador.velocidade * dt end
    if love.keyboard.isDown("down") then jogador.y = jogador.y + jogador.velocidade * dt end

    -- Verificar coleta de moedas
    for i, moeda in ipairs(moedas) do
        if not moeda.coletada and colidiu(jogador, moeda) then
            moeda.coletada = true
            pontuacao = pontuacao + 10
            moedasColetadas = moedasColetadas + 1

            -- Verificar se coletou todas
            if moedasColetadas >= totalMoedas then
                print("Parab√©ns! Todas as moedas coletadas!")
            end
        end
    end
end

function love.draw()
    -- Jogador
    love.graphics.setColor(0, 0, 1)
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Moedas
    love.graphics.setColor(1, 1, 0)
    for i, moeda in ipairs(moedas) do
        if not moeda.coletada then
            love.graphics.circle("fill", moeda.x + moeda.largura/2, moeda.y + moeda.altura/2, moeda.largura/2)
        end
    end

    -- Interface
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Pontua√ß√£o: " .. pontuacao, 10, 10)
    love.graphics.print("Moedas: " .. moedasColetadas .. "/" .. totalMoedas, 10, 30)

    if moedasColetadas >= totalMoedas then
        love.graphics.print("VOC√ä VENCEU!", 200, 200)
    end
end
```

---

## üß© 8.7 Desafio Guiado: Jogo de Coleta Completo

Vamos criar um jogo completo onde:

-   O jogador coleta moedas espalhadas pela tela
-   Existem obst√°culos que bloqueiam o movimento
-   Cada moeda coletada aumenta a pontua√ß√£o
-   As moedas desaparecem ap√≥s a coleta
-   H√° um sistema de vit√≥ria

```lua
function colidiu(a, b)
    -- Verificar se os objetos existem
    if not a or not b then
        return false
    end

    -- Verificar se t√™m as propriedades necess√°rias
    if not (a.x and a.y and a.largura and a.altura and
            b.x and b.y and b.largura and b.altura) then
        return false
    end

    return a.x < b.x + b.largura and -- a est√° √† esquerda da borda direita de b
        b.x < a.x + a.largura and    -- b est√° √† esquerda da borda direita de a
        a.y < b.y + b.altura and     -- a est√° acima da borda inferior de b
        b.y < a.y + a.altura         -- b est√° acima da borda inferior de a
end

function love.load()
    -- Configura√ß√µes da tela
    love.window.setTitle("Jogo de Coleta - Colis√µes AABB")

    -- Jogador
    jogador = {
        x = 50,
        y = 50,
        largura = 30,
        altura = 30,
        velocidade = 180,
        cor = { 80 / 255, 250 / 255, 123 / 255 } -- Cor #50FA7B
    }

    -- Obst√°culos (paredes)
    obstaculos = {
        { x = 200, y = 50,  largura = 20,  altura = 200 },
        { x = 400, y = 100, largura = 20,  altura = 150 },
        { x = 100, y = 300, largura = 200, altura = 20 },
        { x = 350, y = 350, largura = 150, altura = 20 },
        { x = 550, y = 200, largura = 20,  altura = 200 }
    }

    -- Moedas
    moedas = {
        { x = 150, y = 100, largura = 15, altura = 15, coletada = false, valor = 10 },
        { x = 300, y = 80,  largura = 15, altura = 15, coletada = false, valor = 10 },
        { x = 450, y = 200, largura = 15, altura = 15, coletada = false, valor = 10 },
        { x = 250, y = 250, largura = 15, altura = 15, coletada = false, valor = 10 },
        { x = 500, y = 300, largura = 15, altura = 15, coletada = false, valor = 10 },
        { x = 80,  y = 400, largura = 15, altura = 15, coletada = false, valor = 10 },
        { x = 350, y = 450, largura = 15, altura = 15, coletada = false, valor = 20 }, -- Moeda especial
        { x = 600, y = 100, largura = 15, altura = 15, coletada = false, valor = 10 }
    }

    -- Sistema de jogo
    pontuacao = 0
    moedasColetadas = 0
    totalMoedas = #moedas
    jogoGanho = false
    tempo = 0

    -- Interface
    fonte = love.graphics.newFont(20)
    love.graphics.setFont(fonte)
end

function love.update(dt)
    if jogoGanho then
        return -- Para o jogo se ganhou
    end

    tempo = tempo + dt

    -- Movimento do jogador
    local novoX = jogador.x
    local novoY = jogador.y

    if love.keyboard.isDown("right", "d") then
        novoX = novoX + jogador.velocidade * dt
    end
    if love.keyboard.isDown("left", "a") then
        novoX = novoX - jogador.velocidade * dt
    end
    if love.keyboard.isDown("up", "w") then
        novoY = novoY - jogador.velocidade * dt
    end
    if love.keyboard.isDown("down", "s") then
        novoY = novoY + jogador.velocidade * dt
    end

    -- Verificar colis√£o com obst√°culos antes de mover
    local futuro = {
        x = novoX,
        y = novoY,
        largura = jogador.largura,
        altura = jogador.altura
    }

    local podeMove = true
    for i, obstaculo in ipairs(obstaculos) do
        if colidiu(futuro, obstaculo) then
            podeMove = false
            break
        end
    end

    -- Manter dentro da tela
    if novoX < 0 or novoX + jogador.largura > love.graphics.getWidth() or
        novoY < 0 or novoY + jogador.altura > love.graphics.getHeight() then
        podeMove = false
    end

    -- Aplicar movimento se poss√≠vel
    if podeMove then
        jogador.x = novoX
        jogador.y = novoY
    end

    -- Verificar coleta de moedas
    for i, moeda in ipairs(moedas) do
        if not moeda.coletada and colidiu(jogador, moeda) then
            moeda.coletada = true
            pontuacao = pontuacao + moeda.valor
            moedasColetadas = moedasColetadas + 1

            -- Som de coleta (simulado com print)
            if moeda.valor > 10 then
                print("Moeda especial coletada! +" .. moeda.valor .. " pontos!")
            else
                print("Moeda coletada! +" .. moeda.valor .. " pontos")
            end

            -- Verificar vit√≥ria
            if moedasColetadas >= totalMoedas then
                jogoGanho = true
                print("Parab√©ns! Jogo completado em " .. math.floor(tempo) .. " segundos!")
            end
        end
    end
end

function love.draw()
    -- Fundo
    love.graphics.setColor(40 / 255, 42 / 255, 54 / 255) -- Cor #282A36
    love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), love.graphics.getHeight())

    -- Obst√°culos
    love.graphics.setColor(255 / 255, 85 / 255, 85 / 255) -- Cor #FF5555
    for i, obstaculo in ipairs(obstaculos) do
        love.graphics.rectangle("fill", obstaculo.x, obstaculo.y, obstaculo.largura, obstaculo
            .altura)
    end

    -- Contorno dos obst√°culos
    love.graphics.setColor(255 / 255, 121 / 255, 198 / 255) -- Cor #FF79C6
    for i, obstaculo in ipairs(obstaculos) do
        love.graphics.rectangle("line", obstaculo.x, obstaculo.y, obstaculo.largura, obstaculo
            .altura)
    end

    -- Moedas
    for i, moeda in ipairs(moedas) do
        if not moeda.coletada then
            if moeda.valor > 10 then
                love.graphics.setColor(255 / 255, 184 / 255, 108 / 255) -- Cor #FFB86C para moeda especial
            else
                love.graphics.setColor(241 / 255, 250 / 255, 140 / 255) -- Cor #F1FA8C para moeda normal
            end

            local centroX = moeda.x + moeda.largura / 2
            local centroY = moeda.y + moeda.altura / 2
            love.graphics.circle("fill", centroX, centroY, moeda.largura / 2)

            -- Brilho da moeda especial
            if moeda.valor > 10 then
                love.graphics.setColor(1, 1, 1, 0.3)
                love.graphics.circle("fill", centroX, centroY, moeda.largura / 2 + 3)
            end
        end
    end

    -- Jogador
    love.graphics.setColor(jogador.cor)
    love.graphics.rectangle("fill", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Contorno do jogador
    love.graphics.setColor(189 / 255, 147 / 255, 249 / 255) -- Cor #BD93F9
    love.graphics.rectangle("line", jogador.x, jogador.y, jogador.largura, jogador.altura)

    -- Interface
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("Pontua√ß√£o: " .. pontuacao, 10, 10)
    love.graphics.print("Moedas: " .. moedasColetadas .. "/" .. totalMoedas, 10, 35)
    love.graphics.print("Tempo: " .. math.floor(tempo) .. "s", 10, 60)

    -- Controles
    love.graphics.setColor(0.7, 0.7, 0.7)
    love.graphics.print("Use WASD ou setas para mover", 10, love.graphics.getHeight() - 25)

    -- Mensagem de vit√≥ria
    if jogoGanho then
        love.graphics.setColor(0, 0, 0, 0.7)
        love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), love.graphics.getHeight())

        love.graphics.setColor(1, 1, 0)
        local msg = "PARAB√âNS!"
        local largura = fonte:getWidth(msg)
        love.graphics.print(msg, (love.graphics.getWidth() - largura) / 2, 200)

        love.graphics.setColor(1, 1, 1)
        local msg2 = "Pontua√ß√£o Final: " .. pontuacao
        local largura2 = fonte:getWidth(msg2)
        love.graphics.print(msg2, (love.graphics.getWidth() - largura2) / 2, 230)

        local msg3 = "Tempo: " .. math.floor(tempo) .. " segundos"
        local largura3 = fonte:getWidth(msg3)
        love.graphics.print(msg3, (love.graphics.getWidth() - largura3) / 2, 260)

        local msg4 = "Pressione R para reiniciar"
        local largura4 = fonte:getWidth(msg4)
        love.graphics.print(msg4, (love.graphics.getWidth() - largura4) / 2, 290)

        love.graphics.setColor(0.8, 0.8, 0.8)
        local msg5 = "Pressione ESC para sair"
        local largura5 = fonte:getWidth(msg5)
        love.graphics.print(msg5, (love.graphics.getWidth() - largura5) / 2, 320)
    end
end

function love.keypressed(key)
    if key == "escape" then
        love.event.quit()
    end

    if key == "r" and jogoGanho then
        -- Reiniciar jogo
        for i, moeda in ipairs(moedas) do
            moeda.coletada = false
        end
        pontuacao = 0
        moedasColetadas = 0
        tempo = 0
        jogoGanho = false
        jogador.x = 50
        jogador.y = 50
    end
end
```

---

## üìö Conceitos Avan√ßados

### Colis√£o Circular

Para objetos circulares, use dist√¢ncia entre centros:

```lua
function colisaoCircular(a, b)
    local dx = (a.x + a.raio) - (b.x + b.raio)
    local dy = (a.y + a.raio) - (b.y + b.raio)
    local distancia = math.sqrt(dx*dx + dy*dy)
    return distancia < (a.raio + b.raio)
end
```

### Sistema de Camadas de Colis√£o

```lua
-- Diferentes tipos de colis√£o
CAMADAS = {
    JOGADOR = 1,
    INIMIGO = 2,
    ITEM = 4,
    PAREDE = 8
}

function verificarColisaoCamada(objeto1, objeto2, camada1, camada2)
    if (objeto1.camada & camada1) > 0 and (objeto2.camada & camada2) > 0 then
        return colidiu(objeto1, objeto2)
    end
    return false
end
```

---

## ‚úÖ Conclus√£o do Cap√≠tulo

Voc√™ aprendeu:

**Detec√ß√£o de Colis√µes AABB**: A t√©cnica fundamental para detectar sobreposi√ß√£o entre ret√¢ngulos alinhados aos eixos

**Resolu√ß√£o de Colis√µes**: Como impedir movimento inv√°lido usando verifica√ß√£o preventiva de posi√ß√µes futuras

**M√∫ltiplos Objetos**: Como verificar colis√µes eficientemente com listas de obst√°culos usando loops

**Sistemas de Coleta**: Como implementar mec√¢nicas de coleta de itens que desaparecem e aumentam pontua√ß√£o

**Projeto Completo**: Como combinar todos os conceitos em um jogo funcional com obst√°culos, coleta e interface

### üí° Dicas de Boas Pr√°ticas

-   Sempre use verifica√ß√£o preventiva em vez de corre√ß√£o ap√≥s colis√£o
-   Separe movimento horizontal e vertical para colis√µes mais suaves
-   Use loops eficientes e saia cedo (`break`) quando encontrar a primeira colis√£o
-   Organize objetos em categorias para otimizar verifica√ß√µes
-   Mantenha as fun√ß√µes de colis√£o simples e reutiliz√°veis
-   Teste colis√µes nas bordas da tela para evitar que objetos saiam do jogo
