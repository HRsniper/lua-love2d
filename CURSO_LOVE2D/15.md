# üß™ Cap√≠tulo 15: Debugging e Boas Pr√°ticas L√ñVE2D

## üéØ Objetivo

Ensinar como depurar erros, aplicar boas pr√°ticas de organiza√ß√£o e otimiza√ß√£o, e preparar seu jogo para manuten√ß√£o e expans√£o futura.

---

## üêû 15.1 Debugging com print

A forma mais simples de depurar em Lua √© usando `print()` para inspecionar valores.

```lua

function love.update(dt)
    print("Posi√ß√£o do jogador:", jogador.x, jogador.y)
end
```

Use com modera√ß√£o ‚Äî excesso de print pode afetar performance.

## üîç 15.2 Usando love.errhand

Voc√™ pode personalizar o tratamento de erros com `love.errhand`.

```lua
function love.errhand(msg)
    return "Erro detectado: " .. tostring(msg)
end
```

---

## üßπ 15.3 Boas Pr√°ticas de C√≥digo Limpo

### Estrutura de Projeto Profissional

```txt
meu_jogo/
‚îú‚îÄ‚îÄ main.lua                 # Ponto de entrada
‚îú‚îÄ‚îÄ conf.lua                 # Configura√ß√µes L√ñVE
‚îú‚îÄ‚îÄ assets/                  # Assets do jogo
‚îÇ   ‚îú‚îÄ‚îÄ images/
‚îÇ   ‚îú‚îÄ‚îÄ sounds/
‚îÇ   ‚îî‚îÄ‚îÄ fonts/
‚îú‚îÄ‚îÄ src/                     # C√≥digo fonte
‚îÇ   ‚îú‚îÄ‚îÄ core/                # Sistemas centrais
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game.lua
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ state_manager.lua
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ input_manager.lua
‚îÇ   ‚îú‚îÄ‚îÄ entities/            # Entidades do jogo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ player.lua
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ enemy.lua
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bullet.lua
‚îÇ   ‚îú‚îÄ‚îÄ states/              # Estados do jogo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ menu.lua
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gameplay.lua
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ game_over.lua
‚îÇ   ‚îú‚îÄ‚îÄ systems/             # Sistemas ECS
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ movement.lua
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ collision.lua
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rendering.lua
‚îÇ   ‚îî‚îÄ‚îÄ utils/               # Utilit√°rios
‚îÇ       ‚îú‚îÄ‚îÄ math.lua
‚îÇ       ‚îú‚îÄ‚îÄ table.lua
‚îÇ       ‚îî‚îÄ‚îÄ string.lua
‚îú‚îÄ‚îÄ debug/                   # Sistema de debug
‚îú‚îÄ‚îÄ test/                    # Testes
‚îú‚îÄ‚îÄ docs/                    # Documenta√ß√£o
‚îî‚îÄ‚îÄ builds/                  # Builds geradas
```

### Padr√µes de Nomenclatura

```lua
-- naming_conventions.lua

-- CONSTANTES (UPPER_SNAKE_CASE)
local GRAVITY = 9.81
local MAX_HEALTH = 100
local DEFAULT_SPEED = 200

-- Vari√°veis locais (camelCase ou snake_case - seja consistente)
local current_state = "menu"
local player_position = {x = 0, y = 0}
local is_game_paused = false

-- Fun√ß√µes (camelCase ou snake_case - seja consistente)
local function calculateDistance(x1, y1, x2, y2)
    return math.sqrt((x2 - x1)^2 + (y2 - y1)^2)
end

local function calculate_distance(dt)
    -- Implementa√ß√£o
end

-- Classes/M√≥dulos (PascalCase)
local PlayerController = {}
local GameStateManager = {}
local CollisionSystem = {}

-- Arquivos (snake_case)
-- player_controller.lua
-- game_state_manager.lua
-- collision_system.lua

-- Prefixos para diferentes tipos
local g_game_state = "global"    -- g_ para globais
local m_module_data = {}         -- m_ para dados de m√≥dulo
local p_private_func = function() end -- p_ para privadas
local cfg_window_width = 800     -- cfg_ para configura√ß√µes

-- Booleans com prefixos claros
local is_player_alive = true
local has_power_up = false
local can_jump = true
local should_respawn = false

-- Cole√ß√µes no plural
local enemies = {}
local bullets = {}
local power_ups = {}
local animations = {}
```

---

## ‚ö° 15.4 Otimiza√ß√£o de Performance

-   Evite recriar objetos em loops (ex: imagens, fontes)
-   Use `local` para vari√°veis acessadas com frequ√™ncia
-   Remova objetos fora da tela com `table.remove`
-   Prefira `ipairs` para listas ordenadas `{423, 425, 426}`
-   Use `pairs` para listas chave/valor `{umnomoe="lua5.4"}`

---

### Profiler de Performance

```lua
-- debug/profiler.lua
local Profiler = {}

Profiler.sections = {}
Profiler.current_frame = {}
Profiler.history = {}
Profiler.max_history = 60
Profiler.enabled = true

function Profiler:start(name)
    if not self.enabled then return end

    self.current_frame[name] = {
        start_time = love.timer.getTime(),
        start_memory = collectgarbage("count")
    }
end

function Profiler:stop(name)
    if not self.enabled or not self.current_frame[name] then return end

    local section = self.current_frame[name]
    local duration = love.timer.getTime() - section.start_time
    local memory_used = collectgarbage("count") - section.start_memory

    if not self.sections[name] then
        self.sections[name] = {
            total_time = 0,
            call_count = 0,
            avg_time = 0,
            max_time = 0,
            min_time = math.huge,
            memory_usage = 0
        }
    end

    local stats = self.sections[name]
    stats.total_time = stats.total_time + duration
    stats.call_count = stats.call_count + 1
    stats.avg_time = stats.total_time / stats.call_count
    stats.max_time = math.max(stats.max_time, duration)
    stats.min_time = math.min(stats.min_time, duration)
    stats.memory_usage = memory_used

    self.current_frame[name] = nil
end

function Profiler:endFrame()
    if not self.enabled then return end

    -- Salvar dados do frame atual
    local frame_data = {}
    for name, stats in pairs(self.sections) do
        frame_data[name] = {
            avg_time = stats.avg_time,
            memory_usage = stats.memory_usage
        }
    end

    table.insert(self.history, frame_data)

    if #self.history > self.max_history then
        table.remove(self.history, 1)
    end

    -- Reset para pr√≥ximo frame
    self.sections = {}
end

function Profiler:getReport()
    local report = {}

    for name, stats in pairs(self.sections) do
        table.insert(report, {
            name = name,
            avg_time = stats.avg_time * 1000, -- ms
            max_time = stats.max_time * 1000,
            min_time = stats.min_time * 1000,
            call_count = stats.call_count,
            memory = stats.memory_usage
        })
    end

    -- Ordenar por tempo m√©dio
    table.sort(report, function(a, b)
        return a.avg_time > b.avg_time
    end)

    return report
end

function Profiler:draw()
    if not self.enabled then return end

    local report = self:getReport()
    local font = love.graphics.getFont()
    local y = 10
    local line_height = font:getHeight() + 2

    love.graphics.setColor(0, 0, 0, 0.7)
    love.graphics.rectangle("fill", love.graphics.getWidth() - 300, 0, 300, 200)

    love.graphics.setColor(1, 1, 1)
    love.graphics.print("PROFILER", love.graphics.getWidth() - 290, y)
    y = y + line_height * 2

    for i, section in ipairs(report) do
        if i > 8 then break end -- Limitar exibi√ß√£o

        local text = string.format("%s: %.2fms (%.1fKB)",
            section.name, section.avg_time, section.memory)

        -- Colorir baseado na performance
        if section.avg_time > 5 then
            love.graphics.setColor(1, 0, 0) -- Vermelho para lento
        elseif section.avg_time > 2 then
            love.graphics.setColor(1, 1, 0) -- Amarelo para m√©dio
        else
            love.graphics.setColor(0, 1, 0) -- Verde para r√°pido
        end

        love.graphics.print(text, love.graphics.getWidth() - 290, y)
        y = y + line_height
    end
end

-- Macro para facilitar uso
function Profiler:profile(name, func, ...)
    self:start(name)
    local results = {func(...)}
    self:stop(name)
    return unpack(results)
end

return Profiler
```

```lua
-- to usando um Exemplo do cap11
-- main.lua
local Profiler = require("debug.profiler") -- ajuste o caminho conforme necess√°rio

function love.update(dt)
    Profiler:start("update")
    -- Seu c√≥digo de aqui

    Profiler:stop("update")
    Profiler:endFrame()
end

function love.draw()
    Profiler:profile("draw", function()
        -- Seu c√≥digo de aqui
    end)
    Profiler:draw()
end
```

---

### M√©tricas e Analytics

Exemplo:

```lua
-- src/analytics/metrics.lua
local Metrics = {}

Metrics.events = {}
Metrics.session_data = {
    start_time = 0,
    play_time = 0,
    level_attempts = {},
    deaths = 0,
    score = 0
}

function Metrics:init()
    self.session_data.start_time = love.timer.getTime()

    -- Carregar dados persistentes
    self:loadPersistentData()
end

function Metrics:trackEvent(event_name, properties)
    local event = {
        name = event_name,
        timestamp = love.timer.getTime(),
        session_time = self:getSessionTime(),
        properties = properties or {}
    }

    table.insert(self.events, event)

    if Console then
        Console:debug("Evento:", event_name, json.encode(properties or {}))
    end

    -- Processar eventos especiais
    self:processEvent(event)
end

function Metrics:processEvent(event)
    local name = event.name
    local props = event.properties

    if name == "player_death" then
        self.session_data.deaths = self.session_data.deaths + 1
    elseif name == "level_complete" then
        local level = props.level or "unknown"
        if not self.session_data.level_attempts[level] then
            self.session_data.level_attempts[level] = 0
        end
        self.session_data.level_attempts[level] =
            self.session_data.level_attempts[level] + 1
    elseif name == "score_change" then
        self.session_data.score = props.new_score or self.session_data.score
    end
end

function Metrics:getSessionTime()
    return love.timer.getTime() - self.session_data.start_time
end

function Metrics:getSessionReport()
    return {
        session_time = self:getSessionTime(),
        events_count = #self.events,
        deaths = self.session_data.deaths,
        score = self.session_data.score,
        levels_attempted = self.session_data.level_attempts
    }
end

function Metrics:loadPersistentData()
    if love.filesystem.getInfo("metrics.json") then
        local content = love.filesystem.read("metrics.json")
        local data = json.decode(content)

        -- Merge com dados da sess√£o
        for key, value in pairs(data) do
            if key ~= "start_time" then
                self.session_data[key] = value
            end
        end
    end
end

function Metrics:savePersistentData()
    local data = self:deepCopy(self.session_data)
    data.last_save = os.date()

    love.filesystem.write("metrics.json", json.encode(data))
end

function Metrics:deepCopy(original)
    local copy = {}
    for key, value in pairs(original) do
        if type(value) == "table" then
            copy[key] = self:deepCopy(value)
        else
            copy[key] = value
        end
    end
    return copy
end

-- Shortcuts para eventos comuns
function Metrics:playerDied(cause, position)
    self:trackEvent("player_death", {
        cause = cause,
        x = position and position.x,
        y = position and position.y
    })
end

function Metrics:levelStarted(level_name)
    self:trackEvent("level_start", {level = level_name})
end

function Metrics:levelCompleted(level_name, time, score)
    self:trackEvent("level_complete", {
        level = level_name,
        time = time,
        score = score
    })
end

function Metrics:itemCollected(item_type, item_name)
    self:trackEvent("item_collected", {
        type = item_type,
        name = item_name
    })
end

return Metrics
```

## ‚úÖ Conclus√£o do Cap√≠tulo

Voc√™ aprendeu:

-   Como depurar com print e love.errhand
-   Como organizar seu c√≥digo em m√≥dulos
-   Como aplicar boas pr√°ticas de legibilidade e manuten√ß√£o
-   Como otimizar performance e evitar gargalos
