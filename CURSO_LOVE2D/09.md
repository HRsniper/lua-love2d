# ðŸš€ CapÃ­tulo 9: Criando um Jogo Completo â€” _Shoot the Enemy_

## ðŸŽ¯ Objetivo

Desenvolver um jogo completo onde o jogador controla um personagem que dispara projÃ©teis para eliminar inimigos. O jogo terÃ¡ pontuaÃ§Ã£o, colisÃµes, spawn de inimigos e organizaÃ§Ã£o em mÃºltiplos arquivos usando boas prÃ¡ticas de programaÃ§Ã£o.

---

## ðŸ§© 9.1 Estrutura do Projeto

### OrganizaÃ§Ã£o dos Arquivos

```
shoot_the_enemy/
â”œâ”€â”€ main.lua           # Arquivo principal do jogo
â”œâ”€â”€ player.lua          # MÃ³dulo do jogador
â”œâ”€â”€ bullet.lua          # Sistema de projÃ©teis
â”œâ”€â”€ enemy.lua           # Sistema de inimigos
â”œâ”€â”€ collision.lua       # Sistema de colisÃµes
â”œâ”€â”€ gamestate.lua       # Estados do jogo
â””â”€â”€ assets/             # Recursos do jogo
    â”œâ”€â”€ player.png      # Sprite do jogador
    â”œâ”€â”€ enemy.png       # Sprite do inimigo
    â”œâ”€â”€ bullet.png      # Sprite do projÃ©til
    â”œâ”€â”€ background.png  # Fundo do jogo
    â””â”€â”€ shoot.wav       # Som do disparo
```

### Vantagens da OrganizaÃ§Ã£o Modular

-   **CÃ³digo mais limpo** e fÃ¡cil de manter
-   **ReutilizaÃ§Ã£o** de componentes
-   **Trabalho em equipe** mais eficiente
-   **Debugging** mais simples
-   **Escalabilidade** para projetos maiores

---

## ðŸ‘¤ 9.2 Arquivo `player.lua`

### VersÃ£o BÃ¡sica

```lua
local player = {
    img = love.graphics.newImage("assets/player.png"),
    x = 400,
    y = 500,
    speed = 300,
    quads = {},
    frameAtual = 0,
    velocidadeAnimacao = 0.2,
    tempoFrame = 0,
    height = 50,
    width = 50
}

-- Criar quads para cada frame da animaÃ§Ã£o (4 frames de 50x50)
for i = 0, 3 do
    player.quads[i] = love.graphics.newQuad(i * player.width, 0, player.width, player.height,
        player.img:getDimensions())
end

function player.update(dt)
    if love.keyboard.isDown("a", "left") then
        player.x = player.x - player.speed * dt
    elseif love.keyboard.isDown("d", "right") then
        player.x = player.x + player.speed * dt
    end

    player.tempoFrame = player.tempoFrame + dt
    if player.tempoFrame >= player.velocidadeAnimacao then
        player.frameAtual = (player.frameAtual + 1) % 4
        player.tempoFrame = 0
    end

    -- Manter dentro da tela
    player.x = math.max(0, math.min(love.graphics.getWidth() - player.width, player.x))
end

function player.draw()
    love.graphics.draw(player.img, player.quads[player.frameAtual], player.x, player.y)
end

return player
```

---

## ðŸ”« 9.3 Arquivo `bullet.lua`

### Sistema de ProjÃ©teis BÃ¡sico

```lua
local bullet = {
    img = love.graphics.newImage("assets/bullet.png"),
    list = {},
    speed = 500,
}

bullet.imgWidth = bullet.img:getWidth()
bullet.imgHeight = bullet.img:getHeight()

function bullet.spawn(x, y)
    local center = bullet.imgWidth / 2 -- Centralizar
    table.insert(bullet.list, { x = x - center, y = y, speed = bullet.speed })
end

function bullet.update(dt)
    for i = #bullet.list, 1, -1 do
        local b = bullet.list[i]
        b.y = b.y - b.speed * dt

        -- Remover se saiu da tela
        if b.y < -bullet.imgHeight then
            table.remove(bullet.list, i)
        end
    end
end

function bullet.draw()
    for _, b in ipairs(bullet.list) do
        love.graphics.draw(bullet.img, b.x, b.y)
    end
end

function bullet.remove(index)
    table.remove(bullet.list, index)
end

function bullet.clear()
    bullet.list = {}
end

return bullet
```

---

## ðŸ‘¾ 9.4 Arquivo `enemy.lua`

### Sistema BÃ¡sico de Inimigos

```lua
local enemy = {
    img = love.graphics.newImage("assets/enemy.png"),
    list = {},
    spawnTimer = 0,
    quads = {},
    frameAtual = 0,
    velocidadeAnimacao = 0.2,
    tempoFrame = 0,
    height = 50,
    width = 50,
    health = 1,
    speed = 100,
    spawnRate = 2.0
}

-- Criar quads para cada frame da animaÃ§Ã£o (4 frames de 50x50)
for i = 0, 3 do
    enemy.quads[i] = love.graphics.newQuad(i * enemy.width, 0, enemy.width, enemy.height,
        enemy.img:getDimensions())
end

function enemy.spawn()
    local x = math.random(0, 750)
    table.insert(enemy.list,
        {
            x = x,
            y = -enemy.height,
            speed = enemy.speed + math.random(-20, 20), --VariaÃ§Ã£o na velocidade
            health = enemy.health
        })
end

function enemy.update(dt)
    enemy.spawnTimer = enemy.spawnTimer + dt
    if enemy.spawnTimer > enemy.spawnRate then
        enemy.spawn()
        enemy.spawnTimer = 0
        -- Aumentar dificuldade gradualmente
        enemy.spawnRate = math.max(0.5, enemy.spawnRate - 0.01)
    end

    for i = #enemy.list, 1, -1 do
        local e = enemy.list[i]
        e.y = e.y + e.speed * dt

        -- Remover se saiu da tela
        if e.y > love.graphics.getHeight() then
            table.remove(enemy.list, i)
        end
    end

    enemy.tempoFrame = enemy.tempoFrame + dt
    if enemy.tempoFrame >= enemy.velocidadeAnimacao then
        enemy.frameAtual = (enemy.frameAtual + 1) % 4
        enemy.tempoFrame = 0
    end
end

function enemy.draw()
    for _, e in ipairs(enemy.list) do
        love.graphics.draw(enemy.img, enemy.quads[enemy.frameAtual], e.x, e.y)
    end
end

function enemy.remove(index)
    table.remove(enemy.list, index)
end

function enemy.clear()
    enemy.list = {}
end

return enemy
```

---

### VersÃ£o AvanÃ§ada com Vida

```lua
local player = {
    img = love.graphics.newImage("assets/player.png"),
    x = 400,
    y = 500,
    speed = 300,
    quads = {},
    frameAtual = 0,
    velocidadeAnimacao = 0.2,
    tempoFrame = 0,
    height = 50,
    width = 50,

    -- Sistema de vida
    maxHealth = 3,
    health = maxHealth,
    invulnerable = false,
    invulnerableTime = 0,
    invulnerableDuration = 2.0
}

-- Criar quads para cada frame da animaÃ§Ã£o (4 frames de 50x50)
for i = 0, 3 do
    player.quads[i] = love.graphics.newQuad(i * player.width, 0, player.width, player.height,
        player.img:getDimensions())
end

function player.update(dt)
    if love.keyboard.isDown("a", "left") then
        player.x = player.x - player.speed * dt
    elseif love.keyboard.isDown("d", "right") then
        player.x = player.x + player.speed * dt
    end

    player.tempoFrame = player.tempoFrame + dt
    if player.tempoFrame >= player.velocidadeAnimacao then
        player.frameAtual = (player.frameAtual + 1) % 4
        player.tempoFrame = 0
    end

    -- Manter dentro da tela
    player.x = math.max(0, math.min(love.graphics.getWidth() - player.width, player.x))

    -- Invulnerabilidade
    if player.invulnerable then
        player.invulnerableTime = player.invulnerableTime - dt
        if player.invulnerableTime <= 0 then
            player.invulnerable = false
        end
    end
end

function player.draw()
    love.graphics.setColor(1, 1, 1)
    love.graphics.draw(player.img, player.quads[player.frameAtual], player.x, player.y)

    -- Efeito de piscar quando invulnerÃ¡vel
    if player.invulnerable and math.floor(player.invulnerableTime * 10) % 2 == 0 then
        return -- NÃ£o desenhar (efeito piscante)
    end
end

function player.takeDamage()
    if not player.invulnerable then
        player.health = player.health - 1
        player.invulnerable = true
        player.invulnerableTime = player.invulnerableDuration
        return true -- Dano aplicado
    end
    return false    -- Sem dano (invulnerÃ¡vel)
end

function player.isDead()
    return player.health <= 0
end

return player
```

### Sistema AvanÃ§ado com Diferentes Tipos

```lua
local player = require("player")

local bullet = {
    img = love.graphics.newImage("assets/bullet.png"),
    list = {},

    types = {
        normal = {
            speed = 500,
            damage = 1,
            color = { 1, 0, 0, 0.3 },
        },
        rapid = {
            speed = 700,
            damage = 1,
            color = { 0, 1, 0, 0.3 },
        },
        heavy = {
            speed = 300,
            damage = 3,
            color = { 0, 0, 1, 0.3 },
        }
    }
}

bullet.imgWidth = bullet.img:getWidth()
bullet.imgHeight = bullet.img:getHeight()

function bullet.spawn(x, y, bulletType)
    bulletType = bulletType or "normal"
    local typeData = bullet.types[bulletType]
    local center = (bullet.imgWidth - player.width) / 2 -- Centralizar
    table.insert(bullet.list,
        {
            x = x - center,
            y = y,
            speed = typeData.speed,
            damage = typeData.damage,
            color = typeData.color,
            width = bullet.imgWidth,
            height = bullet.imgWidth
        })
end

function bullet.update(dt)
    for i = #bullet.list, 1, -1 do
        local b = bullet.list[i]
        b.y = b.y - b.speed * dt

        -- Remover se saiu da tela
        if b.y < -bullet.imgHeight then
            table.remove(bullet.list, i)
        end
    end
end

function bullet.draw()
    for _, b in ipairs(bullet.list) do
        love.graphics.setColor(1, 1, 1) -- reset
        love.graphics.draw(bullet.img, b.x, b.y)

        love.graphics.setColor(b.color)
        love.graphics.rectangle("fill", b.x, b.y, b.width, b.height) -- cor do tipo
    end

    love.graphics.setColor(1, 1, 1) -- reset
end

function bullet.remove(index)
    table.remove(bullet.list, index)
end

function bullet.clear()
    bullet.list = {}
end

return bullet
```

---

### Sistema AvanÃ§ado com Tipos Diferentes

```lua
local enemy = {
    img = love.graphics.newImage("assets/enemy.png"),
    list = {},
    quads = {},
    frameAtual = 0,
    velocidadeAnimacao = 0.2,
    tempoFrame = 0,
    height = 50,
    width = 50,
    spawnTimer = 0,
    spawnRate = 2.0,

    types = {
        basic = {
            speed = 100,
            health = 1,
            points = 10,
            color = { 1, 0, 0, 0.03 },
        },
        fast = {
            speed = 200,
            health = 1,
            points = 20,
            color = { 0, 1, 0, 0.03 },
        },
        tank = {
            speed = 50,
            health = 3,
            points = 50,
            color = { 0, 0, 1, 0.03 },
        }
    }
}

-- Criar quads para cada frame da animaÃ§Ã£o (4 frames de 50x50)
for i = 0, 3 do
    enemy.quads[i] = love.graphics.newQuad(i * enemy.width, 0, enemy.width, enemy.height,
        enemy.img:getDimensions())
end

function enemy.spawn(enemyType)
    enemyType = enemyType or "basic"
    local typeData = enemy.types[enemyType]
    local x = math.random(0, love.graphics.getWidth() - enemy.width)
    table.insert(enemy.list,
        {
            x = x,
            y = -enemy.height,
            speed = typeData.speed + math.random(-20, 20), --VariaÃ§Ã£o na velocidade
            health = typeData.health,
            maxHealth = typeData.health,
            points = typeData.points,
            color = typeData.color,
            width = enemy.width,
            height = enemy.height,
            type = enemyType
        })
end

function enemy.spawnRandom()
    local rand = math.random()
    if rand < 0.6 then
        enemy.spawn("basic")
    elseif rand < 0.85 then
        enemy.spawn("fast")
    else
        enemy.spawn("tank")
    end
end

function enemy.update(dt)
    enemy.spawnTimer = enemy.spawnTimer + dt
    if enemy.spawnTimer > enemy.spawnRate then
        enemy.spawn()
        enemy.spawnTimer = 0
        -- Aumentar dificuldade gradualmente
        enemy.spawnRate = math.max(0.5, enemy.spawnRate - 0.01)
    end

    for i = #enemy.list, 1, -1 do
        local e = enemy.list[i]
        e.y = e.y + e.speed * dt

        -- Remover se saiu da tela
        if e.y > love.graphics.getHeight() then
            table.remove(enemy.list, i)
        end
    end

    enemy.tempoFrame = enemy.tempoFrame + dt
    if enemy.tempoFrame >= enemy.velocidadeAnimacao then
        enemy.frameAtual = (enemy.frameAtual + 1) % 4
        enemy.tempoFrame = 0
    end
end

function enemy.draw()
    for _, e in ipairs(enemy.list) do
        love.graphics.setColor(1, 1, 1) -- reset
        love.graphics.draw(enemy.img, enemy.quads[enemy.frameAtual], e.x, e.y)

        love.graphics.setColor(e.color)
        love.graphics.rectangle("fill", e.x, e.y, e.width, e.height) -- cor do tipo

        -- Barra de vida para inimigos com mais de 1 HP
        if e.maxHealth > 1 then
            local barWidth = e.width
            local barHeight = 5
            local healthPercent = e.health / e.maxHealth

            love.graphics.setColor(1, 0, 0)
            love.graphics.rectangle("fill", e.x, e.y - 10, barWidth, barHeight)
            love.graphics.setColor(0, 1, 0)
            love.graphics.rectangle("fill", e.x, e.y - 10, barWidth * healthPercent, barHeight)
        end
    end

    love.graphics.setColor(1, 1, 1) -- reset
end

function enemy.takeDamage(index, damage)
    if enemy.list[index] then
        enemy.list[index].health = enemy.list[index].health - damage
        return enemy.list[index].health <= 0, enemy.list[index].points
    end
    return false, 0
end

function enemy.remove(index)
    table.remove(enemy.list, index)
end

function enemy.clear()
    enemy.list = {}
end

return enemy
```

---

## ðŸ§  9.5 Arquivo `main.lua`

### VersÃ£o Completa e Otimizada

```lua
local player = require("player")
local bullet = require("bullet")
local enemy = require("enemy")

-- VariÃ¡veis do jogo
local gameState = "playing" -- "playing", "paused", "gameover"
local score = 0
local highScore = 0

-- Som
local shootSound = love.audio.newSource("assets/shoot.ogg", "static")
local hitSound = love.audio.newSource("assets/hitsound.ogg", "static")

-- ConfiguraÃ§Ãµes
local config = {
    fireRate = 0.15,
    lastShot = 0
}

local backgroundImg = love.graphics.newImage("assets/background.png")

function love.load()
    love.window.setTitle("Shoot the Enemy")

    -- Carregar fonte
    local font = love.graphics.newFont(20)
    love.graphics.setFont(font)

    -- Carregar high score
    local file = io.open("highscore.txt", "r")
    if file then
        local content = file:read("*a")
        file:close()
        highScore = tonumber(content) or 0
    end
end

function love.update(dt)
    if gameState == "playing" then
        -- Atualizar rate de tiro
        config.lastShot = config.lastShot + dt

        -- Atualizar jogador
        player.update(dt)

        -- Verificar se jogador morreu
        if player.isDead() then
            gameState = "gameover"
            -- Salvar high score
            if score > highScore then
                highScore = score
                local file = io.open("highscore.txt", "w")
                if file then
                    file:write(tostring(highScore))
                    file:close()
                end
            end
            return
        end

        -- Atualizar projÃ©teis e inimigos
        bullet.update(dt)
        enemy.update(dt)

        -- Verificar colisÃµes entre projÃ©teis e inimigos
        for bulletIndex = #bullet.list, 1, -1 do
            local bulletType = bullet.list[bulletIndex]
            local bulletBounds = {
                x = bulletType.x,
                y = bulletType.y,
                width = bulletType.width,
                height = bulletType.height
            }

            for enemyIndex = #enemy.list, 1, -1 do
                local enemyType = enemy.list[enemyIndex]
                local enemyBounds = {
                    x = enemyType.x,
                    y = enemyType.y,
                    width = enemyType.width,
                    height = enemyType.height
                }

                if checkCollision(bulletBounds, enemyBounds) then
                    -- Aplicar dano ao inimigo
                    local died, points = enemy.takeDamage(enemyIndex, bulletType.damage or 1)
                    if died then
                        score = score + points
                        enemy.remove(enemyIndex)
                    end

                    bullet.remove(bulletIndex)
                    hitSound:play()
                    break
                end
            end
        end

        -- Verificar colisÃµes entre jogador e inimigos
        local playerBounds = {
            x = player.x,
            y = player.y,
            width = player.width,
            height = player
                .height
        }
        for enemyIndex = #enemy.list, 1, -1 do
            local enemyType = enemy.list[enemyIndex]
            local enemyBounds = {
                x = enemyType.x,
                y = enemyType.y,
                width = enemyType.width,
                height = enemyType.height
            }

            if checkCollision(playerBounds, enemyBounds) then
                if player.takeDamage() then
                    enemy.remove(enemyIndex)
                    hitSound:play()
                end
            end
        end
    elseif gameState == "paused" then
        -- Jogo pausado, nÃ£o atualizar nada
    end
end

function love.draw()
    love.graphics.draw(backgroundImg, 0, 0)

    if gameState == "playing" or gameState == "paused" then
        player.draw()
        bullet.draw()
        enemy.draw()

        -- Interface
        love.graphics.setColor(1, 1, 1)
        love.graphics.print("Score: " .. score, 10, 10)
        love.graphics.print("High Score: " .. highScore, 10, 35)
        love.graphics.print("Health: " .. player.health, 10, 60)

        -- Indicador de pausa
        if gameState == "paused" then
            love.graphics.setColor(0, 0, 0, 0.7)
            love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), love.graphics.getHeight())
            love.graphics.setColor(1, 1, 1)
            love.graphics.printf("PAUSED", 0, love.graphics.getHeight() / 2 - 10,
                love.graphics.getWidth(), "center")
            love.graphics.printf("Press P to continue", 0, love.graphics.getHeight() / 2 + 20,
                love.graphics.getWidth(), "center")
        end
    elseif gameState == "gameover" then
        -- Tela de game over
        love.graphics.setColor(1, 0, 0, 0.8)
        love.graphics.rectangle("fill", 0, 0, love.graphics.getWidth(), love.graphics.getHeight())

        love.graphics.setColor(1, 1, 1)
        love.graphics.printf("GAME OVER", 0, love.graphics.getHeight() / 2 - 60,
            love.graphics.getWidth(), "center")
        love.graphics.printf("Final Score: " .. score, 0, love.graphics.getHeight() / 2 - 30,
            love.graphics.getWidth(), "center")
        love.graphics.printf("High Score: " .. highScore, 0, love.graphics.getHeight() / 2,
            love.graphics.getWidth(), "center")
        love.graphics.printf("Press R to restart", 0, love.graphics.getHeight() / 2 + 40,
            love.graphics.getWidth(), "center")
        love.graphics.printf("Press ESC to quit", 0, love.graphics.getHeight() / 2 + 70,
            love.graphics.getWidth(), "center")
    end

    -- InstruÃ§Ãµes
    if gameState == "playing" then
        love.graphics.setColor(0.7, 0.7, 0.7)
        love.graphics.print("A/D or Arrows: Move | Click/Space: Shoot | P: Pause", 10,
            love.graphics.getHeight() - 25)
    end
end

function love.mousepressed(x, y, button)
    -- Disparar projÃ©til quando o botÃ£o esquerdo for pressionado
    if button == 1 then tryToShoot() end
end

function love.keypressed(key)
    if gameState == "playing" then
        if key == "space" then
            tryToShoot()
        elseif key == "p" then
            gameState = "paused"
        end
    elseif gameState == "paused" then
        if key == "p" then
            gameState = "playing"
        end
    elseif gameState == "gameover" then
        if key == "r" then
            restartGame()
        elseif key == "escape" then
            love.event.quit()
        end
    end
end

function tryToShoot()
    if config.lastShot >= config.fireRate then
        bullet.spawn(player.x, player.y)
        config.lastShot = 0
        shootSound:play()
    end
end

function restartGame()
    -- Resetar variÃ¡veis do jogo
    gameState = "playing"
    score = 0
    config.lastShot = 0

    -- Resetar jogador
    player.x = love.graphics.getWidth() / 2 - player.width / 2
    player.y = 500
    player.health = player.maxHealth
    player.invulnerable = false
    player.invulnerableTime = 0

    -- Limpar listas
    bullet.clear()
    enemy.clear()

    -- Resetar spawn rate dos inimigos
    enemy.spawnTimer = 0
    enemy.spawnRate = 2.0
end

function checkCollision(a, b)
    return a.x < b.x + b.width and
        b.x < a.x + a.width and
        a.y < b.y + b.height and
        b.y < a.y + a.height
end
```

---

## ðŸŽ® 9.6 Melhorias Adicionais

Exemplos:

### Sistema de Power-ups

```lua
-- Em um arquivo separado: powerup.lua
local powerup = {}
powerup.list = {}
powerup.types = {
    rapid = {color = {0, 1, 1}, effect = "rapidFire"},
    health = {color = {0, 1, 0}, effect = "heal"},
    multiShot = {color = {1, 0, 1}, effect = "multiShot"}
}

function powerup.spawn(x, y, type)
    table.insert(powerup.list, {
        x = x, y = y, type = type,
        width = 20, height = 20,
        speed = 50
    })
end

return powerup
```

### Sistema de PartÃ­culas para ExplosÃµes

```lua
-- Sistema simples de partÃ­culas
local particles = {}

function createExplosion(x, y)
    local system = love.graphics.newParticleSystem(texture, 32)
    system:setParticleLifetime(0.3, 0.8)
    system:setEmissionRate(100)
    system:setSizeVariation(1)
    system:setLinearAcceleration(-20, -20, 20, 20)
    system:setColors(1, 1, 0, 1, 1, 0, 0, 0)

    table.insert(particles, {
        system = system,
        x = x, y = y
    })

    system:emit(16)
end
```

### Sistema de Ondas

```lua
local wave = {
    current = 1,
    enemiesLeft = 10,
    break_time = 0
}

function wave.update(dt)
    if #enemy.list == 0 and wave.enemiesLeft == 0 then
        wave.break_time = wave.break_time + dt
        if wave.break_time >= 3 then
            wave.current = wave.current + 1
            wave.enemiesLeft = wave.current * 5
            wave.break_time = 0
        end
    end
end
```

---

## ðŸ’¡ OtimizaÃ§Ãµes e Boas PrÃ¡ticas

### Gerenciamento de MemÃ³ria

```lua
-- Limitar nÃºmero de objetos na tela
local MAX_BULLETS = 50
local MAX_ENEMIES = 20

function bullet.spawn(x, y)
    if #bullet.list >= MAX_BULLETS then
        table.remove(bullet.list, 1) -- Remove o mais antigo
    end
    table.insert(bullet.list, {x = x, y = y, speed = 500})
end
```

### Pool de Objetos

```lua
-- Reutilizar objetos em vez de criar/destruir
local bulletPool = {}
local activeBullets = {}

function getBulletFromPool()
    if #bulletPool > 0 then
        return table.remove(bulletPool)
    else
        return {x = 0, y = 0, active = false}
    end
end

function returnBulletToPool(bullet)
    bullet.active = false
    table.insert(bulletPool, bullet)
end
```

### Debugging

```lua
local DEBUG = false

function love.keypressed(key)
    if key == "f1" then
        DEBUG = not DEBUG
    end
end

function love.draw()
    -- ... cÃ³digo normal ...

    if DEBUG then
        love.graphics.print("FPS: " .. love.timer.getFPS(), 10, 100)
        love.graphics.print("Bullets: " .. #bullet.list, 10, 125)
        love.graphics.print("Enemies: " .. #enemy.list, 10, 150)
    end
end
```

---

## âœ… ConclusÃ£o do CapÃ­tulo

VocÃª desenvolveu:

**Jogo Completo Funcional**: Um shoot'em up com todos os elementos essenciais - movimento, tiro, inimigos, colisÃµes e pontuaÃ§Ã£o

**Arquitetura Modular**: OrganizaÃ§Ã£o profissional do cÃ³digo em mÃºltiplos arquivos, facilitando manutenÃ§Ã£o e expansÃ£o

**Sistemas de Jogo AvanÃ§ados**: Estados de jogo, sistema de vida, diferentes tipos de inimigos e projÃ©teis, high score persistente

**MecÃ¢nicas Polidas**: Rate limiting para tiros, invulnerabilidade temporal, aumento progressivo de dificuldade

**Interface Completa**: Telas de pausa e game over, controles intuitivos, feedback visual adequado

### ðŸ’¡ Dicas de Boas PrÃ¡ticas

-   Sempre organize cÃ³digo em mÃ³dulos para projetos maiores que facilitem manutenÃ§Ã£o e colaboraÃ§Ã£o
-   Use sistemas de pool de objetos para melhor performance em jogos com muitos elementos dinÃ¢micos
-   Implemente sistemas de debugging desde o inÃ­cio para facilitar desenvolvimento e testes
-   Mantenha separaÃ§Ã£o clara entre lÃ³gica de jogo, renderizaÃ§Ã£o e entrada do usuÃ¡rio
-   Use configuraÃ§Ãµes centralizadas para facilitar balanceamento e ajustes de gameplay
-   Sempre teste limites (muitos objetos na tela, situaÃ§Ãµes extremas) para garantir estabilidade
-   Considere persistÃªncia de dados (high scores, configuraÃ§Ãµes) para melhor experiÃªncia do usuÃ¡rio

### ðŸš€ PrÃ³ximas ExpansÃµes PossÃ­veis

-   Sistema de power-ups e upgrades
-   MÃºltiplos tipos de armas e muniÃ§Ã£o
-   Boss battles com padrÃµes de ataque complexos
-   Sistema de ondas com progressÃ£o de dificuldade
-   Efeitos visuais e sonoros mais elaborados
-   Menu principal e tela de configuraÃ§Ãµes
-   Sistema de conquistas e estatÃ­sticas
-   Multiplayer local ou online
